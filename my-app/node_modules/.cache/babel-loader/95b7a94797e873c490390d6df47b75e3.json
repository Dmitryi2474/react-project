{"ast":null,"code":"'use strict';\n\nvar url = require('url');\nexports = module.exports = function historyApiFallback(options) {\n  options = options || {};\n  var logger = getLogger(options);\n  return function (req, res, next) {\n    var headers = req.headers;\n    if (req.method !== 'GET') {\n      logger('Not rewriting', req.method, req.url, 'because the method is not GET.');\n      return next();\n    } else if (!headers || typeof headers.accept !== 'string') {\n      logger('Not rewriting', req.method, req.url, 'because the client did not send an HTTP accept header.');\n      return next();\n    } else if (headers.accept.indexOf('application/json') === 0) {\n      logger('Not rewriting', req.method, req.url, 'because the client prefers JSON.');\n      return next();\n    } else if (!acceptsHtml(headers.accept, options)) {\n      logger('Not rewriting', req.method, req.url, 'because the client does not accept HTML.');\n      return next();\n    }\n    var parsedUrl = url.parse(req.url);\n    var rewriteTarget;\n    options.rewrites = options.rewrites || [];\n    for (var i = 0; i < options.rewrites.length; i++) {\n      var rewrite = options.rewrites[i];\n      var match = parsedUrl.pathname.match(rewrite.from);\n      if (match !== null) {\n        rewriteTarget = evaluateRewriteRule(parsedUrl, match, rewrite.to, req);\n        if (rewriteTarget.charAt(0) !== '/') {\n          logger('We recommend using an absolute path for the rewrite target.', 'Received a non-absolute rewrite target', rewriteTarget, 'for URL', req.url);\n        }\n        logger('Rewriting', req.method, req.url, 'to', rewriteTarget);\n        req.url = rewriteTarget;\n        return next();\n      }\n    }\n    var pathname = parsedUrl.pathname;\n    if (pathname.lastIndexOf('.') > pathname.lastIndexOf('/') && options.disableDotRule !== true) {\n      logger('Not rewriting', req.method, req.url, 'because the path includes a dot (.) character.');\n      return next();\n    }\n    rewriteTarget = options.index || '/index.html';\n    logger('Rewriting', req.method, req.url, 'to', rewriteTarget);\n    req.url = rewriteTarget;\n    next();\n  };\n};\nfunction evaluateRewriteRule(parsedUrl, match, rule, req) {\n  if (typeof rule === 'string') {\n    return rule;\n  } else if (typeof rule !== 'function') {\n    throw new Error('Rewrite rule can only be of type string or function.');\n  }\n  return rule({\n    parsedUrl: parsedUrl,\n    match: match,\n    request: req\n  });\n}\nfunction acceptsHtml(header, options) {\n  options.htmlAcceptHeaders = options.htmlAcceptHeaders || ['text/html', '*/*'];\n  for (var i = 0; i < options.htmlAcceptHeaders.length; i++) {\n    if (header.indexOf(options.htmlAcceptHeaders[i]) !== -1) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction getLogger(options) {\n  if (options && options.logger) {\n    return options.logger;\n  } else if (options && options.verbose) {\n    return console.log.bind(console);\n  }\n  return function () {};\n}","map":{"version":3,"names":["url","require","exports","module","historyApiFallback","options","logger","getLogger","req","res","next","headers","method","accept","indexOf","acceptsHtml","parsedUrl","parse","rewriteTarget","rewrites","i","length","rewrite","match","pathname","from","evaluateRewriteRule","to","charAt","lastIndexOf","disableDotRule","index","rule","Error","request","header","htmlAcceptHeaders","verbose","console","log","bind"],"sources":["/home/user/Рабочий стол/pizza/project/node_modules/connect-history-api-fallback/lib/index.js"],"sourcesContent":["'use strict';\n\nvar url = require('url');\n\nexports = module.exports = function historyApiFallback(options) {\n  options = options || {};\n  var logger = getLogger(options);\n\n  return function(req, res, next) {\n    var headers = req.headers;\n    if (req.method !== 'GET') {\n      logger(\n        'Not rewriting',\n        req.method,\n        req.url,\n        'because the method is not GET.'\n      );\n      return next();\n    } else if (!headers || typeof headers.accept !== 'string') {\n      logger(\n        'Not rewriting',\n        req.method,\n        req.url,\n        'because the client did not send an HTTP accept header.'\n      );\n      return next();\n    } else if (headers.accept.indexOf('application/json') === 0) {\n      logger(\n        'Not rewriting',\n        req.method,\n        req.url,\n        'because the client prefers JSON.'\n      );\n      return next();\n    } else if (!acceptsHtml(headers.accept, options)) {\n      logger(\n        'Not rewriting',\n        req.method,\n        req.url,\n        'because the client does not accept HTML.'\n      );\n      return next();\n    }\n\n    var parsedUrl = url.parse(req.url);\n    var rewriteTarget;\n    options.rewrites = options.rewrites || [];\n    for (var i = 0; i < options.rewrites.length; i++) {\n      var rewrite = options.rewrites[i];\n      var match = parsedUrl.pathname.match(rewrite.from);\n      if (match !== null) {\n        rewriteTarget = evaluateRewriteRule(parsedUrl, match, rewrite.to, req);\n\n        if(rewriteTarget.charAt(0) !== '/') {\n          logger(\n            'We recommend using an absolute path for the rewrite target.',\n            'Received a non-absolute rewrite target',\n            rewriteTarget,\n            'for URL',\n            req.url\n          );\n        }\n\n        logger('Rewriting', req.method, req.url, 'to', rewriteTarget);\n        req.url = rewriteTarget;\n        return next();\n      }\n    }\n\n    var pathname = parsedUrl.pathname;\n    if (pathname.lastIndexOf('.') > pathname.lastIndexOf('/') &&\n        options.disableDotRule !== true) {\n      logger(\n        'Not rewriting',\n        req.method,\n        req.url,\n        'because the path includes a dot (.) character.'\n      );\n      return next();\n    }\n\n    rewriteTarget = options.index || '/index.html';\n    logger('Rewriting', req.method, req.url, 'to', rewriteTarget);\n    req.url = rewriteTarget;\n    next();\n  };\n};\n\nfunction evaluateRewriteRule(parsedUrl, match, rule, req) {\n  if (typeof rule === 'string') {\n    return rule;\n  } else if (typeof rule !== 'function') {\n    throw new Error('Rewrite rule can only be of type string or function.');\n  }\n\n  return rule({\n    parsedUrl: parsedUrl,\n    match: match,\n    request: req\n  });\n}\n\nfunction acceptsHtml(header, options) {\n  options.htmlAcceptHeaders = options.htmlAcceptHeaders || ['text/html', '*/*'];\n  for (var i = 0; i < options.htmlAcceptHeaders.length; i++) {\n    if (header.indexOf(options.htmlAcceptHeaders[i]) !== -1) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction getLogger(options) {\n  if (options && options.logger) {\n    return options.logger;\n  } else if (options && options.verbose) {\n    return console.log.bind(console);\n  }\n  return function(){};\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}