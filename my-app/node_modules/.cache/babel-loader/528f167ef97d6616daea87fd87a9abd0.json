{"ast":null,"code":"var camelCase = require('camelcase');\nvar path = require('path');\nvar tokenizeArgString = require('./lib/tokenize-arg-string');\nvar util = require('util');\nfunction parse(args, opts) {\n  if (!opts) opts = {};\n  // allow a string argument to be passed in rather\n  // than an argv array.\n  args = tokenizeArgString(args);\n  // aliases might have transitive relationships, normalize this.\n  var aliases = combineAliases(opts.alias || {});\n  var configuration = assign({\n    'short-option-groups': true,\n    'camel-case-expansion': true,\n    'dot-notation': true,\n    'parse-numbers': true,\n    'boolean-negation': true,\n    'duplicate-arguments-array': true,\n    'flatten-duplicate-arrays': true\n  }, opts.configuration);\n  var defaults = opts.default || {};\n  var configObjects = opts.configObjects || [];\n  var envPrefix = opts.envPrefix;\n  var newAliases = {};\n  // allow a i18n handler to be passed in, default to a fake one (util.format).\n  var __ = opts.__ || function (str) {\n    return util.format.apply(util, Array.prototype.slice.call(arguments));\n  };\n  var error = null;\n  var flags = {\n    aliases: {},\n    arrays: {},\n    bools: {},\n    strings: {},\n    numbers: {},\n    counts: {},\n    normalize: {},\n    configs: {},\n    defaulted: {},\n    nargs: {},\n    coercions: {}\n  };\n  var negative = /^-[0-9]+(\\.[0-9]+)?/;\n  [].concat(opts.array).filter(Boolean).forEach(function (key) {\n    flags.arrays[key] = true;\n  });\n  [].concat(opts.boolean).filter(Boolean).forEach(function (key) {\n    flags.bools[key] = true;\n  });\n  [].concat(opts.string).filter(Boolean).forEach(function (key) {\n    flags.strings[key] = true;\n  });\n  [].concat(opts.number).filter(Boolean).forEach(function (key) {\n    flags.numbers[key] = true;\n  });\n  [].concat(opts.count).filter(Boolean).forEach(function (key) {\n    flags.counts[key] = true;\n  });\n  [].concat(opts.normalize).filter(Boolean).forEach(function (key) {\n    flags.normalize[key] = true;\n  });\n  Object.keys(opts.narg || {}).forEach(function (k) {\n    flags.nargs[k] = opts.narg[k];\n  });\n  Object.keys(opts.coerce || {}).forEach(function (k) {\n    flags.coercions[k] = opts.coerce[k];\n  });\n  if (Array.isArray(opts.config) || typeof opts.config === 'string') {\n    ;\n    [].concat(opts.config).filter(Boolean).forEach(function (key) {\n      flags.configs[key] = true;\n    });\n  } else {\n    Object.keys(opts.config || {}).forEach(function (k) {\n      flags.configs[k] = opts.config[k];\n    });\n  }\n\n  // create a lookup table that takes into account all\n  // combinations of aliases: {f: ['foo'], foo: ['f']}\n  extendAliases(opts.key, aliases, opts.default, flags.arrays);\n\n  // apply default values to all aliases.\n  Object.keys(defaults).forEach(function (key) {\n    (flags.aliases[key] || []).forEach(function (alias) {\n      defaults[alias] = defaults[key];\n    });\n  });\n  var argv = {\n    _: []\n  };\n  Object.keys(flags.bools).forEach(function (key) {\n    setArg(key, !(key in defaults) ? false : defaults[key]);\n    setDefaulted(key);\n  });\n  var notFlags = [];\n  if (args.indexOf('--') !== -1) {\n    notFlags = args.slice(args.indexOf('--') + 1);\n    args = args.slice(0, args.indexOf('--'));\n  }\n  for (var i = 0; i < args.length; i++) {\n    var arg = args[i];\n    var broken;\n    var key;\n    var letters;\n    var m;\n    var next;\n    var value;\n\n    // -- seperated by =\n    if (arg.match(/^--.+=/) || !configuration['short-option-groups'] && arg.match(/^-.+=/)) {\n      // Using [\\s\\S] instead of . because js doesn't support the\n      // 'dotall' regex modifier. See:\n      // http://stackoverflow.com/a/1068308/13216\n      m = arg.match(/^--?([^=]+)=([\\s\\S]*)$/);\n\n      // nargs format = '--f=monkey washing cat'\n      if (checkAllAliases(m[1], flags.nargs)) {\n        args.splice(i + 1, 0, m[2]);\n        i = eatNargs(i, m[1], args);\n        // arrays format = '--f=a b c'\n      } else if (checkAllAliases(m[1], flags.arrays) && args.length > i + 1) {\n        args.splice(i + 1, 0, m[2]);\n        i = eatArray(i, m[1], args);\n      } else {\n        setArg(m[1], m[2]);\n      }\n    } else if (arg.match(/^--no-.+/) && configuration['boolean-negation']) {\n      key = arg.match(/^--no-(.+)/)[1];\n      setArg(key, false);\n\n      // -- seperated by space.\n    } else if (arg.match(/^--.+/) || !configuration['short-option-groups'] && arg.match(/^-.+/)) {\n      key = arg.match(/^--?(.+)/)[1];\n\n      // nargs format = '--foo a b c'\n      if (checkAllAliases(key, flags.nargs)) {\n        i = eatNargs(i, key, args);\n        // array format = '--foo a b c'\n      } else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) {\n        i = eatArray(i, key, args);\n      } else {\n        next = args[i + 1];\n        if (next !== undefined && (!next.match(/^-/) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {\n          setArg(key, next);\n          i++;\n        } else if (/^(true|false)$/.test(next)) {\n          setArg(key, next);\n          i++;\n        } else {\n          setArg(key, defaultForType(guessType(key, flags)));\n        }\n      }\n\n      // dot-notation flag seperated by '='.\n    } else if (arg.match(/^-.\\..+=/)) {\n      m = arg.match(/^-([^=]+)=([\\s\\S]*)$/);\n      setArg(m[1], m[2]);\n\n      // dot-notation flag seperated by space.\n    } else if (arg.match(/^-.\\..+/)) {\n      next = args[i + 1];\n      key = arg.match(/^-(.\\..+)/)[1];\n      if (next !== undefined && !next.match(/^-/) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {\n        setArg(key, next);\n        i++;\n      } else {\n        setArg(key, defaultForType(guessType(key, flags)));\n      }\n    } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {\n      letters = arg.slice(1, -1).split('');\n      broken = false;\n      for (var j = 0; j < letters.length; j++) {\n        next = arg.slice(j + 2);\n        if (letters[j + 1] && letters[j + 1] === '=') {\n          value = arg.slice(j + 3);\n          key = letters[j];\n\n          // nargs format = '-f=monkey washing cat'\n          if (checkAllAliases(key, flags.nargs)) {\n            args.splice(i + 1, 0, value);\n            i = eatNargs(i, key, args);\n            // array format = '-f=a b c'\n          } else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) {\n            args.splice(i + 1, 0, value);\n            i = eatArray(i, key, args);\n          } else {\n            setArg(key, value);\n          }\n          broken = true;\n          break;\n        }\n        if (next === '-') {\n          setArg(letters[j], next);\n          continue;\n        }\n\n        // current letter is an alphabetic character and next value is a number\n        if (/[A-Za-z]/.test(letters[j]) && /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next)) {\n          setArg(letters[j], next);\n          broken = true;\n          break;\n        }\n        if (letters[j + 1] && letters[j + 1].match(/\\W/)) {\n          setArg(letters[j], next);\n          broken = true;\n          break;\n        } else {\n          setArg(letters[j], defaultForType(guessType(letters[j], flags)));\n        }\n      }\n      key = arg.slice(-1)[0];\n      if (!broken && key !== '-') {\n        // nargs format = '-f a b c'\n        if (checkAllAliases(key, flags.nargs)) {\n          i = eatNargs(i, key, args);\n          // array format = '-f a b c'\n        } else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) {\n          i = eatArray(i, key, args);\n        } else {\n          next = args[i + 1];\n          if (next !== undefined && (!/^(-|--)[^-]/.test(next) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {\n            setArg(key, next);\n            i++;\n          } else if (/^(true|false)$/.test(next)) {\n            setArg(key, next);\n            i++;\n          } else {\n            setArg(key, defaultForType(guessType(key, flags)));\n          }\n        }\n      }\n    } else {\n      argv._.push(flags.strings['_'] || !isNumber(arg) ? arg : Number(arg));\n    }\n  }\n\n  // order of precedence:\n  // 1. command line arg\n  // 2. value from config file\n  // 3. value from config objects\n  // 4. value from env var\n  // 5. configured default value\n  applyEnvVars(argv, true); // special case: check env vars that point to config file\n  setConfig(argv);\n  setConfigObjects();\n  applyEnvVars(argv, false);\n  applyDefaultsAndAliases(argv, flags.aliases, defaults);\n  applyCoercions(argv);\n\n  // for any counts either not in args or without an explicit default, set to 0\n  Object.keys(flags.counts).forEach(function (key) {\n    if (!hasKey(argv, key.split('.'))) setArg(key, 0);\n  });\n  notFlags.forEach(function (key) {\n    argv._.push(key);\n  });\n\n  // how many arguments should we consume, based\n  // on the nargs option?\n  function eatNargs(i, key, args) {\n    var toEat = checkAllAliases(key, flags.nargs);\n    if (args.length - (i + 1) < toEat) error = Error(__('Not enough arguments following: %s', key));\n    for (var ii = i + 1; ii < toEat + i + 1; ii++) {\n      setArg(key, args[ii]);\n    }\n    return i + toEat;\n  }\n\n  // if an option is an array, eat all non-hyphenated arguments\n  // following it... YUM!\n  // e.g., --foo apple banana cat becomes [\"apple\", \"banana\", \"cat\"]\n  function eatArray(i, key, args) {\n    var start = i + 1;\n    var argsToSet = [];\n    var multipleArrayFlag = i > 0;\n    for (var ii = i + 1; ii < args.length; ii++) {\n      if (/^-/.test(args[ii]) && !negative.test(args[ii])) {\n        if (ii === start) {\n          setArg(key, defaultForType('array'));\n        }\n        multipleArrayFlag = true;\n        break;\n      }\n      i = ii;\n      argsToSet.push(args[ii]);\n    }\n    if (multipleArrayFlag) {\n      setArg(key, argsToSet.map(function (arg) {\n        return processValue(key, arg);\n      }));\n    } else {\n      argsToSet.forEach(function (arg) {\n        setArg(key, arg);\n      });\n    }\n    return i;\n  }\n  function setArg(key, val) {\n    unsetDefaulted(key);\n    if (/-/.test(key) && !(flags.aliases[key] && flags.aliases[key].length) && configuration['camel-case-expansion']) {\n      var c = camelCase(key);\n      flags.aliases[key] = [c];\n      newAliases[c] = true;\n    }\n    var value = processValue(key, val);\n    var splitKey = key.split('.');\n    setKey(argv, splitKey, value);\n\n    // handle populating aliases of the full key\n    if (flags.aliases[key]) {\n      flags.aliases[key].forEach(function (x) {\n        x = x.split('.');\n        setKey(argv, x, value);\n      });\n    }\n\n    // handle populating aliases of the first element of the dot-notation key\n    if (splitKey.length > 1 && configuration['dot-notation']) {\n      ;\n      (flags.aliases[splitKey[0]] || []).forEach(function (x) {\n        x = x.split('.');\n\n        // expand alias with nested objects in key\n        var a = [].concat(splitKey);\n        a.shift(); // nuke the old key.\n        x = x.concat(a);\n        setKey(argv, x, value);\n      });\n    }\n\n    // Set normalize getter and setter when key is in 'normalize' but isn't an array\n    if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {\n      var keys = [key].concat(flags.aliases[key] || []);\n      keys.forEach(function (key) {\n        argv.__defineSetter__(key, function (v) {\n          val = path.normalize(v);\n        });\n        argv.__defineGetter__(key, function () {\n          return typeof val === 'string' ? path.normalize(val) : val;\n        });\n      });\n    }\n  }\n  function processValue(key, val) {\n    // handle parsing boolean arguments --foo=true --bar false.\n    if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {\n      if (typeof val === 'string') val = val === 'true';\n    }\n    var value = val;\n    if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.coercions)) {\n      if (isNumber(val)) value = Number(val);\n      if (!isUndefined(val) && !isNumber(val) && checkAllAliases(key, flags.numbers)) value = NaN;\n    }\n\n    // increment a count given as arg (either no value or value parsed as boolean)\n    if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === 'boolean')) {\n      value = increment;\n    }\n\n    // Set normalized value when key is in 'normalize' and in 'arrays'\n    if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {\n      if (Array.isArray(val)) value = val.map(path.normalize);else value = path.normalize(val);\n    }\n    return value;\n  }\n\n  // set args from config.json file, this should be\n  // applied last so that defaults can be applied.\n  function setConfig(argv) {\n    var configLookup = {};\n\n    // expand defaults/aliases, in-case any happen to reference\n    // the config.json file.\n    applyDefaultsAndAliases(configLookup, flags.aliases, defaults);\n    Object.keys(flags.configs).forEach(function (configKey) {\n      var configPath = argv[configKey] || configLookup[configKey];\n      if (configPath) {\n        try {\n          var config = null;\n          var resolvedConfigPath = path.resolve(process.cwd(), configPath);\n          if (typeof flags.configs[configKey] === 'function') {\n            try {\n              config = flags.configs[configKey](resolvedConfigPath);\n            } catch (e) {\n              config = e;\n            }\n            if (config instanceof Error) {\n              error = config;\n              return;\n            }\n          } else {\n            config = require(resolvedConfigPath);\n          }\n          setConfigObject(config);\n        } catch (ex) {\n          if (argv[configKey]) error = Error(__('Invalid JSON config file: %s', configPath));\n        }\n      }\n    });\n  }\n\n  // set args from config object.\n  // it recursively checks nested objects.\n  function setConfigObject(config, prev) {\n    Object.keys(config).forEach(function (key) {\n      var value = config[key];\n      var fullKey = prev ? prev + '.' + key : key;\n\n      // if the value is an inner object and we have dot-notation\n      // enabled, treat inner objects in config the same as\n      // heavily nested dot notations (foo.bar.apple).\n      if (typeof value === 'object' && !Array.isArray(value) && configuration['dot-notation']) {\n        // if the value is an object but not an array, check nested object\n        setConfigObject(value, fullKey);\n      } else {\n        // setting arguments via CLI takes precedence over\n        // values within the config file.\n        if (!hasKey(argv, fullKey.split('.')) || flags.defaulted[fullKey]) {\n          setArg(fullKey, value);\n        }\n      }\n    });\n  }\n\n  // set all config objects passed in opts\n  function setConfigObjects() {\n    if (typeof configObjects === 'undefined') return;\n    configObjects.forEach(function (configObject) {\n      setConfigObject(configObject);\n    });\n  }\n  function applyEnvVars(argv, configOnly) {\n    if (typeof envPrefix === 'undefined') return;\n    var prefix = typeof envPrefix === 'string' ? envPrefix : '';\n    Object.keys(process.env).forEach(function (envVar) {\n      if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) {\n        // get array of nested keys and convert them to camel case\n        var keys = envVar.split('__').map(function (key, i) {\n          if (i === 0) {\n            key = key.substring(prefix.length);\n          }\n          return camelCase(key);\n        });\n        if ((configOnly && flags.configs[keys.join('.')] || !configOnly) && (!hasKey(argv, keys) || flags.defaulted[keys.join('.')])) {\n          setArg(keys.join('.'), process.env[envVar]);\n        }\n      }\n    });\n  }\n  function applyCoercions(argv) {\n    var coerce;\n    Object.keys(argv).forEach(function (key) {\n      coerce = checkAllAliases(key, flags.coercions);\n      if (typeof coerce === 'function') {\n        try {\n          argv[key] = coerce(argv[key]);\n        } catch (err) {\n          error = err;\n        }\n      }\n    });\n  }\n  function applyDefaultsAndAliases(obj, aliases, defaults) {\n    Object.keys(defaults).forEach(function (key) {\n      if (!hasKey(obj, key.split('.'))) {\n        setKey(obj, key.split('.'), defaults[key]);\n        (aliases[key] || []).forEach(function (x) {\n          if (hasKey(obj, x.split('.'))) return;\n          setKey(obj, x.split('.'), defaults[key]);\n        });\n      }\n    });\n  }\n  function hasKey(obj, keys) {\n    var o = obj;\n    if (!configuration['dot-notation']) keys = [keys.join('.')];\n    keys.slice(0, -1).forEach(function (key) {\n      o = o[key] || {};\n    });\n    var key = keys[keys.length - 1];\n    if (typeof o !== 'object') return false;else return key in o;\n  }\n  function setKey(obj, keys, value) {\n    var o = obj;\n    if (!configuration['dot-notation']) keys = [keys.join('.')];\n    keys.slice(0, -1).forEach(function (key) {\n      if (o[key] === undefined) o[key] = {};\n      o = o[key];\n    });\n    var key = keys[keys.length - 1];\n    var isTypeArray = checkAllAliases(key, flags.arrays);\n    var isValueArray = Array.isArray(value);\n    var duplicate = configuration['duplicate-arguments-array'];\n    if (value === increment) {\n      o[key] = increment(o[key]);\n    } else if (Array.isArray(o[key])) {\n      if (duplicate && isTypeArray && isValueArray) {\n        o[key] = configuration['flatten-duplicate-arrays'] ? o[key].concat(value) : [o[key]].concat([value]);\n      } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {\n        o[key] = value;\n      } else {\n        o[key] = o[key].concat([value]);\n      }\n    } else if (o[key] === undefined && isTypeArray) {\n      o[key] = isValueArray ? value : [value];\n    } else if (duplicate && !(o[key] === undefined || checkAllAliases(key, flags.bools) || checkAllAliases(keys.join('.'), flags.bools) || checkAllAliases(key, flags.counts))) {\n      o[key] = [o[key], value];\n    } else {\n      o[key] = value;\n    }\n  }\n\n  // extend the aliases list with inferred aliases.\n  function extendAliases() {\n    Array.prototype.slice.call(arguments).forEach(function (obj) {\n      Object.keys(obj || {}).forEach(function (key) {\n        // short-circuit if we've already added a key\n        // to the aliases array, for example it might\n        // exist in both 'opts.default' and 'opts.key'.\n        if (flags.aliases[key]) return;\n        flags.aliases[key] = [].concat(aliases[key] || []);\n        // For \"--option-name\", also set argv.optionName\n        flags.aliases[key].concat(key).forEach(function (x) {\n          if (/-/.test(x) && configuration['camel-case-expansion']) {\n            var c = camelCase(x);\n            flags.aliases[key].push(c);\n            newAliases[c] = true;\n          }\n        });\n        flags.aliases[key].forEach(function (x) {\n          flags.aliases[x] = [key].concat(flags.aliases[key].filter(function (y) {\n            return x !== y;\n          }));\n        });\n      });\n    });\n  }\n\n  // check if a flag is set for any of a key's aliases.\n  function checkAllAliases(key, flag) {\n    var isSet = false;\n    var toCheck = [].concat(flags.aliases[key] || [], key);\n    toCheck.forEach(function (key) {\n      if (flag[key]) isSet = flag[key];\n    });\n    return isSet;\n  }\n  function setDefaulted(key) {\n    [].concat(flags.aliases[key] || [], key).forEach(function (k) {\n      flags.defaulted[k] = true;\n    });\n  }\n  function unsetDefaulted(key) {\n    [].concat(flags.aliases[key] || [], key).forEach(function (k) {\n      delete flags.defaulted[k];\n    });\n  }\n\n  // return a default value, given the type of a flag.,\n  // e.g., key of type 'string' will default to '', rather than 'true'.\n  function defaultForType(type) {\n    var def = {\n      boolean: true,\n      string: '',\n      number: undefined,\n      array: []\n    };\n    return def[type];\n  }\n\n  // given a flag, enforce a default type.\n  function guessType(key, flags) {\n    var type = 'boolean';\n    if (checkAllAliases(key, flags.strings)) type = 'string';else if (checkAllAliases(key, flags.numbers)) type = 'number';else if (checkAllAliases(key, flags.arrays)) type = 'array';\n    return type;\n  }\n  function isNumber(x) {\n    if (!configuration['parse-numbers']) return false;\n    if (typeof x === 'number') return true;\n    if (/^0x[0-9a-f]+$/i.test(x)) return true;\n    return /^[-+]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(e[-+]?\\d+)?$/.test(x);\n  }\n  function isUndefined(num) {\n    return num === undefined;\n  }\n  return {\n    argv: argv,\n    error: error,\n    aliases: flags.aliases,\n    newAliases: newAliases,\n    configuration: configuration\n  };\n}\n\n// if any aliases reference each other, we should\n// merge them together.\nfunction combineAliases(aliases) {\n  var aliasArrays = [];\n  var change = true;\n  var combined = {};\n\n  // turn alias lookup hash {key: ['alias1', 'alias2']} into\n  // a simple array ['key', 'alias1', 'alias2']\n  Object.keys(aliases).forEach(function (key) {\n    aliasArrays.push([].concat(aliases[key], key));\n  });\n\n  // combine arrays until zero changes are\n  // made in an iteration.\n  while (change) {\n    change = false;\n    for (var i = 0; i < aliasArrays.length; i++) {\n      for (var ii = i + 1; ii < aliasArrays.length; ii++) {\n        var intersect = aliasArrays[i].filter(function (v) {\n          return aliasArrays[ii].indexOf(v) !== -1;\n        });\n        if (intersect.length) {\n          aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);\n          aliasArrays.splice(ii, 1);\n          change = true;\n          break;\n        }\n      }\n    }\n  }\n\n  // map arrays back to the hash-lookup (de-dupe while\n  // we're at it).\n  aliasArrays.forEach(function (aliasArray) {\n    aliasArray = aliasArray.filter(function (v, i, self) {\n      return self.indexOf(v) === i;\n    });\n    combined[aliasArray.pop()] = aliasArray;\n  });\n  return combined;\n}\nfunction assign(defaults, configuration) {\n  var o = {};\n  configuration = configuration || {};\n  Object.keys(defaults).forEach(function (k) {\n    o[k] = defaults[k];\n  });\n  Object.keys(configuration).forEach(function (k) {\n    o[k] = configuration[k];\n  });\n  return o;\n}\n\n// this function should only be called when a count is given as an arg\n// it is NOT called to set a default value\n// thus we can start the count at 1 instead of 0\nfunction increment(orig) {\n  return orig !== undefined ? orig + 1 : 1;\n}\nfunction Parser(args, opts) {\n  var result = parse(args.slice(), opts);\n  return result.argv;\n}\n\n// parse arguments and return detailed\n// meta information, aliases, etc.\nParser.detailed = function (args, opts) {\n  return parse(args.slice(), opts);\n};\nmodule.exports = Parser;","map":{"version":3,"names":["camelCase","require","path","tokenizeArgString","util","parse","args","opts","aliases","combineAliases","alias","configuration","assign","defaults","default","configObjects","envPrefix","newAliases","__","str","format","apply","Array","prototype","slice","call","arguments","error","flags","arrays","bools","strings","numbers","counts","normalize","configs","defaulted","nargs","coercions","negative","concat","array","filter","Boolean","forEach","key","boolean","string","number","count","Object","keys","narg","k","coerce","isArray","config","extendAliases","argv","_","setArg","setDefaulted","notFlags","indexOf","i","length","arg","broken","letters","m","next","value","match","checkAllAliases","splice","eatNargs","eatArray","undefined","test","defaultForType","guessType","split","j","push","isNumber","Number","applyEnvVars","setConfig","setConfigObjects","applyDefaultsAndAliases","applyCoercions","hasKey","toEat","Error","ii","start","argsToSet","multipleArrayFlag","map","processValue","val","unsetDefaulted","c","splitKey","setKey","x","a","shift","__defineSetter__","v","__defineGetter__","isUndefined","NaN","increment","configLookup","configKey","configPath","resolvedConfigPath","resolve","process","cwd","e","setConfigObject","ex","prev","fullKey","configObject","configOnly","prefix","env","envVar","lastIndexOf","substring","join","err","obj","o","isTypeArray","isValueArray","duplicate","y","flag","isSet","toCheck","type","def","num","aliasArrays","change","combined","intersect","aliasArray","self","pop","orig","Parser","result","detailed","module","exports"],"sources":["/home/user/Рабочий стол/pizza/project/node_modules/yargs-parser/index.js"],"sourcesContent":["var camelCase = require('camelcase')\nvar path = require('path')\nvar tokenizeArgString = require('./lib/tokenize-arg-string')\nvar util = require('util')\n\nfunction parse (args, opts) {\n  if (!opts) opts = {}\n  // allow a string argument to be passed in rather\n  // than an argv array.\n  args = tokenizeArgString(args)\n  // aliases might have transitive relationships, normalize this.\n  var aliases = combineAliases(opts.alias || {})\n  var configuration = assign({\n    'short-option-groups': true,\n    'camel-case-expansion': true,\n    'dot-notation': true,\n    'parse-numbers': true,\n    'boolean-negation': true,\n    'duplicate-arguments-array': true,\n    'flatten-duplicate-arrays': true\n  }, opts.configuration)\n  var defaults = opts.default || {}\n  var configObjects = opts.configObjects || []\n  var envPrefix = opts.envPrefix\n  var newAliases = {}\n  // allow a i18n handler to be passed in, default to a fake one (util.format).\n  var __ = opts.__ || function (str) {\n    return util.format.apply(util, Array.prototype.slice.call(arguments))\n  }\n  var error = null\n  var flags = {\n    aliases: {},\n    arrays: {},\n    bools: {},\n    strings: {},\n    numbers: {},\n    counts: {},\n    normalize: {},\n    configs: {},\n    defaulted: {},\n    nargs: {},\n    coercions: {}\n  }\n  var negative = /^-[0-9]+(\\.[0-9]+)?/\n\n  ;[].concat(opts.array).filter(Boolean).forEach(function (key) {\n    flags.arrays[key] = true\n  })\n\n  ;[].concat(opts.boolean).filter(Boolean).forEach(function (key) {\n    flags.bools[key] = true\n  })\n\n  ;[].concat(opts.string).filter(Boolean).forEach(function (key) {\n    flags.strings[key] = true\n  })\n\n  ;[].concat(opts.number).filter(Boolean).forEach(function (key) {\n    flags.numbers[key] = true\n  })\n\n  ;[].concat(opts.count).filter(Boolean).forEach(function (key) {\n    flags.counts[key] = true\n  })\n\n  ;[].concat(opts.normalize).filter(Boolean).forEach(function (key) {\n    flags.normalize[key] = true\n  })\n\n  Object.keys(opts.narg || {}).forEach(function (k) {\n    flags.nargs[k] = opts.narg[k]\n  })\n\n  Object.keys(opts.coerce || {}).forEach(function (k) {\n    flags.coercions[k] = opts.coerce[k]\n  })\n\n  if (Array.isArray(opts.config) || typeof opts.config === 'string') {\n    ;[].concat(opts.config).filter(Boolean).forEach(function (key) {\n      flags.configs[key] = true\n    })\n  } else {\n    Object.keys(opts.config || {}).forEach(function (k) {\n      flags.configs[k] = opts.config[k]\n    })\n  }\n\n  // create a lookup table that takes into account all\n  // combinations of aliases: {f: ['foo'], foo: ['f']}\n  extendAliases(opts.key, aliases, opts.default, flags.arrays)\n\n  // apply default values to all aliases.\n  Object.keys(defaults).forEach(function (key) {\n    (flags.aliases[key] || []).forEach(function (alias) {\n      defaults[alias] = defaults[key]\n    })\n  })\n\n  var argv = { _: [] }\n\n  Object.keys(flags.bools).forEach(function (key) {\n    setArg(key, !(key in defaults) ? false : defaults[key])\n    setDefaulted(key)\n  })\n\n  var notFlags = []\n  if (args.indexOf('--') !== -1) {\n    notFlags = args.slice(args.indexOf('--') + 1)\n    args = args.slice(0, args.indexOf('--'))\n  }\n\n  for (var i = 0; i < args.length; i++) {\n    var arg = args[i]\n    var broken\n    var key\n    var letters\n    var m\n    var next\n    var value\n\n    // -- seperated by =\n    if (arg.match(/^--.+=/) || (\n      !configuration['short-option-groups'] && arg.match(/^-.+=/)\n    )) {\n      // Using [\\s\\S] instead of . because js doesn't support the\n      // 'dotall' regex modifier. See:\n      // http://stackoverflow.com/a/1068308/13216\n      m = arg.match(/^--?([^=]+)=([\\s\\S]*)$/)\n\n      // nargs format = '--f=monkey washing cat'\n      if (checkAllAliases(m[1], flags.nargs)) {\n        args.splice(i + 1, 0, m[2])\n        i = eatNargs(i, m[1], args)\n      // arrays format = '--f=a b c'\n      } else if (checkAllAliases(m[1], flags.arrays) && args.length > i + 1) {\n        args.splice(i + 1, 0, m[2])\n        i = eatArray(i, m[1], args)\n      } else {\n        setArg(m[1], m[2])\n      }\n    } else if (arg.match(/^--no-.+/) && configuration['boolean-negation']) {\n      key = arg.match(/^--no-(.+)/)[1]\n      setArg(key, false)\n\n    // -- seperated by space.\n    } else if (arg.match(/^--.+/) || (\n      !configuration['short-option-groups'] && arg.match(/^-.+/)\n    )) {\n      key = arg.match(/^--?(.+)/)[1]\n\n      // nargs format = '--foo a b c'\n      if (checkAllAliases(key, flags.nargs)) {\n        i = eatNargs(i, key, args)\n      // array format = '--foo a b c'\n      } else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) {\n        i = eatArray(i, key, args)\n      } else {\n        next = args[i + 1]\n\n        if (next !== undefined && (!next.match(/^-/) ||\n          next.match(negative)) &&\n          !checkAllAliases(key, flags.bools) &&\n          !checkAllAliases(key, flags.counts)) {\n          setArg(key, next)\n          i++\n        } else if (/^(true|false)$/.test(next)) {\n          setArg(key, next)\n          i++\n        } else {\n          setArg(key, defaultForType(guessType(key, flags)))\n        }\n      }\n\n    // dot-notation flag seperated by '='.\n    } else if (arg.match(/^-.\\..+=/)) {\n      m = arg.match(/^-([^=]+)=([\\s\\S]*)$/)\n      setArg(m[1], m[2])\n\n    // dot-notation flag seperated by space.\n    } else if (arg.match(/^-.\\..+/)) {\n      next = args[i + 1]\n      key = arg.match(/^-(.\\..+)/)[1]\n\n      if (next !== undefined && !next.match(/^-/) &&\n        !checkAllAliases(key, flags.bools) &&\n        !checkAllAliases(key, flags.counts)) {\n        setArg(key, next)\n        i++\n      } else {\n        setArg(key, defaultForType(guessType(key, flags)))\n      }\n    } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {\n      letters = arg.slice(1, -1).split('')\n      broken = false\n\n      for (var j = 0; j < letters.length; j++) {\n        next = arg.slice(j + 2)\n\n        if (letters[j + 1] && letters[j + 1] === '=') {\n          value = arg.slice(j + 3)\n          key = letters[j]\n\n          // nargs format = '-f=monkey washing cat'\n          if (checkAllAliases(key, flags.nargs)) {\n            args.splice(i + 1, 0, value)\n            i = eatNargs(i, key, args)\n          // array format = '-f=a b c'\n          } else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) {\n            args.splice(i + 1, 0, value)\n            i = eatArray(i, key, args)\n          } else {\n            setArg(key, value)\n          }\n\n          broken = true\n          break\n        }\n\n        if (next === '-') {\n          setArg(letters[j], next)\n          continue\n        }\n\n        // current letter is an alphabetic character and next value is a number\n        if (/[A-Za-z]/.test(letters[j]) &&\n          /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next)) {\n          setArg(letters[j], next)\n          broken = true\n          break\n        }\n\n        if (letters[j + 1] && letters[j + 1].match(/\\W/)) {\n          setArg(letters[j], next)\n          broken = true\n          break\n        } else {\n          setArg(letters[j], defaultForType(guessType(letters[j], flags)))\n        }\n      }\n\n      key = arg.slice(-1)[0]\n\n      if (!broken && key !== '-') {\n        // nargs format = '-f a b c'\n        if (checkAllAliases(key, flags.nargs)) {\n          i = eatNargs(i, key, args)\n        // array format = '-f a b c'\n        } else if (checkAllAliases(key, flags.arrays) && args.length > i + 1) {\n          i = eatArray(i, key, args)\n        } else {\n          next = args[i + 1]\n\n          if (next !== undefined && (!/^(-|--)[^-]/.test(next) ||\n            next.match(negative)) &&\n            !checkAllAliases(key, flags.bools) &&\n            !checkAllAliases(key, flags.counts)) {\n            setArg(key, next)\n            i++\n          } else if (/^(true|false)$/.test(next)) {\n            setArg(key, next)\n            i++\n          } else {\n            setArg(key, defaultForType(guessType(key, flags)))\n          }\n        }\n      }\n    } else {\n      argv._.push(\n        flags.strings['_'] || !isNumber(arg) ? arg : Number(arg)\n      )\n    }\n  }\n\n  // order of precedence:\n  // 1. command line arg\n  // 2. value from config file\n  // 3. value from config objects\n  // 4. value from env var\n  // 5. configured default value\n  applyEnvVars(argv, true) // special case: check env vars that point to config file\n  setConfig(argv)\n  setConfigObjects()\n  applyEnvVars(argv, false)\n  applyDefaultsAndAliases(argv, flags.aliases, defaults)\n  applyCoercions(argv)\n\n  // for any counts either not in args or without an explicit default, set to 0\n  Object.keys(flags.counts).forEach(function (key) {\n    if (!hasKey(argv, key.split('.'))) setArg(key, 0)\n  })\n\n  notFlags.forEach(function (key) {\n    argv._.push(key)\n  })\n\n  // how many arguments should we consume, based\n  // on the nargs option?\n  function eatNargs (i, key, args) {\n    var toEat = checkAllAliases(key, flags.nargs)\n\n    if (args.length - (i + 1) < toEat) error = Error(__('Not enough arguments following: %s', key))\n\n    for (var ii = i + 1; ii < (toEat + i + 1); ii++) {\n      setArg(key, args[ii])\n    }\n\n    return (i + toEat)\n  }\n\n  // if an option is an array, eat all non-hyphenated arguments\n  // following it... YUM!\n  // e.g., --foo apple banana cat becomes [\"apple\", \"banana\", \"cat\"]\n  function eatArray (i, key, args) {\n    var start = i + 1\n    var argsToSet = []\n    var multipleArrayFlag = i > 0\n    for (var ii = i + 1; ii < args.length; ii++) {\n      if (/^-/.test(args[ii]) && !negative.test(args[ii])) {\n        if (ii === start) {\n          setArg(key, defaultForType('array'))\n        }\n        multipleArrayFlag = true\n        break\n      }\n      i = ii\n      argsToSet.push(args[ii])\n    }\n    if (multipleArrayFlag) {\n      setArg(key, argsToSet.map(function (arg) {\n        return processValue(key, arg)\n      }))\n    } else {\n      argsToSet.forEach(function (arg) {\n        setArg(key, arg)\n      })\n    }\n\n    return i\n  }\n\n  function setArg (key, val) {\n    unsetDefaulted(key)\n\n    if (/-/.test(key) && !(flags.aliases[key] && flags.aliases[key].length) && configuration['camel-case-expansion']) {\n      var c = camelCase(key)\n      flags.aliases[key] = [c]\n      newAliases[c] = true\n    }\n\n    var value = processValue(key, val)\n\n    var splitKey = key.split('.')\n    setKey(argv, splitKey, value)\n\n    // handle populating aliases of the full key\n    if (flags.aliases[key]) {\n      flags.aliases[key].forEach(function (x) {\n        x = x.split('.')\n        setKey(argv, x, value)\n      })\n    }\n\n    // handle populating aliases of the first element of the dot-notation key\n    if (splitKey.length > 1 && configuration['dot-notation']) {\n      ;(flags.aliases[splitKey[0]] || []).forEach(function (x) {\n        x = x.split('.')\n\n        // expand alias with nested objects in key\n        var a = [].concat(splitKey)\n        a.shift() // nuke the old key.\n        x = x.concat(a)\n\n        setKey(argv, x, value)\n      })\n    }\n\n    // Set normalize getter and setter when key is in 'normalize' but isn't an array\n    if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {\n      var keys = [key].concat(flags.aliases[key] || [])\n      keys.forEach(function (key) {\n        argv.__defineSetter__(key, function (v) {\n          val = path.normalize(v)\n        })\n\n        argv.__defineGetter__(key, function () {\n          return typeof val === 'string' ? path.normalize(val) : val\n        })\n      })\n    }\n  }\n\n  function processValue (key, val) {\n    // handle parsing boolean arguments --foo=true --bar false.\n    if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {\n      if (typeof val === 'string') val = val === 'true'\n    }\n\n    var value = val\n    if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.coercions)) {\n      if (isNumber(val)) value = Number(val)\n      if (!isUndefined(val) && !isNumber(val) && checkAllAliases(key, flags.numbers)) value = NaN\n    }\n\n    // increment a count given as arg (either no value or value parsed as boolean)\n    if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === 'boolean')) {\n      value = increment\n    }\n\n    // Set normalized value when key is in 'normalize' and in 'arrays'\n    if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {\n      if (Array.isArray(val)) value = val.map(path.normalize)\n      else value = path.normalize(val)\n    }\n    return value\n  }\n\n  // set args from config.json file, this should be\n  // applied last so that defaults can be applied.\n  function setConfig (argv) {\n    var configLookup = {}\n\n    // expand defaults/aliases, in-case any happen to reference\n    // the config.json file.\n    applyDefaultsAndAliases(configLookup, flags.aliases, defaults)\n\n    Object.keys(flags.configs).forEach(function (configKey) {\n      var configPath = argv[configKey] || configLookup[configKey]\n      if (configPath) {\n        try {\n          var config = null\n          var resolvedConfigPath = path.resolve(process.cwd(), configPath)\n\n          if (typeof flags.configs[configKey] === 'function') {\n            try {\n              config = flags.configs[configKey](resolvedConfigPath)\n            } catch (e) {\n              config = e\n            }\n            if (config instanceof Error) {\n              error = config\n              return\n            }\n          } else {\n            config = require(resolvedConfigPath)\n          }\n\n          setConfigObject(config)\n        } catch (ex) {\n          if (argv[configKey]) error = Error(__('Invalid JSON config file: %s', configPath))\n        }\n      }\n    })\n  }\n\n  // set args from config object.\n  // it recursively checks nested objects.\n  function setConfigObject (config, prev) {\n    Object.keys(config).forEach(function (key) {\n      var value = config[key]\n      var fullKey = prev ? prev + '.' + key : key\n\n      // if the value is an inner object and we have dot-notation\n      // enabled, treat inner objects in config the same as\n      // heavily nested dot notations (foo.bar.apple).\n      if (typeof value === 'object' && !Array.isArray(value) && configuration['dot-notation']) {\n        // if the value is an object but not an array, check nested object\n        setConfigObject(value, fullKey)\n      } else {\n        // setting arguments via CLI takes precedence over\n        // values within the config file.\n        if (!hasKey(argv, fullKey.split('.')) || (flags.defaulted[fullKey])) {\n          setArg(fullKey, value)\n        }\n      }\n    })\n  }\n\n  // set all config objects passed in opts\n  function setConfigObjects () {\n    if (typeof configObjects === 'undefined') return\n    configObjects.forEach(function (configObject) {\n      setConfigObject(configObject)\n    })\n  }\n\n  function applyEnvVars (argv, configOnly) {\n    if (typeof envPrefix === 'undefined') return\n\n    var prefix = typeof envPrefix === 'string' ? envPrefix : ''\n    Object.keys(process.env).forEach(function (envVar) {\n      if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) {\n        // get array of nested keys and convert them to camel case\n        var keys = envVar.split('__').map(function (key, i) {\n          if (i === 0) {\n            key = key.substring(prefix.length)\n          }\n          return camelCase(key)\n        })\n\n        if (((configOnly && flags.configs[keys.join('.')]) || !configOnly) && (!hasKey(argv, keys) || flags.defaulted[keys.join('.')])) {\n          setArg(keys.join('.'), process.env[envVar])\n        }\n      }\n    })\n  }\n\n  function applyCoercions (argv) {\n    var coerce\n    Object.keys(argv).forEach(function (key) {\n      coerce = checkAllAliases(key, flags.coercions)\n      if (typeof coerce === 'function') {\n        try {\n          argv[key] = coerce(argv[key])\n        } catch (err) {\n          error = err\n        }\n      }\n    })\n  }\n\n  function applyDefaultsAndAliases (obj, aliases, defaults) {\n    Object.keys(defaults).forEach(function (key) {\n      if (!hasKey(obj, key.split('.'))) {\n        setKey(obj, key.split('.'), defaults[key])\n\n        ;(aliases[key] || []).forEach(function (x) {\n          if (hasKey(obj, x.split('.'))) return\n          setKey(obj, x.split('.'), defaults[key])\n        })\n      }\n    })\n  }\n\n  function hasKey (obj, keys) {\n    var o = obj\n\n    if (!configuration['dot-notation']) keys = [keys.join('.')]\n\n    keys.slice(0, -1).forEach(function (key) {\n      o = (o[key] || {})\n    })\n\n    var key = keys[keys.length - 1]\n\n    if (typeof o !== 'object') return false\n    else return key in o\n  }\n\n  function setKey (obj, keys, value) {\n    var o = obj\n\n    if (!configuration['dot-notation']) keys = [keys.join('.')]\n\n    keys.slice(0, -1).forEach(function (key) {\n      if (o[key] === undefined) o[key] = {}\n      o = o[key]\n    })\n\n    var key = keys[keys.length - 1]\n\n    var isTypeArray = checkAllAliases(key, flags.arrays)\n    var isValueArray = Array.isArray(value)\n    var duplicate = configuration['duplicate-arguments-array']\n\n    if (value === increment) {\n      o[key] = increment(o[key])\n    } else if (Array.isArray(o[key])) {\n      if (duplicate && isTypeArray && isValueArray) {\n        o[key] = configuration['flatten-duplicate-arrays'] ? o[key].concat(value) : [o[key]].concat([value])\n      } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {\n        o[key] = value\n      } else {\n        o[key] = o[key].concat([value])\n      }\n    } else if (o[key] === undefined && isTypeArray) {\n      o[key] = isValueArray ? value : [value]\n    } else if (duplicate && !(o[key] === undefined || checkAllAliases(key, flags.bools) || checkAllAliases(keys.join('.'), flags.bools) || checkAllAliases(key, flags.counts))) {\n      o[key] = [ o[key], value ]\n    } else {\n      o[key] = value\n    }\n  }\n\n  // extend the aliases list with inferred aliases.\n  function extendAliases () {\n    Array.prototype.slice.call(arguments).forEach(function (obj) {\n      Object.keys(obj || {}).forEach(function (key) {\n        // short-circuit if we've already added a key\n        // to the aliases array, for example it might\n        // exist in both 'opts.default' and 'opts.key'.\n        if (flags.aliases[key]) return\n\n        flags.aliases[key] = [].concat(aliases[key] || [])\n        // For \"--option-name\", also set argv.optionName\n        flags.aliases[key].concat(key).forEach(function (x) {\n          if (/-/.test(x) && configuration['camel-case-expansion']) {\n            var c = camelCase(x)\n            flags.aliases[key].push(c)\n            newAliases[c] = true\n          }\n        })\n        flags.aliases[key].forEach(function (x) {\n          flags.aliases[x] = [key].concat(flags.aliases[key].filter(function (y) {\n            return x !== y\n          }))\n        })\n      })\n    })\n  }\n\n  // check if a flag is set for any of a key's aliases.\n  function checkAllAliases (key, flag) {\n    var isSet = false\n    var toCheck = [].concat(flags.aliases[key] || [], key)\n\n    toCheck.forEach(function (key) {\n      if (flag[key]) isSet = flag[key]\n    })\n\n    return isSet\n  }\n\n  function setDefaulted (key) {\n    [].concat(flags.aliases[key] || [], key).forEach(function (k) {\n      flags.defaulted[k] = true\n    })\n  }\n\n  function unsetDefaulted (key) {\n    [].concat(flags.aliases[key] || [], key).forEach(function (k) {\n      delete flags.defaulted[k]\n    })\n  }\n\n  // return a default value, given the type of a flag.,\n  // e.g., key of type 'string' will default to '', rather than 'true'.\n  function defaultForType (type) {\n    var def = {\n      boolean: true,\n      string: '',\n      number: undefined,\n      array: []\n    }\n\n    return def[type]\n  }\n\n  // given a flag, enforce a default type.\n  function guessType (key, flags) {\n    var type = 'boolean'\n\n    if (checkAllAliases(key, flags.strings)) type = 'string'\n    else if (checkAllAliases(key, flags.numbers)) type = 'number'\n    else if (checkAllAliases(key, flags.arrays)) type = 'array'\n\n    return type\n  }\n\n  function isNumber (x) {\n    if (!configuration['parse-numbers']) return false\n    if (typeof x === 'number') return true\n    if (/^0x[0-9a-f]+$/i.test(x)) return true\n    return /^[-+]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(e[-+]?\\d+)?$/.test(x)\n  }\n\n  function isUndefined (num) {\n    return num === undefined\n  }\n\n  return {\n    argv: argv,\n    error: error,\n    aliases: flags.aliases,\n    newAliases: newAliases,\n    configuration: configuration\n  }\n}\n\n// if any aliases reference each other, we should\n// merge them together.\nfunction combineAliases (aliases) {\n  var aliasArrays = []\n  var change = true\n  var combined = {}\n\n  // turn alias lookup hash {key: ['alias1', 'alias2']} into\n  // a simple array ['key', 'alias1', 'alias2']\n  Object.keys(aliases).forEach(function (key) {\n    aliasArrays.push(\n      [].concat(aliases[key], key)\n    )\n  })\n\n  // combine arrays until zero changes are\n  // made in an iteration.\n  while (change) {\n    change = false\n    for (var i = 0; i < aliasArrays.length; i++) {\n      for (var ii = i + 1; ii < aliasArrays.length; ii++) {\n        var intersect = aliasArrays[i].filter(function (v) {\n          return aliasArrays[ii].indexOf(v) !== -1\n        })\n\n        if (intersect.length) {\n          aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii])\n          aliasArrays.splice(ii, 1)\n          change = true\n          break\n        }\n      }\n    }\n  }\n\n  // map arrays back to the hash-lookup (de-dupe while\n  // we're at it).\n  aliasArrays.forEach(function (aliasArray) {\n    aliasArray = aliasArray.filter(function (v, i, self) {\n      return self.indexOf(v) === i\n    })\n    combined[aliasArray.pop()] = aliasArray\n  })\n\n  return combined\n}\n\nfunction assign (defaults, configuration) {\n  var o = {}\n  configuration = configuration || {}\n\n  Object.keys(defaults).forEach(function (k) {\n    o[k] = defaults[k]\n  })\n  Object.keys(configuration).forEach(function (k) {\n    o[k] = configuration[k]\n  })\n\n  return o\n}\n\n// this function should only be called when a count is given as an arg\n// it is NOT called to set a default value\n// thus we can start the count at 1 instead of 0\nfunction increment (orig) {\n  return orig !== undefined ? orig + 1 : 1\n}\n\nfunction Parser (args, opts) {\n  var result = parse(args.slice(), opts)\n\n  return result.argv\n}\n\n// parse arguments and return detailed\n// meta information, aliases, etc.\nParser.detailed = function (args, opts) {\n  return parse(args.slice(), opts)\n}\n\nmodule.exports = Parser\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}