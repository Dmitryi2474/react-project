{"ast":null,"code":"/*!\n * micromatch <https://github.com/jonschlinkert/micromatch>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nvar utils = require('./utils');\nvar Glob = require('./glob');\n\n/**\n * Expose `expand`\n */\n\nmodule.exports = expand;\n\n/**\n * Expand a glob pattern to resolve braces and\n * similar patterns before converting to regex.\n *\n * @param  {String|Array} `pattern`\n * @param  {Array} `files`\n * @param  {Options} `opts`\n * @return {Array}\n */\n\nfunction expand(pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('micromatch.expand(): argument should be a string.');\n  }\n  var glob = new Glob(pattern, options || {});\n  var opts = glob.options;\n  if (!utils.isGlob(pattern)) {\n    glob.pattern = glob.pattern.replace(/([\\/.])/g, '\\\\$1');\n    return glob;\n  }\n  glob.pattern = glob.pattern.replace(/(\\+)(?!\\()/g, '\\\\$1');\n  glob.pattern = glob.pattern.split('$').join('\\\\$');\n  if (typeof opts.braces !== 'boolean' && typeof opts.nobraces !== 'boolean') {\n    opts.braces = true;\n  }\n  if (glob.pattern === '.*') {\n    return {\n      pattern: '\\\\.' + star,\n      tokens: tok,\n      options: opts\n    };\n  }\n  if (glob.pattern === '*') {\n    return {\n      pattern: oneStar(opts.dot),\n      tokens: tok,\n      options: opts\n    };\n  }\n\n  // parse the glob pattern into tokens\n  glob.parse();\n  var tok = glob.tokens;\n  tok.is.negated = opts.negated;\n\n  // dotfile handling\n  if ((opts.dotfiles === true || tok.is.dotfile) && opts.dot !== false) {\n    opts.dotfiles = true;\n    opts.dot = true;\n  }\n  if ((opts.dotdirs === true || tok.is.dotdir) && opts.dot !== false) {\n    opts.dotdirs = true;\n    opts.dot = true;\n  }\n\n  // check for braces with a dotfile pattern\n  if (/[{,]\\./.test(glob.pattern)) {\n    opts.makeRe = false;\n    opts.dot = true;\n  }\n  if (opts.nonegate !== true) {\n    opts.negated = glob.negated;\n  }\n\n  // if the leading character is a dot or a slash, escape it\n  if (glob.pattern.charAt(0) === '.' && glob.pattern.charAt(1) !== '/') {\n    glob.pattern = '\\\\' + glob.pattern;\n  }\n\n  /**\n   * Extended globs\n   */\n\n  // expand braces, e.g `{1..5}`\n  glob.track('before braces');\n  if (tok.is.braces) {\n    glob.braces();\n  }\n  glob.track('after braces');\n\n  // expand extglobs, e.g `foo/!(a|b)`\n  glob.track('before extglob');\n  if (tok.is.extglob) {\n    glob.extglob();\n  }\n  glob.track('after extglob');\n\n  // expand brackets, e.g `[[:alpha:]]`\n  glob.track('before brackets');\n  if (tok.is.brackets) {\n    glob.brackets();\n  }\n  glob.track('after brackets');\n\n  // special patterns\n  glob._replace('[!', '[^');\n  glob._replace('(?', '(%~');\n  glob._replace(/\\[\\]/, '\\\\[\\\\]');\n  glob._replace('/[', '/' + (opts.dot ? dotfiles : nodot) + '[', true);\n  glob._replace('/?', '/' + (opts.dot ? dotfiles : nodot) + '[^/]', true);\n  glob._replace('/.', '/(?=.)\\\\.', true);\n\n  // windows drives\n  glob._replace(/^(\\w):([\\\\\\/]+?)/gi, '(?=.)$1:$2', true);\n\n  // negate slashes in exclusion ranges\n  if (glob.pattern.indexOf('[^') !== -1) {\n    glob.pattern = negateSlash(glob.pattern);\n  }\n  if (opts.globstar !== false && glob.pattern === '**') {\n    glob.pattern = globstar(opts.dot);\n  } else {\n    glob.pattern = balance(glob.pattern, '[', ']');\n    glob.escape(glob.pattern);\n\n    // if the pattern has `**`\n    if (tok.is.globstar) {\n      glob.pattern = collapse(glob.pattern, '/**');\n      glob.pattern = collapse(glob.pattern, '**/');\n      glob._replace('/**/', '(?:/' + globstar(opts.dot) + '/|/)', true);\n      glob._replace(/\\*{2,}/g, '**');\n\n      // 'foo/*'\n      glob._replace(/(\\w+)\\*(?!\\/)/g, '$1[^/]*?', true);\n      glob._replace(/\\*\\*\\/\\*(\\w)/g, globstar(opts.dot) + '\\\\/' + (opts.dot ? dotfiles : nodot) + '[^/]*?$1', true);\n      if (opts.dot !== true) {\n        glob._replace(/\\*\\*\\/(.)/g, '(?:**\\\\/|)$1');\n      }\n\n      // 'foo/**' or '{**,*}', but not 'foo**'\n      if (tok.path.dirname !== '' || /,\\*\\*|\\*\\*,/.test(glob.orig)) {\n        glob._replace('**', globstar(opts.dot), true);\n      }\n    }\n\n    // ends with /*\n    glob._replace(/\\/\\*$/, '\\\\/' + oneStar(opts.dot), true);\n    // ends with *, no slashes\n    glob._replace(/(?!\\/)\\*$/, star, true);\n    // has 'n*.' (partial wildcard w/ file extension)\n    glob._replace(/([^\\/]+)\\*/, '$1' + oneStar(true), true);\n    // has '*'\n    glob._replace('*', oneStar(opts.dot), true);\n    glob._replace('?.', '?\\\\.', true);\n    glob._replace('?:', '?:', true);\n    glob._replace(/\\?+/g, function (match) {\n      var len = match.length;\n      if (len === 1) {\n        return qmark;\n      }\n      return qmark + '{' + len + '}';\n    });\n\n    // escape '.abc' => '\\\\.abc'\n    glob._replace(/\\.([*\\w]+)/g, '\\\\.$1');\n    // fix '[^\\\\\\\\/]'\n    glob._replace(/\\[\\^[\\\\\\/]+\\]/g, qmark);\n    // '///' => '\\/'\n    glob._replace(/\\/+/g, '\\\\/');\n    // '\\\\\\\\\\\\' => '\\\\'\n    glob._replace(/\\\\{2,}/g, '\\\\');\n  }\n\n  // unescape previously escaped patterns\n  glob.unescape(glob.pattern);\n  glob._replace('__UNESC_STAR__', '*');\n\n  // escape dots that follow qmarks\n  glob._replace('?.', '?\\\\.');\n\n  // remove unnecessary slashes in character classes\n  glob._replace('[^\\\\/]', qmark);\n  if (glob.pattern.length > 1) {\n    if (/^[\\[?*]/.test(glob.pattern)) {\n      // only prepend the string if we don't want to match dotfiles\n      glob.pattern = (opts.dot ? dotfiles : nodot) + glob.pattern;\n    }\n  }\n  return glob;\n}\n\n/**\n * Collapse repeated character sequences.\n *\n * ```js\n * collapse('a/../../../b', '../');\n * //=> 'a/../b'\n * ```\n *\n * @param  {String} `str`\n * @param  {String} `ch` Character sequence to collapse\n * @return {String}\n */\n\nfunction collapse(str, ch) {\n  var res = str.split(ch);\n  var isFirst = res[0] === '';\n  var isLast = res[res.length - 1] === '';\n  res = res.filter(Boolean);\n  if (isFirst) res.unshift('');\n  if (isLast) res.push('');\n  return res.join(ch);\n}\n\n/**\n * Negate slashes in exclusion ranges, per glob spec:\n *\n * ```js\n * negateSlash('[^foo]');\n * //=> '[^\\\\/foo]'\n * ```\n *\n * @param  {String} `str` glob pattern\n * @return {String}\n */\n\nfunction negateSlash(str) {\n  return str.replace(/\\[\\^([^\\]]*?)\\]/g, function (match, inner) {\n    if (inner.indexOf('/') === -1) {\n      inner = '\\\\/' + inner;\n    }\n    return '[^' + inner + ']';\n  });\n}\n\n/**\n * Escape imbalanced braces/bracket. This is a very\n * basic, naive implementation that only does enough\n * to serve the purpose.\n */\n\nfunction balance(str, a, b) {\n  var aarr = str.split(a);\n  var alen = aarr.join('').length;\n  var blen = str.split(b).join('').length;\n  if (alen !== blen) {\n    str = aarr.join('\\\\' + a);\n    return str.split(b).join('\\\\' + b);\n  }\n  return str;\n}\n\n/**\n * Special patterns to be converted to regex.\n * Heuristics are used to simplify patterns\n * and speed up processing.\n */\n\n/* eslint no-multi-spaces: 0 */\nvar qmark = '[^/]';\nvar star = qmark + '*?';\nvar nodot = '(?!\\\\.)(?=.)';\nvar dotfileGlob = '(?:\\\\/|^)\\\\.{1,2}($|\\\\/)';\nvar dotfiles = '(?!' + dotfileGlob + ')(?=.)';\nvar twoStarDot = '(?:(?!' + dotfileGlob + ').)*?';\n\n/**\n * Create a regex for `*`.\n *\n * If `dot` is true, or the pattern does not begin with\n * a leading star, then return the simpler regex.\n */\n\nfunction oneStar(dotfile) {\n  return dotfile ? '(?!' + dotfileGlob + ')(?=.)' + star : nodot + star;\n}\nfunction globstar(dotfile) {\n  if (dotfile) {\n    return twoStarDot;\n  }\n  return '(?:(?!(?:\\\\/|^)\\\\.).)*?';\n}","map":{"version":3,"names":["utils","require","Glob","module","exports","expand","pattern","options","TypeError","glob","opts","isGlob","replace","split","join","braces","nobraces","star","tokens","tok","oneStar","dot","parse","is","negated","dotfiles","dotfile","dotdirs","dotdir","test","makeRe","nonegate","charAt","track","extglob","brackets","_replace","nodot","indexOf","negateSlash","globstar","balance","escape","collapse","path","dirname","orig","match","len","length","qmark","unescape","str","ch","res","isFirst","isLast","filter","Boolean","unshift","push","inner","a","b","aarr","alen","blen","dotfileGlob","twoStarDot"],"sources":["/home/user/Рабочий стол/pizza/project/node_modules/micromatch/lib/expand.js"],"sourcesContent":["/*!\n * micromatch <https://github.com/jonschlinkert/micromatch>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nvar utils = require('./utils');\nvar Glob = require('./glob');\n\n/**\n * Expose `expand`\n */\n\nmodule.exports = expand;\n\n/**\n * Expand a glob pattern to resolve braces and\n * similar patterns before converting to regex.\n *\n * @param  {String|Array} `pattern`\n * @param  {Array} `files`\n * @param  {Options} `opts`\n * @return {Array}\n */\n\nfunction expand(pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('micromatch.expand(): argument should be a string.');\n  }\n\n  var glob = new Glob(pattern, options || {});\n  var opts = glob.options;\n\n  if (!utils.isGlob(pattern)) {\n    glob.pattern = glob.pattern.replace(/([\\/.])/g, '\\\\$1');\n    return glob;\n  }\n\n  glob.pattern = glob.pattern.replace(/(\\+)(?!\\()/g, '\\\\$1');\n  glob.pattern = glob.pattern.split('$').join('\\\\$');\n\n  if (typeof opts.braces !== 'boolean' && typeof opts.nobraces !== 'boolean') {\n    opts.braces = true;\n  }\n\n  if (glob.pattern === '.*') {\n    return {\n      pattern: '\\\\.' + star,\n      tokens: tok,\n      options: opts\n    };\n  }\n\n  if (glob.pattern === '*') {\n    return {\n      pattern: oneStar(opts.dot),\n      tokens: tok,\n      options: opts\n    };\n  }\n\n  // parse the glob pattern into tokens\n  glob.parse();\n  var tok = glob.tokens;\n  tok.is.negated = opts.negated;\n\n  // dotfile handling\n  if ((opts.dotfiles === true || tok.is.dotfile) && opts.dot !== false) {\n    opts.dotfiles = true;\n    opts.dot = true;\n  }\n\n  if ((opts.dotdirs === true || tok.is.dotdir) && opts.dot !== false) {\n    opts.dotdirs = true;\n    opts.dot = true;\n  }\n\n  // check for braces with a dotfile pattern\n  if (/[{,]\\./.test(glob.pattern)) {\n    opts.makeRe = false;\n    opts.dot = true;\n  }\n\n  if (opts.nonegate !== true) {\n    opts.negated = glob.negated;\n  }\n\n  // if the leading character is a dot or a slash, escape it\n  if (glob.pattern.charAt(0) === '.' && glob.pattern.charAt(1) !== '/') {\n    glob.pattern = '\\\\' + glob.pattern;\n  }\n\n  /**\n   * Extended globs\n   */\n\n  // expand braces, e.g `{1..5}`\n  glob.track('before braces');\n  if (tok.is.braces) {\n    glob.braces();\n  }\n  glob.track('after braces');\n\n  // expand extglobs, e.g `foo/!(a|b)`\n  glob.track('before extglob');\n  if (tok.is.extglob) {\n    glob.extglob();\n  }\n  glob.track('after extglob');\n\n  // expand brackets, e.g `[[:alpha:]]`\n  glob.track('before brackets');\n  if (tok.is.brackets) {\n    glob.brackets();\n  }\n  glob.track('after brackets');\n\n  // special patterns\n  glob._replace('[!', '[^');\n  glob._replace('(?', '(%~');\n  glob._replace(/\\[\\]/, '\\\\[\\\\]');\n  glob._replace('/[', '/' + (opts.dot ? dotfiles : nodot) + '[', true);\n  glob._replace('/?', '/' + (opts.dot ? dotfiles : nodot) + '[^/]', true);\n  glob._replace('/.', '/(?=.)\\\\.', true);\n\n  // windows drives\n  glob._replace(/^(\\w):([\\\\\\/]+?)/gi, '(?=.)$1:$2', true);\n\n  // negate slashes in exclusion ranges\n  if (glob.pattern.indexOf('[^') !== -1) {\n    glob.pattern = negateSlash(glob.pattern);\n  }\n\n  if (opts.globstar !== false && glob.pattern === '**') {\n    glob.pattern = globstar(opts.dot);\n\n  } else {\n    glob.pattern = balance(glob.pattern, '[', ']');\n    glob.escape(glob.pattern);\n\n    // if the pattern has `**`\n    if (tok.is.globstar) {\n      glob.pattern = collapse(glob.pattern, '/**');\n      glob.pattern = collapse(glob.pattern, '**/');\n      glob._replace('/**/', '(?:/' + globstar(opts.dot) + '/|/)', true);\n      glob._replace(/\\*{2,}/g, '**');\n\n      // 'foo/*'\n      glob._replace(/(\\w+)\\*(?!\\/)/g, '$1[^/]*?', true);\n      glob._replace(/\\*\\*\\/\\*(\\w)/g, globstar(opts.dot) + '\\\\/' + (opts.dot ? dotfiles : nodot) + '[^/]*?$1', true);\n\n      if (opts.dot !== true) {\n        glob._replace(/\\*\\*\\/(.)/g, '(?:**\\\\/|)$1');\n      }\n\n      // 'foo/**' or '{**,*}', but not 'foo**'\n      if (tok.path.dirname !== '' || /,\\*\\*|\\*\\*,/.test(glob.orig)) {\n        glob._replace('**', globstar(opts.dot), true);\n      }\n    }\n\n    // ends with /*\n    glob._replace(/\\/\\*$/, '\\\\/' + oneStar(opts.dot), true);\n    // ends with *, no slashes\n    glob._replace(/(?!\\/)\\*$/, star, true);\n    // has 'n*.' (partial wildcard w/ file extension)\n    glob._replace(/([^\\/]+)\\*/, '$1' + oneStar(true), true);\n    // has '*'\n    glob._replace('*', oneStar(opts.dot), true);\n    glob._replace('?.', '?\\\\.', true);\n    glob._replace('?:', '?:', true);\n\n    glob._replace(/\\?+/g, function(match) {\n      var len = match.length;\n      if (len === 1) {\n        return qmark;\n      }\n      return qmark + '{' + len + '}';\n    });\n\n    // escape '.abc' => '\\\\.abc'\n    glob._replace(/\\.([*\\w]+)/g, '\\\\.$1');\n    // fix '[^\\\\\\\\/]'\n    glob._replace(/\\[\\^[\\\\\\/]+\\]/g, qmark);\n    // '///' => '\\/'\n    glob._replace(/\\/+/g, '\\\\/');\n    // '\\\\\\\\\\\\' => '\\\\'\n    glob._replace(/\\\\{2,}/g, '\\\\');\n  }\n\n  // unescape previously escaped patterns\n  glob.unescape(glob.pattern);\n  glob._replace('__UNESC_STAR__', '*');\n\n  // escape dots that follow qmarks\n  glob._replace('?.', '?\\\\.');\n\n  // remove unnecessary slashes in character classes\n  glob._replace('[^\\\\/]', qmark);\n\n  if (glob.pattern.length > 1) {\n    if (/^[\\[?*]/.test(glob.pattern)) {\n      // only prepend the string if we don't want to match dotfiles\n      glob.pattern = (opts.dot ? dotfiles : nodot) + glob.pattern;\n    }\n  }\n\n  return glob;\n}\n\n/**\n * Collapse repeated character sequences.\n *\n * ```js\n * collapse('a/../../../b', '../');\n * //=> 'a/../b'\n * ```\n *\n * @param  {String} `str`\n * @param  {String} `ch` Character sequence to collapse\n * @return {String}\n */\n\nfunction collapse(str, ch) {\n  var res = str.split(ch);\n  var isFirst = res[0] === '';\n  var isLast = res[res.length - 1] === '';\n  res = res.filter(Boolean);\n  if (isFirst) res.unshift('');\n  if (isLast) res.push('');\n  return res.join(ch);\n}\n\n/**\n * Negate slashes in exclusion ranges, per glob spec:\n *\n * ```js\n * negateSlash('[^foo]');\n * //=> '[^\\\\/foo]'\n * ```\n *\n * @param  {String} `str` glob pattern\n * @return {String}\n */\n\nfunction negateSlash(str) {\n  return str.replace(/\\[\\^([^\\]]*?)\\]/g, function(match, inner) {\n    if (inner.indexOf('/') === -1) {\n      inner = '\\\\/' + inner;\n    }\n    return '[^' + inner + ']';\n  });\n}\n\n/**\n * Escape imbalanced braces/bracket. This is a very\n * basic, naive implementation that only does enough\n * to serve the purpose.\n */\n\nfunction balance(str, a, b) {\n  var aarr = str.split(a);\n  var alen = aarr.join('').length;\n  var blen = str.split(b).join('').length;\n\n  if (alen !== blen) {\n    str = aarr.join('\\\\' + a);\n    return str.split(b).join('\\\\' + b);\n  }\n  return str;\n}\n\n/**\n * Special patterns to be converted to regex.\n * Heuristics are used to simplify patterns\n * and speed up processing.\n */\n\n/* eslint no-multi-spaces: 0 */\nvar qmark       = '[^/]';\nvar star        = qmark + '*?';\nvar nodot       = '(?!\\\\.)(?=.)';\nvar dotfileGlob = '(?:\\\\/|^)\\\\.{1,2}($|\\\\/)';\nvar dotfiles    = '(?!' + dotfileGlob + ')(?=.)';\nvar twoStarDot  = '(?:(?!' + dotfileGlob + ').)*?';\n\n/**\n * Create a regex for `*`.\n *\n * If `dot` is true, or the pattern does not begin with\n * a leading star, then return the simpler regex.\n */\n\nfunction oneStar(dotfile) {\n  return dotfile ? '(?!' + dotfileGlob + ')(?=.)' + star : (nodot + star);\n}\n\nfunction globstar(dotfile) {\n  if (dotfile) { return twoStarDot; }\n  return '(?:(?!(?:\\\\/|^)\\\\.).)*?';\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}