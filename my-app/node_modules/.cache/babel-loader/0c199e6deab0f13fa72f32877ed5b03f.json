{"ast":null,"code":"/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\n'use strict';\n\nconst EventEmitter = require('events');\nconst crypto = require('crypto');\nconst Ultron = require('ultron');\nconst https = require('https');\nconst http = require('http');\nconst url = require('url');\nconst PerMessageDeflate = require('./PerMessageDeflate');\nconst EventTarget = require('./EventTarget');\nconst Extensions = require('./Extensions');\nconst constants = require('./Constants');\nconst Receiver = require('./Receiver');\nconst Sender = require('./Sender');\nconst protocolVersions = [8, 13];\nconst closeTimeout = 30 * 1000; // Allow 30 seconds to terminate the connection cleanly.\n\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */\nclass WebSocket extends EventEmitter {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {String} address The URL to which to connect\n   * @param {(String|String[])} protocols The subprotocols\n   * @param {Object} options Connection options\n   */\n  constructor(address, protocols, options) {\n    super();\n    if (!protocols) {\n      protocols = [];\n    } else if (typeof protocols === 'string') {\n      protocols = [protocols];\n    } else if (!Array.isArray(protocols)) {\n      options = protocols;\n      protocols = [];\n    }\n    this.readyState = WebSocket.CONNECTING;\n    this.bytesReceived = 0;\n    this.extensions = {};\n    this.protocol = '';\n    this._binaryType = constants.BINARY_TYPES[0];\n    this._finalize = this.finalize.bind(this);\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = '';\n    this._closeTimer = null;\n    this._finalized = false;\n    this._closeCode = 1006;\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n    this._ultron = null;\n    if (Array.isArray(address)) {\n      initAsServerClient.call(this, address[0], address[1], options);\n    } else {\n      initAsClient.call(this, address, protocols, options);\n    }\n  }\n  get CONNECTING() {\n    return WebSocket.CONNECTING;\n  }\n  get CLOSING() {\n    return WebSocket.CLOSING;\n  }\n  get CLOSED() {\n    return WebSocket.CLOSED;\n  }\n  get OPEN() {\n    return WebSocket.OPEN;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get bufferedAmount() {\n    var amount = 0;\n    if (this._socket) {\n      amount = this._socket.bufferSize + this._sender._bufferedBytes;\n    }\n    return amount;\n  }\n\n  /**\n   * This deviates from the WHATWG interface since ws doesn't support the required\n   * default \"blob\" type (instead we define a custom \"nodebuffer\" type).\n   *\n   * @type {String}\n   */\n  get binaryType() {\n    return this._binaryType;\n  }\n  set binaryType(type) {\n    if (constants.BINARY_TYPES.indexOf(type) < 0) return;\n    this._binaryType = type;\n\n    //\n    // Allow to change `binaryType` on the fly.\n    //\n    if (this._receiver) this._receiver._binaryType = type;\n  }\n\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @private\n   */\n  setSocket(socket, head) {\n    socket.setTimeout(0);\n    socket.setNoDelay();\n    this._receiver = new Receiver(this.extensions, this._maxPayload, this.binaryType);\n    this._sender = new Sender(socket, this.extensions);\n    this._ultron = new Ultron(socket);\n    this._socket = socket;\n    this._ultron.on('close', this._finalize);\n    this._ultron.on('error', this._finalize);\n    this._ultron.on('end', this._finalize);\n    if (head.length > 0) socket.unshift(head);\n    this._ultron.on('data', data => {\n      this.bytesReceived += data.length;\n      this._receiver.add(data);\n    });\n    this._receiver.onmessage = data => this.emit('message', data);\n    this._receiver.onping = data => {\n      this.pong(data, !this._isServer, true);\n      this.emit('ping', data);\n    };\n    this._receiver.onpong = data => this.emit('pong', data);\n    this._receiver.onclose = (code, reason) => {\n      this._closeFrameReceived = true;\n      this._closeMessage = reason;\n      this._closeCode = code;\n      if (!this._finalized) this.close(code, reason);\n    };\n    this._receiver.onerror = (error, code) => {\n      this._closeMessage = '';\n      this._closeCode = code;\n\n      //\n      // Ensure that the error is emitted even if `WebSocket#finalize()` has\n      // already been called.\n      //\n      this.readyState = WebSocket.CLOSING;\n      this.emit('error', error);\n      this.finalize(true);\n    };\n    this.readyState = WebSocket.OPEN;\n    this.emit('open');\n  }\n\n  /**\n   * Clean up and release internal resources.\n   *\n   * @param {(Boolean|Error)} error Indicates whether or not an error occurred\n   * @private\n   */\n  finalize(error) {\n    if (this._finalized) return;\n    this.readyState = WebSocket.CLOSING;\n    this._finalized = true;\n    if (typeof error === 'object') this.emit('error', error);\n    if (!this._socket) return this.emitClose();\n    clearTimeout(this._closeTimer);\n    this._closeTimer = null;\n    this._ultron.destroy();\n    this._ultron = null;\n    this._socket.on('error', constants.NOOP);\n    if (!error) this._socket.end();else this._socket.destroy();\n    this._socket = null;\n    this._sender = null;\n    this._receiver.cleanup(() => this.emitClose());\n    this._receiver = null;\n  }\n\n  /**\n   * Emit the `close` event.\n   *\n   * @private\n   */\n  emitClose() {\n    this.readyState = WebSocket.CLOSED;\n    this.emit('close', this._closeCode, this._closeMessage);\n    if (this.extensions[PerMessageDeflate.extensionName]) {\n      this.extensions[PerMessageDeflate.extensionName].cleanup();\n    }\n    this.extensions = null;\n    this.removeAllListeners();\n  }\n\n  /**\n   * Pause the socket stream.\n   *\n   * @public\n   */\n  pause() {\n    if (this.readyState !== WebSocket.OPEN) throw new Error('not opened');\n    this._socket.pause();\n  }\n\n  /**\n   * Resume the socket stream\n   *\n   * @public\n   */\n  resume() {\n    if (this.readyState !== WebSocket.OPEN) throw new Error('not opened');\n    this._socket.resume();\n  }\n\n  /**\n   * Start a closing handshake.\n   *\n   *            +----------+     +-----------+   +----------+\n   *     + - - -|ws.close()|---->|close frame|-->|ws.close()|- - - -\n   *            +----------+     +-----------+   +----------+       |\n   *     |      +----------+     +-----------+         |\n   *            |ws.close()|<----|close frame|<--------+            |\n   *            +----------+     +-----------+         |\n   *  CLOSING         |              +---+             |         CLOSING\n   *                  |          +---|fin|<------------+\n   *     |            |          |   +---+                          |\n   *                  |          |   +---+      +-------------+\n   *     |            +----------+-->|fin|----->|ws.finalize()| - - +\n   *                             |   +---+      +-------------+\n   *     |     +-------------+   |\n   *      - - -|ws.finalize()|<--+\n   *           +-------------+\n   *\n   * @param {Number} code Status code explaining why the connection is closing\n   * @param {String} data A string explaining why the connection is closing\n   * @public\n   */\n  close(code, data) {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      this._req.abort();\n      this.finalize(new Error('closed before the connection is established'));\n      return;\n    }\n    if (this.readyState === WebSocket.CLOSING) {\n      if (this._closeFrameSent && this._closeFrameReceived) this._socket.end();\n      return;\n    }\n    this.readyState = WebSocket.CLOSING;\n    this._sender.close(code, data, !this._isServer, err => {\n      //\n      // This error is handled by the `'error'` listener on the socket. We only\n      // want to know if the close frame has been sent here.\n      //\n      if (err) return;\n      this._closeFrameSent = true;\n      if (!this._finalized) {\n        if (this._closeFrameReceived) this._socket.end();\n\n        //\n        // Ensure that the connection is cleaned up even when the closing\n        // handshake fails.\n        //\n        this._closeTimer = setTimeout(this._finalize, closeTimeout, true);\n      }\n    });\n  }\n\n  /**\n   * Send a ping message.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Indicates whether or not to mask `data`\n   * @param {Boolean} failSilently Indicates whether or not to throw if `readyState` isn't `OPEN`\n   * @public\n   */\n  ping(data, mask, failSilently) {\n    if (this.readyState !== WebSocket.OPEN) {\n      if (failSilently) return;\n      throw new Error('not opened');\n    }\n    if (typeof data === 'number') data = data.toString();\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.ping(data || constants.EMPTY_BUFFER, mask);\n  }\n\n  /**\n   * Send a pong message.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Indicates whether or not to mask `data`\n   * @param {Boolean} failSilently Indicates whether or not to throw if `readyState` isn't `OPEN`\n   * @public\n   */\n  pong(data, mask, failSilently) {\n    if (this.readyState !== WebSocket.OPEN) {\n      if (failSilently) return;\n      throw new Error('not opened');\n    }\n    if (typeof data === 'number') data = data.toString();\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.pong(data || constants.EMPTY_BUFFER, mask);\n  }\n\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} options.compress Specifies whether or not to compress `data`\n   * @param {Boolean} options.binary Specifies whether `data` is binary or text\n   * @param {Boolean} options.fin Specifies whether the fragment is the last one\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback which is executed when data is written out\n   * @public\n   */\n  send(data, options, cb) {\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n    if (this.readyState !== WebSocket.OPEN) {\n      if (cb) cb(new Error('not opened'));else throw new Error('not opened');\n      return;\n    }\n    if (typeof data === 'number') data = data.toString();\n    const opts = Object.assign({\n      binary: typeof data !== 'string',\n      mask: !this._isServer,\n      compress: true,\n      fin: true\n    }, options);\n    if (!this.extensions[PerMessageDeflate.extensionName]) {\n      opts.compress = false;\n    }\n    this._sender.send(data || constants.EMPTY_BUFFER, opts, cb);\n  }\n\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n  terminate() {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      this._req.abort();\n      this.finalize(new Error('closed before the connection is established'));\n      return;\n    }\n    this.finalize(true);\n  }\n}\nWebSocket.CONNECTING = 0;\nWebSocket.OPEN = 1;\nWebSocket.CLOSING = 2;\nWebSocket.CLOSED = 3;\n\n//\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n['open', 'error', 'close', 'message'].forEach(method => {\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\n    /**\n     * Return the listener of the event.\n     *\n     * @return {(Function|undefined)} The event listener or `undefined`\n     * @public\n     */\n    get() {\n      const listeners = this.listeners(method);\n      for (var i = 0; i < listeners.length; i++) {\n        if (listeners[i]._listener) return listeners[i]._listener;\n      }\n    },\n    /**\n     * Add a listener for the event.\n     *\n     * @param {Function} listener The listener to add\n     * @public\n     */\n    set(listener) {\n      const listeners = this.listeners(method);\n      for (var i = 0; i < listeners.length; i++) {\n        //\n        // Remove only the listeners added via `addEventListener`.\n        //\n        if (listeners[i]._listener) this.removeListener(method, listeners[i]);\n      }\n      this.addEventListener(method, listener);\n    }\n  });\n});\nWebSocket.prototype.addEventListener = EventTarget.addEventListener;\nWebSocket.prototype.removeEventListener = EventTarget.removeEventListener;\nmodule.exports = WebSocket;\n\n/**\n * Initialize a WebSocket server client.\n *\n * @param {http.IncomingMessage} req The request object\n * @param {net.Socket} socket The network socket between the server and client\n * @param {Buffer} head The first packet of the upgraded stream\n * @param {Object} options WebSocket attributes\n * @param {Number} options.protocolVersion The WebSocket protocol version\n * @param {Object} options.extensions The negotiated extensions\n * @param {Number} options.maxPayload The maximum allowed message size\n * @param {String} options.protocol The chosen subprotocol\n * @private\n */\nfunction initAsServerClient(socket, head, options) {\n  this.protocolVersion = options.protocolVersion;\n  this._maxPayload = options.maxPayload;\n  this.extensions = options.extensions;\n  this.protocol = options.protocol;\n  this._isServer = true;\n  this.setSocket(socket, head);\n}\n\n/**\n * Initialize a WebSocket client.\n *\n * @param {String} address The URL to which to connect\n * @param {String[]} protocols The list of subprotocols\n * @param {Object} options Connection options\n * @param {String} options.protocol Value of the `Sec-WebSocket-Protocol` header\n * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable permessage-deflate\n * @param {Number} options.handshakeTimeout Timeout in milliseconds for the handshake request\n * @param {String} options.localAddress Local interface to bind for network connections\n * @param {Number} options.protocolVersion Value of the `Sec-WebSocket-Version` header\n * @param {Object} options.headers An object containing request headers\n * @param {String} options.origin Value of the `Origin` or `Sec-WebSocket-Origin` header\n * @param {http.Agent} options.agent Use the specified Agent\n * @param {String} options.host Value of the `Host` header\n * @param {Number} options.family IP address family to use during hostname lookup (4 or 6).\n * @param {Function} options.checkServerIdentity A function to validate the server hostname\n * @param {Boolean} options.rejectUnauthorized Verify or not the server certificate\n * @param {String} options.passphrase The passphrase for the private key or pfx\n * @param {String} options.ciphers The ciphers to use or exclude\n * @param {String} options.ecdhCurve The curves for ECDH key agreement to use or exclude\n * @param {(String|String[]|Buffer|Buffer[])} options.cert The certificate key\n * @param {(String|String[]|Buffer|Buffer[])} options.key The private key\n * @param {(String|Buffer)} options.pfx The private key, certificate, and CA certs\n * @param {(String|String[]|Buffer|Buffer[])} options.ca Trusted certificates\n * @private\n */\nfunction initAsClient(address, protocols, options) {\n  options = Object.assign({\n    protocolVersion: protocolVersions[1],\n    protocol: protocols.join(','),\n    perMessageDeflate: true,\n    handshakeTimeout: null,\n    localAddress: null,\n    headers: null,\n    family: null,\n    origin: null,\n    agent: null,\n    host: null,\n    //\n    // SSL options.\n    //\n    checkServerIdentity: null,\n    rejectUnauthorized: null,\n    passphrase: null,\n    ciphers: null,\n    ecdhCurve: null,\n    cert: null,\n    key: null,\n    pfx: null,\n    ca: null\n  }, options);\n  if (protocolVersions.indexOf(options.protocolVersion) === -1) {\n    throw new Error(`unsupported protocol version: ${options.protocolVersion} ` + `(supported versions: ${protocolVersions.join(', ')})`);\n  }\n  this.protocolVersion = options.protocolVersion;\n  this._isServer = false;\n  this.url = address;\n  const serverUrl = url.parse(address);\n  const isUnixSocket = serverUrl.protocol === 'ws+unix:';\n  if (!serverUrl.host && (!isUnixSocket || !serverUrl.path)) {\n    throw new Error('invalid url');\n  }\n  const isSecure = serverUrl.protocol === 'wss:' || serverUrl.protocol === 'https:';\n  const key = crypto.randomBytes(16).toString('base64');\n  const httpObj = isSecure ? https : http;\n  var perMessageDeflate;\n  const requestOptions = {\n    port: serverUrl.port || (isSecure ? 443 : 80),\n    host: serverUrl.hostname,\n    path: '/',\n    headers: {\n      'Sec-WebSocket-Version': options.protocolVersion,\n      'Sec-WebSocket-Key': key,\n      'Connection': 'Upgrade',\n      'Upgrade': 'websocket'\n    }\n  };\n  if (options.headers) Object.assign(requestOptions.headers, options.headers);\n  if (options.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(options.perMessageDeflate !== true ? options.perMessageDeflate : {}, false);\n    requestOptions.headers['Sec-WebSocket-Extensions'] = Extensions.format({\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n    });\n  }\n  if (options.protocol) {\n    requestOptions.headers['Sec-WebSocket-Protocol'] = options.protocol;\n  }\n  if (options.origin) {\n    if (options.protocolVersion < 13) {\n      requestOptions.headers['Sec-WebSocket-Origin'] = options.origin;\n    } else {\n      requestOptions.headers.Origin = options.origin;\n    }\n  }\n  if (options.host) requestOptions.headers.Host = options.host;\n  if (serverUrl.auth) requestOptions.auth = serverUrl.auth;\n  if (options.localAddress) requestOptions.localAddress = options.localAddress;\n  if (options.family) requestOptions.family = options.family;\n  if (isUnixSocket) {\n    const parts = serverUrl.path.split(':');\n    requestOptions.socketPath = parts[0];\n    requestOptions.path = parts[1];\n  } else if (serverUrl.path) {\n    //\n    // Make sure that path starts with `/`.\n    //\n    if (serverUrl.path.charAt(0) !== '/') {\n      requestOptions.path = `/${serverUrl.path}`;\n    } else {\n      requestOptions.path = serverUrl.path;\n    }\n  }\n  var agent = options.agent;\n\n  //\n  // A custom agent is required for these options.\n  //\n  if (options.rejectUnauthorized != null || options.checkServerIdentity || options.passphrase || options.ciphers || options.ecdhCurve || options.cert || options.key || options.pfx || options.ca) {\n    if (options.passphrase) requestOptions.passphrase = options.passphrase;\n    if (options.ciphers) requestOptions.ciphers = options.ciphers;\n    if (options.ecdhCurve) requestOptions.ecdhCurve = options.ecdhCurve;\n    if (options.cert) requestOptions.cert = options.cert;\n    if (options.key) requestOptions.key = options.key;\n    if (options.pfx) requestOptions.pfx = options.pfx;\n    if (options.ca) requestOptions.ca = options.ca;\n    if (options.checkServerIdentity) {\n      requestOptions.checkServerIdentity = options.checkServerIdentity;\n    }\n    if (options.rejectUnauthorized != null) {\n      requestOptions.rejectUnauthorized = options.rejectUnauthorized;\n    }\n    if (!agent) agent = new httpObj.Agent(requestOptions);\n  }\n  if (agent) requestOptions.agent = agent;\n  this._req = httpObj.get(requestOptions);\n  if (options.handshakeTimeout) {\n    this._req.setTimeout(options.handshakeTimeout, () => {\n      this._req.abort();\n      this.finalize(new Error('opening handshake has timed out'));\n    });\n  }\n  this._req.on('error', error => {\n    if (this._req.aborted) return;\n    this._req = null;\n    this.finalize(error);\n  });\n  this._req.on('response', res => {\n    if (!this.emit('unexpected-response', this._req, res)) {\n      this._req.abort();\n      this.finalize(new Error(`unexpected server response (${res.statusCode})`));\n    }\n  });\n  this._req.on('upgrade', (res, socket, head) => {\n    this.emit('headers', res.headers, res);\n\n    //\n    // The user may have closed the connection from a listener of the `headers`\n    // event.\n    //\n    if (this.readyState !== WebSocket.CONNECTING) return;\n    this._req = null;\n    const digest = crypto.createHash('sha1').update(key + constants.GUID, 'binary').digest('base64');\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      socket.destroy();\n      return this.finalize(new Error('invalid server key'));\n    }\n    const serverProt = res.headers['sec-websocket-protocol'];\n    const protList = (options.protocol || '').split(/, */);\n    var protError;\n    if (!options.protocol && serverProt) {\n      protError = 'server sent a subprotocol even though none requested';\n    } else if (options.protocol && !serverProt) {\n      protError = 'server sent no subprotocol even though requested';\n    } else if (serverProt && protList.indexOf(serverProt) === -1) {\n      protError = 'server responded with an invalid protocol';\n    }\n    if (protError) {\n      socket.destroy();\n      return this.finalize(new Error(protError));\n    }\n    if (serverProt) this.protocol = serverProt;\n    if (perMessageDeflate) {\n      try {\n        const serverExtensions = Extensions.parse(res.headers['sec-websocket-extensions']);\n        if (serverExtensions[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(serverExtensions[PerMessageDeflate.extensionName]);\n          this.extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        socket.destroy();\n        this.finalize(new Error('invalid Sec-WebSocket-Extensions header'));\n        return;\n      }\n    }\n    this.setSocket(socket, head);\n  });\n}","map":{"version":3,"names":["EventEmitter","require","crypto","Ultron","https","http","url","PerMessageDeflate","EventTarget","Extensions","constants","Receiver","Sender","protocolVersions","closeTimeout","WebSocket","constructor","address","protocols","options","Array","isArray","readyState","CONNECTING","bytesReceived","extensions","protocol","_binaryType","BINARY_TYPES","_finalize","finalize","bind","_closeFrameReceived","_closeFrameSent","_closeMessage","_closeTimer","_finalized","_closeCode","_receiver","_sender","_socket","_ultron","initAsServerClient","call","initAsClient","CLOSING","CLOSED","OPEN","bufferedAmount","amount","bufferSize","_bufferedBytes","binaryType","type","indexOf","setSocket","socket","head","setTimeout","setNoDelay","_maxPayload","on","length","unshift","data","add","onmessage","emit","onping","pong","_isServer","onpong","onclose","code","reason","close","onerror","error","emitClose","clearTimeout","destroy","NOOP","end","cleanup","extensionName","removeAllListeners","pause","Error","resume","_req","abort","err","ping","mask","failSilently","toString","undefined","EMPTY_BUFFER","send","cb","opts","Object","assign","binary","compress","fin","terminate","forEach","method","defineProperty","prototype","get","listeners","i","_listener","set","listener","removeListener","addEventListener","removeEventListener","module","exports","protocolVersion","maxPayload","join","perMessageDeflate","handshakeTimeout","localAddress","headers","family","origin","agent","host","checkServerIdentity","rejectUnauthorized","passphrase","ciphers","ecdhCurve","cert","key","pfx","ca","serverUrl","parse","isUnixSocket","path","isSecure","randomBytes","httpObj","requestOptions","port","hostname","format","offer","Origin","Host","auth","parts","split","socketPath","charAt","Agent","aborted","res","statusCode","digest","createHash","update","GUID","serverProt","protList","protError","serverExtensions","accept"],"sources":["/home/user/Рабочий стол/pizza/project/node_modules/ws/lib/WebSocket.js"],"sourcesContent":["/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\n'use strict';\n\nconst EventEmitter = require('events');\nconst crypto = require('crypto');\nconst Ultron = require('ultron');\nconst https = require('https');\nconst http = require('http');\nconst url = require('url');\n\nconst PerMessageDeflate = require('./PerMessageDeflate');\nconst EventTarget = require('./EventTarget');\nconst Extensions = require('./Extensions');\nconst constants = require('./Constants');\nconst Receiver = require('./Receiver');\nconst Sender = require('./Sender');\n\nconst protocolVersions = [8, 13];\nconst closeTimeout = 30 * 1000; // Allow 30 seconds to terminate the connection cleanly.\n\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */\nclass WebSocket extends EventEmitter {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {String} address The URL to which to connect\n   * @param {(String|String[])} protocols The subprotocols\n   * @param {Object} options Connection options\n   */\n  constructor (address, protocols, options) {\n    super();\n\n    if (!protocols) {\n      protocols = [];\n    } else if (typeof protocols === 'string') {\n      protocols = [protocols];\n    } else if (!Array.isArray(protocols)) {\n      options = protocols;\n      protocols = [];\n    }\n\n    this.readyState = WebSocket.CONNECTING;\n    this.bytesReceived = 0;\n    this.extensions = {};\n    this.protocol = '';\n\n    this._binaryType = constants.BINARY_TYPES[0];\n    this._finalize = this.finalize.bind(this);\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = '';\n    this._closeTimer = null;\n    this._finalized = false;\n    this._closeCode = 1006;\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n    this._ultron = null;\n\n    if (Array.isArray(address)) {\n      initAsServerClient.call(this, address[0], address[1], options);\n    } else {\n      initAsClient.call(this, address, protocols, options);\n    }\n  }\n\n  get CONNECTING () { return WebSocket.CONNECTING; }\n  get CLOSING () { return WebSocket.CLOSING; }\n  get CLOSED () { return WebSocket.CLOSED; }\n  get OPEN () { return WebSocket.OPEN; }\n\n  /**\n   * @type {Number}\n   */\n  get bufferedAmount () {\n    var amount = 0;\n\n    if (this._socket) {\n      amount = this._socket.bufferSize + this._sender._bufferedBytes;\n    }\n    return amount;\n  }\n\n  /**\n   * This deviates from the WHATWG interface since ws doesn't support the required\n   * default \"blob\" type (instead we define a custom \"nodebuffer\" type).\n   *\n   * @type {String}\n   */\n  get binaryType () {\n    return this._binaryType;\n  }\n\n  set binaryType (type) {\n    if (constants.BINARY_TYPES.indexOf(type) < 0) return;\n\n    this._binaryType = type;\n\n    //\n    // Allow to change `binaryType` on the fly.\n    //\n    if (this._receiver) this._receiver._binaryType = type;\n  }\n\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @private\n   */\n  setSocket (socket, head) {\n    socket.setTimeout(0);\n    socket.setNoDelay();\n\n    this._receiver = new Receiver(this.extensions, this._maxPayload, this.binaryType);\n    this._sender = new Sender(socket, this.extensions);\n    this._ultron = new Ultron(socket);\n    this._socket = socket;\n\n    this._ultron.on('close', this._finalize);\n    this._ultron.on('error', this._finalize);\n    this._ultron.on('end', this._finalize);\n\n    if (head.length > 0) socket.unshift(head);\n\n    this._ultron.on('data', (data) => {\n      this.bytesReceived += data.length;\n      this._receiver.add(data);\n    });\n\n    this._receiver.onmessage = (data) => this.emit('message', data);\n    this._receiver.onping = (data) => {\n      this.pong(data, !this._isServer, true);\n      this.emit('ping', data);\n    };\n    this._receiver.onpong = (data) => this.emit('pong', data);\n    this._receiver.onclose = (code, reason) => {\n      this._closeFrameReceived = true;\n      this._closeMessage = reason;\n      this._closeCode = code;\n      if (!this._finalized) this.close(code, reason);\n    };\n    this._receiver.onerror = (error, code) => {\n      this._closeMessage = '';\n      this._closeCode = code;\n\n      //\n      // Ensure that the error is emitted even if `WebSocket#finalize()` has\n      // already been called.\n      //\n      this.readyState = WebSocket.CLOSING;\n      this.emit('error', error);\n      this.finalize(true);\n    };\n\n    this.readyState = WebSocket.OPEN;\n    this.emit('open');\n  }\n\n  /**\n   * Clean up and release internal resources.\n   *\n   * @param {(Boolean|Error)} error Indicates whether or not an error occurred\n   * @private\n   */\n  finalize (error) {\n    if (this._finalized) return;\n\n    this.readyState = WebSocket.CLOSING;\n    this._finalized = true;\n\n    if (typeof error === 'object') this.emit('error', error);\n    if (!this._socket) return this.emitClose();\n\n    clearTimeout(this._closeTimer);\n    this._closeTimer = null;\n\n    this._ultron.destroy();\n    this._ultron = null;\n\n    this._socket.on('error', constants.NOOP);\n\n    if (!error) this._socket.end();\n    else this._socket.destroy();\n\n    this._socket = null;\n    this._sender = null;\n\n    this._receiver.cleanup(() => this.emitClose());\n    this._receiver = null;\n  }\n\n  /**\n   * Emit the `close` event.\n   *\n   * @private\n   */\n  emitClose () {\n    this.readyState = WebSocket.CLOSED;\n\n    this.emit('close', this._closeCode, this._closeMessage);\n\n    if (this.extensions[PerMessageDeflate.extensionName]) {\n      this.extensions[PerMessageDeflate.extensionName].cleanup();\n    }\n\n    this.extensions = null;\n\n    this.removeAllListeners();\n  }\n\n  /**\n   * Pause the socket stream.\n   *\n   * @public\n   */\n  pause () {\n    if (this.readyState !== WebSocket.OPEN) throw new Error('not opened');\n\n    this._socket.pause();\n  }\n\n  /**\n   * Resume the socket stream\n   *\n   * @public\n   */\n  resume () {\n    if (this.readyState !== WebSocket.OPEN) throw new Error('not opened');\n\n    this._socket.resume();\n  }\n\n  /**\n   * Start a closing handshake.\n   *\n   *            +----------+     +-----------+   +----------+\n   *     + - - -|ws.close()|---->|close frame|-->|ws.close()|- - - -\n   *            +----------+     +-----------+   +----------+       |\n   *     |      +----------+     +-----------+         |\n   *            |ws.close()|<----|close frame|<--------+            |\n   *            +----------+     +-----------+         |\n   *  CLOSING         |              +---+             |         CLOSING\n   *                  |          +---|fin|<------------+\n   *     |            |          |   +---+                          |\n   *                  |          |   +---+      +-------------+\n   *     |            +----------+-->|fin|----->|ws.finalize()| - - +\n   *                             |   +---+      +-------------+\n   *     |     +-------------+   |\n   *      - - -|ws.finalize()|<--+\n   *           +-------------+\n   *\n   * @param {Number} code Status code explaining why the connection is closing\n   * @param {String} data A string explaining why the connection is closing\n   * @public\n   */\n  close (code, data) {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      this._req.abort();\n      this.finalize(new Error('closed before the connection is established'));\n      return;\n    }\n\n    if (this.readyState === WebSocket.CLOSING) {\n      if (this._closeFrameSent && this._closeFrameReceived) this._socket.end();\n      return;\n    }\n\n    this.readyState = WebSocket.CLOSING;\n    this._sender.close(code, data, !this._isServer, (err) => {\n      //\n      // This error is handled by the `'error'` listener on the socket. We only\n      // want to know if the close frame has been sent here.\n      //\n      if (err) return;\n\n      this._closeFrameSent = true;\n\n      if (!this._finalized) {\n        if (this._closeFrameReceived) this._socket.end();\n\n        //\n        // Ensure that the connection is cleaned up even when the closing\n        // handshake fails.\n        //\n        this._closeTimer = setTimeout(this._finalize, closeTimeout, true);\n      }\n    });\n  }\n\n  /**\n   * Send a ping message.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Indicates whether or not to mask `data`\n   * @param {Boolean} failSilently Indicates whether or not to throw if `readyState` isn't `OPEN`\n   * @public\n   */\n  ping (data, mask, failSilently) {\n    if (this.readyState !== WebSocket.OPEN) {\n      if (failSilently) return;\n      throw new Error('not opened');\n    }\n\n    if (typeof data === 'number') data = data.toString();\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.ping(data || constants.EMPTY_BUFFER, mask);\n  }\n\n  /**\n   * Send a pong message.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Indicates whether or not to mask `data`\n   * @param {Boolean} failSilently Indicates whether or not to throw if `readyState` isn't `OPEN`\n   * @public\n   */\n  pong (data, mask, failSilently) {\n    if (this.readyState !== WebSocket.OPEN) {\n      if (failSilently) return;\n      throw new Error('not opened');\n    }\n\n    if (typeof data === 'number') data = data.toString();\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.pong(data || constants.EMPTY_BUFFER, mask);\n  }\n\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} options.compress Specifies whether or not to compress `data`\n   * @param {Boolean} options.binary Specifies whether `data` is binary or text\n   * @param {Boolean} options.fin Specifies whether the fragment is the last one\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback which is executed when data is written out\n   * @public\n   */\n  send (data, options, cb) {\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    if (this.readyState !== WebSocket.OPEN) {\n      if (cb) cb(new Error('not opened'));\n      else throw new Error('not opened');\n      return;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    const opts = Object.assign({\n      binary: typeof data !== 'string',\n      mask: !this._isServer,\n      compress: true,\n      fin: true\n    }, options);\n\n    if (!this.extensions[PerMessageDeflate.extensionName]) {\n      opts.compress = false;\n    }\n\n    this._sender.send(data || constants.EMPTY_BUFFER, opts, cb);\n  }\n\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n  terminate () {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      this._req.abort();\n      this.finalize(new Error('closed before the connection is established'));\n      return;\n    }\n\n    this.finalize(true);\n  }\n}\n\nWebSocket.CONNECTING = 0;\nWebSocket.OPEN = 1;\nWebSocket.CLOSING = 2;\nWebSocket.CLOSED = 3;\n\n//\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n['open', 'error', 'close', 'message'].forEach((method) => {\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\n    /**\n     * Return the listener of the event.\n     *\n     * @return {(Function|undefined)} The event listener or `undefined`\n     * @public\n     */\n    get () {\n      const listeners = this.listeners(method);\n      for (var i = 0; i < listeners.length; i++) {\n        if (listeners[i]._listener) return listeners[i]._listener;\n      }\n    },\n    /**\n     * Add a listener for the event.\n     *\n     * @param {Function} listener The listener to add\n     * @public\n     */\n    set (listener) {\n      const listeners = this.listeners(method);\n      for (var i = 0; i < listeners.length; i++) {\n        //\n        // Remove only the listeners added via `addEventListener`.\n        //\n        if (listeners[i]._listener) this.removeListener(method, listeners[i]);\n      }\n      this.addEventListener(method, listener);\n    }\n  });\n});\n\nWebSocket.prototype.addEventListener = EventTarget.addEventListener;\nWebSocket.prototype.removeEventListener = EventTarget.removeEventListener;\n\nmodule.exports = WebSocket;\n\n/**\n * Initialize a WebSocket server client.\n *\n * @param {http.IncomingMessage} req The request object\n * @param {net.Socket} socket The network socket between the server and client\n * @param {Buffer} head The first packet of the upgraded stream\n * @param {Object} options WebSocket attributes\n * @param {Number} options.protocolVersion The WebSocket protocol version\n * @param {Object} options.extensions The negotiated extensions\n * @param {Number} options.maxPayload The maximum allowed message size\n * @param {String} options.protocol The chosen subprotocol\n * @private\n */\nfunction initAsServerClient (socket, head, options) {\n  this.protocolVersion = options.protocolVersion;\n  this._maxPayload = options.maxPayload;\n  this.extensions = options.extensions;\n  this.protocol = options.protocol;\n\n  this._isServer = true;\n\n  this.setSocket(socket, head);\n}\n\n/**\n * Initialize a WebSocket client.\n *\n * @param {String} address The URL to which to connect\n * @param {String[]} protocols The list of subprotocols\n * @param {Object} options Connection options\n * @param {String} options.protocol Value of the `Sec-WebSocket-Protocol` header\n * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable permessage-deflate\n * @param {Number} options.handshakeTimeout Timeout in milliseconds for the handshake request\n * @param {String} options.localAddress Local interface to bind for network connections\n * @param {Number} options.protocolVersion Value of the `Sec-WebSocket-Version` header\n * @param {Object} options.headers An object containing request headers\n * @param {String} options.origin Value of the `Origin` or `Sec-WebSocket-Origin` header\n * @param {http.Agent} options.agent Use the specified Agent\n * @param {String} options.host Value of the `Host` header\n * @param {Number} options.family IP address family to use during hostname lookup (4 or 6).\n * @param {Function} options.checkServerIdentity A function to validate the server hostname\n * @param {Boolean} options.rejectUnauthorized Verify or not the server certificate\n * @param {String} options.passphrase The passphrase for the private key or pfx\n * @param {String} options.ciphers The ciphers to use or exclude\n * @param {String} options.ecdhCurve The curves for ECDH key agreement to use or exclude\n * @param {(String|String[]|Buffer|Buffer[])} options.cert The certificate key\n * @param {(String|String[]|Buffer|Buffer[])} options.key The private key\n * @param {(String|Buffer)} options.pfx The private key, certificate, and CA certs\n * @param {(String|String[]|Buffer|Buffer[])} options.ca Trusted certificates\n * @private\n */\nfunction initAsClient (address, protocols, options) {\n  options = Object.assign({\n    protocolVersion: protocolVersions[1],\n    protocol: protocols.join(','),\n    perMessageDeflate: true,\n    handshakeTimeout: null,\n    localAddress: null,\n    headers: null,\n    family: null,\n    origin: null,\n    agent: null,\n    host: null,\n\n    //\n    // SSL options.\n    //\n    checkServerIdentity: null,\n    rejectUnauthorized: null,\n    passphrase: null,\n    ciphers: null,\n    ecdhCurve: null,\n    cert: null,\n    key: null,\n    pfx: null,\n    ca: null\n  }, options);\n\n  if (protocolVersions.indexOf(options.protocolVersion) === -1) {\n    throw new Error(\n      `unsupported protocol version: ${options.protocolVersion} ` +\n      `(supported versions: ${protocolVersions.join(', ')})`\n    );\n  }\n\n  this.protocolVersion = options.protocolVersion;\n  this._isServer = false;\n  this.url = address;\n\n  const serverUrl = url.parse(address);\n  const isUnixSocket = serverUrl.protocol === 'ws+unix:';\n\n  if (!serverUrl.host && (!isUnixSocket || !serverUrl.path)) {\n    throw new Error('invalid url');\n  }\n\n  const isSecure = serverUrl.protocol === 'wss:' || serverUrl.protocol === 'https:';\n  const key = crypto.randomBytes(16).toString('base64');\n  const httpObj = isSecure ? https : http;\n  var perMessageDeflate;\n\n  const requestOptions = {\n    port: serverUrl.port || (isSecure ? 443 : 80),\n    host: serverUrl.hostname,\n    path: '/',\n    headers: {\n      'Sec-WebSocket-Version': options.protocolVersion,\n      'Sec-WebSocket-Key': key,\n      'Connection': 'Upgrade',\n      'Upgrade': 'websocket'\n    }\n  };\n\n  if (options.headers) Object.assign(requestOptions.headers, options.headers);\n  if (options.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(\n      options.perMessageDeflate !== true ? options.perMessageDeflate : {},\n      false\n    );\n    requestOptions.headers['Sec-WebSocket-Extensions'] = Extensions.format({\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n    });\n  }\n  if (options.protocol) {\n    requestOptions.headers['Sec-WebSocket-Protocol'] = options.protocol;\n  }\n  if (options.origin) {\n    if (options.protocolVersion < 13) {\n      requestOptions.headers['Sec-WebSocket-Origin'] = options.origin;\n    } else {\n      requestOptions.headers.Origin = options.origin;\n    }\n  }\n  if (options.host) requestOptions.headers.Host = options.host;\n  if (serverUrl.auth) requestOptions.auth = serverUrl.auth;\n\n  if (options.localAddress) requestOptions.localAddress = options.localAddress;\n  if (options.family) requestOptions.family = options.family;\n\n  if (isUnixSocket) {\n    const parts = serverUrl.path.split(':');\n\n    requestOptions.socketPath = parts[0];\n    requestOptions.path = parts[1];\n  } else if (serverUrl.path) {\n    //\n    // Make sure that path starts with `/`.\n    //\n    if (serverUrl.path.charAt(0) !== '/') {\n      requestOptions.path = `/${serverUrl.path}`;\n    } else {\n      requestOptions.path = serverUrl.path;\n    }\n  }\n\n  var agent = options.agent;\n\n  //\n  // A custom agent is required for these options.\n  //\n  if (\n    options.rejectUnauthorized != null ||\n    options.checkServerIdentity ||\n    options.passphrase ||\n    options.ciphers ||\n    options.ecdhCurve ||\n    options.cert ||\n    options.key ||\n    options.pfx ||\n    options.ca\n  ) {\n    if (options.passphrase) requestOptions.passphrase = options.passphrase;\n    if (options.ciphers) requestOptions.ciphers = options.ciphers;\n    if (options.ecdhCurve) requestOptions.ecdhCurve = options.ecdhCurve;\n    if (options.cert) requestOptions.cert = options.cert;\n    if (options.key) requestOptions.key = options.key;\n    if (options.pfx) requestOptions.pfx = options.pfx;\n    if (options.ca) requestOptions.ca = options.ca;\n    if (options.checkServerIdentity) {\n      requestOptions.checkServerIdentity = options.checkServerIdentity;\n    }\n    if (options.rejectUnauthorized != null) {\n      requestOptions.rejectUnauthorized = options.rejectUnauthorized;\n    }\n\n    if (!agent) agent = new httpObj.Agent(requestOptions);\n  }\n\n  if (agent) requestOptions.agent = agent;\n\n  this._req = httpObj.get(requestOptions);\n\n  if (options.handshakeTimeout) {\n    this._req.setTimeout(options.handshakeTimeout, () => {\n      this._req.abort();\n      this.finalize(new Error('opening handshake has timed out'));\n    });\n  }\n\n  this._req.on('error', (error) => {\n    if (this._req.aborted) return;\n\n    this._req = null;\n    this.finalize(error);\n  });\n\n  this._req.on('response', (res) => {\n    if (!this.emit('unexpected-response', this._req, res)) {\n      this._req.abort();\n      this.finalize(new Error(`unexpected server response (${res.statusCode})`));\n    }\n  });\n\n  this._req.on('upgrade', (res, socket, head) => {\n    this.emit('headers', res.headers, res);\n\n    //\n    // The user may have closed the connection from a listener of the `headers`\n    // event.\n    //\n    if (this.readyState !== WebSocket.CONNECTING) return;\n\n    this._req = null;\n\n    const digest = crypto.createHash('sha1')\n      .update(key + constants.GUID, 'binary')\n      .digest('base64');\n\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      socket.destroy();\n      return this.finalize(new Error('invalid server key'));\n    }\n\n    const serverProt = res.headers['sec-websocket-protocol'];\n    const protList = (options.protocol || '').split(/, */);\n    var protError;\n\n    if (!options.protocol && serverProt) {\n      protError = 'server sent a subprotocol even though none requested';\n    } else if (options.protocol && !serverProt) {\n      protError = 'server sent no subprotocol even though requested';\n    } else if (serverProt && protList.indexOf(serverProt) === -1) {\n      protError = 'server responded with an invalid protocol';\n    }\n\n    if (protError) {\n      socket.destroy();\n      return this.finalize(new Error(protError));\n    }\n\n    if (serverProt) this.protocol = serverProt;\n\n    if (perMessageDeflate) {\n      try {\n        const serverExtensions = Extensions.parse(\n          res.headers['sec-websocket-extensions']\n        );\n\n        if (serverExtensions[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(\n            serverExtensions[PerMessageDeflate.extensionName]\n          );\n          this.extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        socket.destroy();\n        this.finalize(new Error('invalid Sec-WebSocket-Extensions header'));\n        return;\n      }\n    }\n\n    this.setSocket(socket, head);\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}