{"ast":null,"code":"var url = require(\"url\");\nvar Immutable = require(\"immutable\");\nmodule.exports.init = function (ui, bs) {\n  var validUrls = Immutable.OrderedSet();\n  var methods = {\n    /**\n     * Send the url list to UI\n     * @param urls\n     */\n    sendUpdatedUrls: function (urls) {\n      ui.socket.emit(\"ui:history:update\", decorateUrls(urls));\n    },\n    /**\n     * Only send to UI if list changed\n     * @param current\n     * @param temp\n     */\n    sendUpdatedIfChanged: function (current, temp) {\n      if (!Immutable.is(current, temp)) {\n        validUrls = temp;\n        methods.sendUpdatedUrls(validUrls);\n      }\n    },\n    /**\n     * Send all clients to a URL - this is a proxy\n     * in case we need to limit/check anything.\n     * @param data\n     */\n    sendToUrl: function (data) {\n      var parsed = url.parse(data.path);\n      data.override = true;\n      data.path = parsed.path;\n      data.url = parsed.href;\n      ui.clients.emit(\"browser:location\", data);\n    },\n    /**\n     * Add a new path\n     * @param data\n     */\n    addPath: function (data) {\n      var temp = addPath(validUrls, url.parse(data.href), bs.options.get(\"mode\"));\n      methods.sendUpdatedIfChanged(validUrls, temp, ui.socket);\n    },\n    /**\n     * Remove a path\n     * @param data\n     */\n    removePath: function (data) {\n      var temp = removePath(validUrls, data.path);\n      methods.sendUpdatedIfChanged(validUrls, temp, ui.socket);\n    },\n    /**\n     * Get the current list\n     */\n    getVisited: function () {\n      ui.socket.emit(\"ui:receive:visited\", decorateUrls(validUrls));\n    }\n  };\n  ui.clients.on(\"connection\", function (client) {\n    client.on(\"ui:history:connected\", methods.addPath);\n  });\n  ui.socket.on(\"connection\", function (uiClient) {\n    /**\n     * Send urls on first connection\n     */\n    uiClient.on(\"ui:get:visited\", methods.getVisited);\n    methods.sendUpdatedUrls(validUrls);\n  });\n  ui.listen(\"history\", {\n    \"sendAllTo\": methods.sendToUrl,\n    \"remove\": methods.removePath,\n    \"clear\": function () {\n      validUrls = Immutable.OrderedSet([]);\n      methods.sendUpdatedUrls(validUrls);\n    }\n  });\n  return methods;\n};\n\n/**\n * @param {Immutable.Set} urls\n * @returns {Array}\n */\nfunction decorateUrls(urls) {\n  var count = 0;\n  return urls.map(function (value) {\n    count += 1;\n    return {\n      path: value,\n      key: count\n    };\n  }).toJS().reverse();\n}\n\n/**\n * If snippet mode, add the full URL\n * if server/proxy, add JUST the path\n * @param immSet\n * @param urlObj\n * @param mode\n * @returns {Set}\n */\nfunction addPath(immSet, urlObj, mode) {\n  return immSet.add(mode === \"snippet\" ? urlObj.href : urlObj.path);\n}\nmodule.exports.addPath = addPath;\n\n/**\n * @param immSet\n * @param urlPath\n * @returns {*}\n */\nfunction removePath(immSet, urlPath) {\n  return immSet.remove(url.parse(urlPath).path);\n}\nmodule.exports.removePath = removePath;","map":{"version":3,"names":["url","require","Immutable","module","exports","init","ui","bs","validUrls","OrderedSet","methods","sendUpdatedUrls","urls","socket","emit","decorateUrls","sendUpdatedIfChanged","current","temp","is","sendToUrl","data","parsed","parse","path","override","href","clients","addPath","options","get","removePath","getVisited","on","client","uiClient","listen","count","map","value","key","toJS","reverse","immSet","urlObj","mode","add","urlPath","remove"],"sources":["/home/user/Рабочий стол/pizza/project/node_modules/browser-sync-ui/lib/plugins/history/history.js"],"sourcesContent":["var url       = require(\"url\");\nvar Immutable = require(\"immutable\");\n\nmodule.exports.init = function (ui, bs) {\n\n    var validUrls = Immutable.OrderedSet();\n\n    var methods = {\n        /**\n         * Send the url list to UI\n         * @param urls\n         */\n        sendUpdatedUrls: function (urls) {\n            ui.socket.emit(\"ui:history:update\", decorateUrls(urls));\n        },\n        /**\n         * Only send to UI if list changed\n         * @param current\n         * @param temp\n         */\n        sendUpdatedIfChanged: function (current, temp) {\n            if (!Immutable.is(current, temp)) {\n                validUrls = temp;\n                methods.sendUpdatedUrls(validUrls);\n            }\n        },\n        /**\n         * Send all clients to a URL - this is a proxy\n         * in case we need to limit/check anything.\n         * @param data\n         */\n        sendToUrl: function (data) {\n\n            var parsed = url.parse(data.path);\n\n            data.override = true;\n            data.path = parsed.path;\n            data.url  = parsed.href;\n\n            ui.clients.emit(\"browser:location\", data);\n        },\n        /**\n         * Add a new path\n         * @param data\n         */\n        addPath: function (data) {\n            var temp = addPath(validUrls, url.parse(data.href), bs.options.get(\"mode\"));\n            methods.sendUpdatedIfChanged(validUrls, temp, ui.socket);\n        },\n        /**\n         * Remove a path\n         * @param data\n         */\n        removePath: function (data) {\n            var temp = removePath(validUrls, data.path);\n            methods.sendUpdatedIfChanged(validUrls, temp, ui.socket);\n        },\n        /**\n         * Get the current list\n         */\n        getVisited: function () {\n            ui.socket.emit(\"ui:receive:visited\", decorateUrls(validUrls));\n        }\n    };\n\n    ui.clients.on(\"connection\", function (client) {\n        client.on(\"ui:history:connected\", methods.addPath);\n    });\n\n    ui.socket.on(\"connection\", function (uiClient) {\n        /**\n         * Send urls on first connection\n         */\n        uiClient.on(\"ui:get:visited\",    methods.getVisited);\n        methods.sendUpdatedUrls(validUrls);\n    });\n\n    ui.listen(\"history\", {\n        \"sendAllTo\": methods.sendToUrl,\n        \"remove\":    methods.removePath,\n        \"clear\":     function () {\n            validUrls = Immutable.OrderedSet([]);\n            methods.sendUpdatedUrls(validUrls);\n        }\n    });\n\n    return methods;\n};\n\n/**\n * @param {Immutable.Set} urls\n * @returns {Array}\n */\nfunction decorateUrls (urls) {\n    var count = 0;\n    return urls.map(function (value) {\n        count += 1;\n        return {\n            path: value,\n            key: count\n        };\n    }).toJS().reverse();\n}\n\n/**\n * If snippet mode, add the full URL\n * if server/proxy, add JUST the path\n * @param immSet\n * @param urlObj\n * @param mode\n * @returns {Set}\n */\nfunction addPath(immSet, urlObj, mode) {\n    return immSet.add(\n        mode === \"snippet\"\n            ? urlObj.href\n            : urlObj.path\n    );\n}\n\nmodule.exports.addPath = addPath;\n\n/**\n * @param immSet\n * @param urlPath\n * @returns {*}\n */\nfunction removePath(immSet, urlPath) {\n    return immSet.remove(url.parse(urlPath).path);\n}\n\nmodule.exports.removePath = removePath;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}