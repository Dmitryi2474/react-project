{"ast":null,"code":"/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\n'use strict';\n\nconst safeBuffer = require('safe-buffer');\nconst EventEmitter = require('events');\nconst crypto = require('crypto');\nconst Ultron = require('ultron');\nconst http = require('http');\nconst url = require('url');\nconst PerMessageDeflate = require('./PerMessageDeflate');\nconst Extensions = require('./Extensions');\nconst constants = require('./Constants');\nconst WebSocket = require('./WebSocket');\nconst Buffer = safeBuffer.Buffer;\n\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */\nclass WebSocketServer extends EventEmitter {\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {String} options.host The hostname where to bind the server\n   * @param {Number} options.port The port where to bind the server\n   * @param {http.Server} options.server A pre-created HTTP/S server to use\n   * @param {Function} options.verifyClient An hook to reject connections\n   * @param {Function} options.handleProtocols An hook to handle protocols\n   * @param {String} options.path Accept only connections matching this path\n   * @param {Boolean} options.noServer Enable no server mode\n   * @param {Boolean} options.clientTracking Specifies whether or not to track clients\n   * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable permessage-deflate\n   * @param {Number} options.maxPayload The maximum allowed message size\n   * @param {Function} callback A listener for the `listening` event\n   */\n  constructor(options, callback) {\n    super();\n    options = Object.assign({\n      maxPayload: 100 * 1024 * 1024,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null,\n      // use default (511 as implemented in net.js)\n      server: null,\n      host: null,\n      path: null,\n      port: null\n    }, options);\n    if (options.port == null && !options.server && !options.noServer) {\n      throw new TypeError('missing or invalid options');\n    }\n    if (options.port != null) {\n      this._server = http.createServer((req, res) => {\n        const body = http.STATUS_CODES[426];\n        res.writeHead(426, {\n          'Content-Length': body.length,\n          'Content-Type': 'text/plain'\n        });\n        res.end(body);\n      });\n      this._server.listen(options.port, options.host, options.backlog, callback);\n    } else if (options.server) {\n      this._server = options.server;\n    }\n    if (this._server) {\n      this._ultron = new Ultron(this._server);\n      this._ultron.on('listening', () => this.emit('listening'));\n      this._ultron.on('error', err => this.emit('error', err));\n      this._ultron.on('upgrade', (req, socket, head) => {\n        this.handleUpgrade(req, socket, head, client => {\n          this.emit('connection', client, req);\n        });\n      });\n    }\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n    if (options.clientTracking) this.clients = new Set();\n    this.options = options;\n  }\n\n  /**\n   * Close the server.\n   *\n   * @param {Function} cb Callback\n   * @public\n   */\n  close(cb) {\n    //\n    // Terminate all associated clients.\n    //\n    if (this.clients) {\n      for (const client of this.clients) client.terminate();\n    }\n    const server = this._server;\n    if (server) {\n      this._ultron.destroy();\n      this._ultron = this._server = null;\n\n      //\n      // Close the http server if it was internally created.\n      //\n      if (this.options.port != null) return server.close(cb);\n    }\n    if (cb) cb();\n  }\n\n  /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */\n  shouldHandle(req) {\n    if (this.options.path && url.parse(req.url).pathname !== this.options.path) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */\n  handleUpgrade(req, socket, head, cb) {\n    socket.on('error', socketError);\n    const version = +req.headers['sec-websocket-version'];\n    const extensions = {};\n    if (req.method !== 'GET' || req.headers.upgrade.toLowerCase() !== 'websocket' || !req.headers['sec-websocket-key'] || version !== 8 && version !== 13 || !this.shouldHandle(req)) {\n      return abortConnection(socket, 400);\n    }\n    if (this.options.perMessageDeflate) {\n      const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);\n      try {\n        const offers = Extensions.parse(req.headers['sec-websocket-extensions']);\n        if (offers[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        return abortConnection(socket, 400);\n      }\n    }\n    var protocol = (req.headers['sec-websocket-protocol'] || '').split(/, */);\n\n    //\n    // Optionally call external protocol selection handler.\n    //\n    if (this.options.handleProtocols) {\n      protocol = this.options.handleProtocols(protocol, req);\n      if (protocol === false) return abortConnection(socket, 401);\n    } else {\n      protocol = protocol[0];\n    }\n\n    //\n    // Optionally call external client verification handler.\n    //\n    if (this.options.verifyClient) {\n      const info = {\n        origin: req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\n        secure: !!(req.connection.authorized || req.connection.encrypted),\n        req\n      };\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message) => {\n          if (!verified) return abortConnection(socket, code || 401, message);\n          this.completeUpgrade(protocol, extensions, version, req, socket, head, cb);\n        });\n        return;\n      }\n      if (!this.options.verifyClient(info)) return abortConnection(socket, 401);\n    }\n    this.completeUpgrade(protocol, extensions, version, req, socket, head, cb);\n  }\n\n  /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {String} protocol The chosen subprotocol\n   * @param {Object} extensions The accepted extensions\n   * @param {Number} version The WebSocket protocol version\n   * @param {http.IncomingMessage} req The request object\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @private\n   */\n  completeUpgrade(protocol, extensions, version, req, socket, head, cb) {\n    //\n    // Destroy the socket if the client has already sent a FIN packet.\n    //\n    if (!socket.readable || !socket.writable) return socket.destroy();\n    const key = crypto.createHash('sha1').update(req.headers['sec-websocket-key'] + constants.GUID, 'binary').digest('base64');\n    const headers = ['HTTP/1.1 101 Switching Protocols', 'Upgrade: websocket', 'Connection: Upgrade', `Sec-WebSocket-Accept: ${key}`];\n    if (protocol) headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n    if (extensions[PerMessageDeflate.extensionName]) {\n      const params = extensions[PerMessageDeflate.extensionName].params;\n      const value = Extensions.format({\n        [PerMessageDeflate.extensionName]: [params]\n      });\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\n    }\n\n    //\n    // Allow external modification/inspection of handshake headers.\n    //\n    this.emit('headers', headers, req);\n    socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n    const client = new WebSocket([socket, head], null, {\n      maxPayload: this.options.maxPayload,\n      protocolVersion: version,\n      extensions,\n      protocol\n    });\n    if (this.clients) {\n      this.clients.add(client);\n      client.on('close', () => this.clients.delete(client));\n    }\n    socket.removeListener('error', socketError);\n    cb(client);\n  }\n}\nmodule.exports = WebSocketServer;\n\n/**\n * Handle premature socket errors.\n *\n * @private\n */\nfunction socketError() {\n  this.destroy();\n}\n\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {net.Socket} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @private\n */\nfunction abortConnection(socket, code, message) {\n  if (socket.writable) {\n    message = message || http.STATUS_CODES[code];\n    socket.write(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` + 'Connection: close\\r\\n' + 'Content-type: text/html\\r\\n' + `Content-Length: ${Buffer.byteLength(message)}\\r\\n` + '\\r\\n' + message);\n  }\n  socket.removeListener('error', socketError);\n  socket.destroy();\n}","map":{"version":3,"names":["safeBuffer","require","EventEmitter","crypto","Ultron","http","url","PerMessageDeflate","Extensions","constants","WebSocket","Buffer","WebSocketServer","constructor","options","callback","Object","assign","maxPayload","perMessageDeflate","handleProtocols","clientTracking","verifyClient","noServer","backlog","server","host","path","port","TypeError","_server","createServer","req","res","body","STATUS_CODES","writeHead","length","end","listen","_ultron","on","emit","err","socket","head","handleUpgrade","client","clients","Set","close","cb","terminate","destroy","shouldHandle","parse","pathname","socketError","version","headers","extensions","method","upgrade","toLowerCase","abortConnection","offers","extensionName","accept","protocol","split","info","origin","secure","connection","authorized","encrypted","verified","code","message","completeUpgrade","readable","writable","key","createHash","update","GUID","digest","push","params","value","format","write","concat","join","protocolVersion","add","delete","removeListener","module","exports","byteLength"],"sources":["/home/user/Рабочий стол/pizza/project/node_modules/ws/lib/WebSocketServer.js"],"sourcesContent":["/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\n'use strict';\n\nconst safeBuffer = require('safe-buffer');\nconst EventEmitter = require('events');\nconst crypto = require('crypto');\nconst Ultron = require('ultron');\nconst http = require('http');\nconst url = require('url');\n\nconst PerMessageDeflate = require('./PerMessageDeflate');\nconst Extensions = require('./Extensions');\nconst constants = require('./Constants');\nconst WebSocket = require('./WebSocket');\n\nconst Buffer = safeBuffer.Buffer;\n\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */\nclass WebSocketServer extends EventEmitter {\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {String} options.host The hostname where to bind the server\n   * @param {Number} options.port The port where to bind the server\n   * @param {http.Server} options.server A pre-created HTTP/S server to use\n   * @param {Function} options.verifyClient An hook to reject connections\n   * @param {Function} options.handleProtocols An hook to handle protocols\n   * @param {String} options.path Accept only connections matching this path\n   * @param {Boolean} options.noServer Enable no server mode\n   * @param {Boolean} options.clientTracking Specifies whether or not to track clients\n   * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable permessage-deflate\n   * @param {Number} options.maxPayload The maximum allowed message size\n   * @param {Function} callback A listener for the `listening` event\n   */\n  constructor (options, callback) {\n    super();\n\n    options = Object.assign({\n      maxPayload: 100 * 1024 * 1024,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null, // use default (511 as implemented in net.js)\n      server: null,\n      host: null,\n      path: null,\n      port: null\n    }, options);\n\n    if (options.port == null && !options.server && !options.noServer) {\n      throw new TypeError('missing or invalid options');\n    }\n\n    if (options.port != null) {\n      this._server = http.createServer((req, res) => {\n        const body = http.STATUS_CODES[426];\n\n        res.writeHead(426, {\n          'Content-Length': body.length,\n          'Content-Type': 'text/plain'\n        });\n        res.end(body);\n      });\n      this._server.listen(options.port, options.host, options.backlog, callback);\n    } else if (options.server) {\n      this._server = options.server;\n    }\n\n    if (this._server) {\n      this._ultron = new Ultron(this._server);\n      this._ultron.on('listening', () => this.emit('listening'));\n      this._ultron.on('error', (err) => this.emit('error', err));\n      this._ultron.on('upgrade', (req, socket, head) => {\n        this.handleUpgrade(req, socket, head, (client) => {\n          this.emit('connection', client, req);\n        });\n      });\n    }\n\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n    if (options.clientTracking) this.clients = new Set();\n    this.options = options;\n  }\n\n  /**\n   * Close the server.\n   *\n   * @param {Function} cb Callback\n   * @public\n   */\n  close (cb) {\n    //\n    // Terminate all associated clients.\n    //\n    if (this.clients) {\n      for (const client of this.clients) client.terminate();\n    }\n\n    const server = this._server;\n\n    if (server) {\n      this._ultron.destroy();\n      this._ultron = this._server = null;\n\n      //\n      // Close the http server if it was internally created.\n      //\n      if (this.options.port != null) return server.close(cb);\n    }\n\n    if (cb) cb();\n  }\n\n  /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */\n  shouldHandle (req) {\n    if (this.options.path && url.parse(req.url).pathname !== this.options.path) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */\n  handleUpgrade (req, socket, head, cb) {\n    socket.on('error', socketError);\n\n    const version = +req.headers['sec-websocket-version'];\n    const extensions = {};\n\n    if (\n      req.method !== 'GET' || req.headers.upgrade.toLowerCase() !== 'websocket' ||\n      !req.headers['sec-websocket-key'] || (version !== 8 && version !== 13) ||\n      !this.shouldHandle(req)\n    ) {\n      return abortConnection(socket, 400);\n    }\n\n    if (this.options.perMessageDeflate) {\n      const perMessageDeflate = new PerMessageDeflate(\n        this.options.perMessageDeflate,\n        true,\n        this.options.maxPayload\n      );\n\n      try {\n        const offers = Extensions.parse(\n          req.headers['sec-websocket-extensions']\n        );\n\n        if (offers[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        return abortConnection(socket, 400);\n      }\n    }\n\n    var protocol = (req.headers['sec-websocket-protocol'] || '').split(/, */);\n\n    //\n    // Optionally call external protocol selection handler.\n    //\n    if (this.options.handleProtocols) {\n      protocol = this.options.handleProtocols(protocol, req);\n      if (protocol === false) return abortConnection(socket, 401);\n    } else {\n      protocol = protocol[0];\n    }\n\n    //\n    // Optionally call external client verification handler.\n    //\n    if (this.options.verifyClient) {\n      const info = {\n        origin: req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\n        secure: !!(req.connection.authorized || req.connection.encrypted),\n        req\n      };\n\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message) => {\n          if (!verified) return abortConnection(socket, code || 401, message);\n\n          this.completeUpgrade(\n            protocol,\n            extensions,\n            version,\n            req,\n            socket,\n            head,\n            cb\n          );\n        });\n        return;\n      }\n\n      if (!this.options.verifyClient(info)) return abortConnection(socket, 401);\n    }\n\n    this.completeUpgrade(protocol, extensions, version, req, socket, head, cb);\n  }\n\n  /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {String} protocol The chosen subprotocol\n   * @param {Object} extensions The accepted extensions\n   * @param {Number} version The WebSocket protocol version\n   * @param {http.IncomingMessage} req The request object\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @private\n   */\n  completeUpgrade (protocol, extensions, version, req, socket, head, cb) {\n    //\n    // Destroy the socket if the client has already sent a FIN packet.\n    //\n    if (!socket.readable || !socket.writable) return socket.destroy();\n\n    const key = crypto.createHash('sha1')\n      .update(req.headers['sec-websocket-key'] + constants.GUID, 'binary')\n      .digest('base64');\n\n    const headers = [\n      'HTTP/1.1 101 Switching Protocols',\n      'Upgrade: websocket',\n      'Connection: Upgrade',\n      `Sec-WebSocket-Accept: ${key}`\n    ];\n\n    if (protocol) headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n    if (extensions[PerMessageDeflate.extensionName]) {\n      const params = extensions[PerMessageDeflate.extensionName].params;\n      const value = Extensions.format({\n        [PerMessageDeflate.extensionName]: [params]\n      });\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\n    }\n\n    //\n    // Allow external modification/inspection of handshake headers.\n    //\n    this.emit('headers', headers, req);\n\n    socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n\n    const client = new WebSocket([socket, head], null, {\n      maxPayload: this.options.maxPayload,\n      protocolVersion: version,\n      extensions,\n      protocol\n    });\n\n    if (this.clients) {\n      this.clients.add(client);\n      client.on('close', () => this.clients.delete(client));\n    }\n\n    socket.removeListener('error', socketError);\n    cb(client);\n  }\n}\n\nmodule.exports = WebSocketServer;\n\n/**\n * Handle premature socket errors.\n *\n * @private\n */\nfunction socketError () {\n  this.destroy();\n}\n\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {net.Socket} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @private\n */\nfunction abortConnection (socket, code, message) {\n  if (socket.writable) {\n    message = message || http.STATUS_CODES[code];\n    socket.write(\n      `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` +\n      'Connection: close\\r\\n' +\n      'Content-type: text/html\\r\\n' +\n      `Content-Length: ${Buffer.byteLength(message)}\\r\\n` +\n      '\\r\\n' +\n      message\n    );\n  }\n\n  socket.removeListener('error', socketError);\n  socket.destroy();\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,MAAMA,UAAU,GAAGC,OAAO,CAAC,aAAa,CAAC;AACzC,MAAMC,YAAY,GAAGD,OAAO,CAAC,QAAQ,CAAC;AACtC,MAAME,MAAM,GAAGF,OAAO,CAAC,QAAQ,CAAC;AAChC,MAAMG,MAAM,GAAGH,OAAO,CAAC,QAAQ,CAAC;AAChC,MAAMI,IAAI,GAAGJ,OAAO,CAAC,MAAM,CAAC;AAC5B,MAAMK,GAAG,GAAGL,OAAO,CAAC,KAAK,CAAC;AAE1B,MAAMM,iBAAiB,GAAGN,OAAO,CAAC,qBAAqB,CAAC;AACxD,MAAMO,UAAU,GAAGP,OAAO,CAAC,cAAc,CAAC;AAC1C,MAAMQ,SAAS,GAAGR,OAAO,CAAC,aAAa,CAAC;AACxC,MAAMS,SAAS,GAAGT,OAAO,CAAC,aAAa,CAAC;AAExC,MAAMU,MAAM,GAAGX,UAAU,CAACW,MAAM;;AAEhC;AACA;AACA;AACA;AACA;AACA,MAAMC,eAAe,SAASV,YAAY,CAAC;EACzC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEW,WAAW,CAAEC,OAAO,EAAEC,QAAQ,EAAE;IAC9B,KAAK,EAAE;IAEPD,OAAO,GAAGE,MAAM,CAACC,MAAM,CAAC;MACtBC,UAAU,EAAE,GAAG,GAAG,IAAI,GAAG,IAAI;MAC7BC,iBAAiB,EAAE,KAAK;MACxBC,eAAe,EAAE,IAAI;MACrBC,cAAc,EAAE,IAAI;MACpBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,KAAK;MACfC,OAAO,EAAE,IAAI;MAAE;MACfC,MAAM,EAAE,IAAI;MACZC,IAAI,EAAE,IAAI;MACVC,IAAI,EAAE,IAAI;MACVC,IAAI,EAAE;IACR,CAAC,EAAEd,OAAO,CAAC;IAEX,IAAIA,OAAO,CAACc,IAAI,IAAI,IAAI,IAAI,CAACd,OAAO,CAACW,MAAM,IAAI,CAACX,OAAO,CAACS,QAAQ,EAAE;MAChE,MAAM,IAAIM,SAAS,CAAC,4BAA4B,CAAC;IACnD;IAEA,IAAIf,OAAO,CAACc,IAAI,IAAI,IAAI,EAAE;MACxB,IAAI,CAACE,OAAO,GAAGzB,IAAI,CAAC0B,YAAY,CAAC,CAACC,GAAG,EAAEC,GAAG,KAAK;QAC7C,MAAMC,IAAI,GAAG7B,IAAI,CAAC8B,YAAY,CAAC,GAAG,CAAC;QAEnCF,GAAG,CAACG,SAAS,CAAC,GAAG,EAAE;UACjB,gBAAgB,EAAEF,IAAI,CAACG,MAAM;UAC7B,cAAc,EAAE;QAClB,CAAC,CAAC;QACFJ,GAAG,CAACK,GAAG,CAACJ,IAAI,CAAC;MACf,CAAC,CAAC;MACF,IAAI,CAACJ,OAAO,CAACS,MAAM,CAACzB,OAAO,CAACc,IAAI,EAAEd,OAAO,CAACY,IAAI,EAAEZ,OAAO,CAACU,OAAO,EAAET,QAAQ,CAAC;IAC5E,CAAC,MAAM,IAAID,OAAO,CAACW,MAAM,EAAE;MACzB,IAAI,CAACK,OAAO,GAAGhB,OAAO,CAACW,MAAM;IAC/B;IAEA,IAAI,IAAI,CAACK,OAAO,EAAE;MAChB,IAAI,CAACU,OAAO,GAAG,IAAIpC,MAAM,CAAC,IAAI,CAAC0B,OAAO,CAAC;MACvC,IAAI,CAACU,OAAO,CAACC,EAAE,CAAC,WAAW,EAAE,MAAM,IAAI,CAACC,IAAI,CAAC,WAAW,CAAC,CAAC;MAC1D,IAAI,CAACF,OAAO,CAACC,EAAE,CAAC,OAAO,EAAGE,GAAG,IAAK,IAAI,CAACD,IAAI,CAAC,OAAO,EAAEC,GAAG,CAAC,CAAC;MAC1D,IAAI,CAACH,OAAO,CAACC,EAAE,CAAC,SAAS,EAAE,CAACT,GAAG,EAAEY,MAAM,EAAEC,IAAI,KAAK;QAChD,IAAI,CAACC,aAAa,CAACd,GAAG,EAAEY,MAAM,EAAEC,IAAI,EAAGE,MAAM,IAAK;UAChD,IAAI,CAACL,IAAI,CAAC,YAAY,EAAEK,MAAM,EAAEf,GAAG,CAAC;QACtC,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ;IAEA,IAAIlB,OAAO,CAACK,iBAAiB,KAAK,IAAI,EAAEL,OAAO,CAACK,iBAAiB,GAAG,CAAC,CAAC;IACtE,IAAIL,OAAO,CAACO,cAAc,EAAE,IAAI,CAAC2B,OAAO,GAAG,IAAIC,GAAG,EAAE;IACpD,IAAI,CAACnC,OAAO,GAAGA,OAAO;EACxB;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEoC,KAAK,CAAEC,EAAE,EAAE;IACT;IACA;IACA;IACA,IAAI,IAAI,CAACH,OAAO,EAAE;MAChB,KAAK,MAAMD,MAAM,IAAI,IAAI,CAACC,OAAO,EAAED,MAAM,CAACK,SAAS,EAAE;IACvD;IAEA,MAAM3B,MAAM,GAAG,IAAI,CAACK,OAAO;IAE3B,IAAIL,MAAM,EAAE;MACV,IAAI,CAACe,OAAO,CAACa,OAAO,EAAE;MACtB,IAAI,CAACb,OAAO,GAAG,IAAI,CAACV,OAAO,GAAG,IAAI;;MAElC;MACA;MACA;MACA,IAAI,IAAI,CAAChB,OAAO,CAACc,IAAI,IAAI,IAAI,EAAE,OAAOH,MAAM,CAACyB,KAAK,CAACC,EAAE,CAAC;IACxD;IAEA,IAAIA,EAAE,EAAEA,EAAE,EAAE;EACd;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACEG,YAAY,CAAEtB,GAAG,EAAE;IACjB,IAAI,IAAI,CAAClB,OAAO,CAACa,IAAI,IAAIrB,GAAG,CAACiD,KAAK,CAACvB,GAAG,CAAC1B,GAAG,CAAC,CAACkD,QAAQ,KAAK,IAAI,CAAC1C,OAAO,CAACa,IAAI,EAAE;MAC1E,OAAO,KAAK;IACd;IAEA,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEmB,aAAa,CAAEd,GAAG,EAAEY,MAAM,EAAEC,IAAI,EAAEM,EAAE,EAAE;IACpCP,MAAM,CAACH,EAAE,CAAC,OAAO,EAAEgB,WAAW,CAAC;IAE/B,MAAMC,OAAO,GAAG,CAAC1B,GAAG,CAAC2B,OAAO,CAAC,uBAAuB,CAAC;IACrD,MAAMC,UAAU,GAAG,CAAC,CAAC;IAErB,IACE5B,GAAG,CAAC6B,MAAM,KAAK,KAAK,IAAI7B,GAAG,CAAC2B,OAAO,CAACG,OAAO,CAACC,WAAW,EAAE,KAAK,WAAW,IACzE,CAAC/B,GAAG,CAAC2B,OAAO,CAAC,mBAAmB,CAAC,IAAKD,OAAO,KAAK,CAAC,IAAIA,OAAO,KAAK,EAAG,IACtE,CAAC,IAAI,CAACJ,YAAY,CAACtB,GAAG,CAAC,EACvB;MACA,OAAOgC,eAAe,CAACpB,MAAM,EAAE,GAAG,CAAC;IACrC;IAEA,IAAI,IAAI,CAAC9B,OAAO,CAACK,iBAAiB,EAAE;MAClC,MAAMA,iBAAiB,GAAG,IAAIZ,iBAAiB,CAC7C,IAAI,CAACO,OAAO,CAACK,iBAAiB,EAC9B,IAAI,EACJ,IAAI,CAACL,OAAO,CAACI,UAAU,CACxB;MAED,IAAI;QACF,MAAM+C,MAAM,GAAGzD,UAAU,CAAC+C,KAAK,CAC7BvB,GAAG,CAAC2B,OAAO,CAAC,0BAA0B,CAAC,CACxC;QAED,IAAIM,MAAM,CAAC1D,iBAAiB,CAAC2D,aAAa,CAAC,EAAE;UAC3C/C,iBAAiB,CAACgD,MAAM,CAACF,MAAM,CAAC1D,iBAAiB,CAAC2D,aAAa,CAAC,CAAC;UACjEN,UAAU,CAACrD,iBAAiB,CAAC2D,aAAa,CAAC,GAAG/C,iBAAiB;QACjE;MACF,CAAC,CAAC,OAAOwB,GAAG,EAAE;QACZ,OAAOqB,eAAe,CAACpB,MAAM,EAAE,GAAG,CAAC;MACrC;IACF;IAEA,IAAIwB,QAAQ,GAAG,CAACpC,GAAG,CAAC2B,OAAO,CAAC,wBAAwB,CAAC,IAAI,EAAE,EAAEU,KAAK,CAAC,KAAK,CAAC;;IAEzE;IACA;IACA;IACA,IAAI,IAAI,CAACvD,OAAO,CAACM,eAAe,EAAE;MAChCgD,QAAQ,GAAG,IAAI,CAACtD,OAAO,CAACM,eAAe,CAACgD,QAAQ,EAAEpC,GAAG,CAAC;MACtD,IAAIoC,QAAQ,KAAK,KAAK,EAAE,OAAOJ,eAAe,CAACpB,MAAM,EAAE,GAAG,CAAC;IAC7D,CAAC,MAAM;MACLwB,QAAQ,GAAGA,QAAQ,CAAC,CAAC,CAAC;IACxB;;IAEA;IACA;IACA;IACA,IAAI,IAAI,CAACtD,OAAO,CAACQ,YAAY,EAAE;MAC7B,MAAMgD,IAAI,GAAG;QACXC,MAAM,EAAEvC,GAAG,CAAC2B,OAAO,CAAE,GAAED,OAAO,KAAK,CAAC,GAAG,sBAAsB,GAAG,QAAS,EAAC,CAAC;QAC3Ec,MAAM,EAAE,CAAC,EAAExC,GAAG,CAACyC,UAAU,CAACC,UAAU,IAAI1C,GAAG,CAACyC,UAAU,CAACE,SAAS,CAAC;QACjE3C;MACF,CAAC;MAED,IAAI,IAAI,CAAClB,OAAO,CAACQ,YAAY,CAACe,MAAM,KAAK,CAAC,EAAE;QAC1C,IAAI,CAACvB,OAAO,CAACQ,YAAY,CAACgD,IAAI,EAAE,CAACM,QAAQ,EAAEC,IAAI,EAAEC,OAAO,KAAK;UAC3D,IAAI,CAACF,QAAQ,EAAE,OAAOZ,eAAe,CAACpB,MAAM,EAAEiC,IAAI,IAAI,GAAG,EAAEC,OAAO,CAAC;UAEnE,IAAI,CAACC,eAAe,CAClBX,QAAQ,EACRR,UAAU,EACVF,OAAO,EACP1B,GAAG,EACHY,MAAM,EACNC,IAAI,EACJM,EAAE,CACH;QACH,CAAC,CAAC;QACF;MACF;MAEA,IAAI,CAAC,IAAI,CAACrC,OAAO,CAACQ,YAAY,CAACgD,IAAI,CAAC,EAAE,OAAON,eAAe,CAACpB,MAAM,EAAE,GAAG,CAAC;IAC3E;IAEA,IAAI,CAACmC,eAAe,CAACX,QAAQ,EAAER,UAAU,EAAEF,OAAO,EAAE1B,GAAG,EAAEY,MAAM,EAAEC,IAAI,EAAEM,EAAE,CAAC;EAC5E;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE4B,eAAe,CAAEX,QAAQ,EAAER,UAAU,EAAEF,OAAO,EAAE1B,GAAG,EAAEY,MAAM,EAAEC,IAAI,EAAEM,EAAE,EAAE;IACrE;IACA;IACA;IACA,IAAI,CAACP,MAAM,CAACoC,QAAQ,IAAI,CAACpC,MAAM,CAACqC,QAAQ,EAAE,OAAOrC,MAAM,CAACS,OAAO,EAAE;IAEjE,MAAM6B,GAAG,GAAG/E,MAAM,CAACgF,UAAU,CAAC,MAAM,CAAC,CAClCC,MAAM,CAACpD,GAAG,CAAC2B,OAAO,CAAC,mBAAmB,CAAC,GAAGlD,SAAS,CAAC4E,IAAI,EAAE,QAAQ,CAAC,CACnEC,MAAM,CAAC,QAAQ,CAAC;IAEnB,MAAM3B,OAAO,GAAG,CACd,kCAAkC,EAClC,oBAAoB,EACpB,qBAAqB,EACpB,yBAAwBuB,GAAI,EAAC,CAC/B;IAED,IAAId,QAAQ,EAAET,OAAO,CAAC4B,IAAI,CAAE,2BAA0BnB,QAAS,EAAC,CAAC;IACjE,IAAIR,UAAU,CAACrD,iBAAiB,CAAC2D,aAAa,CAAC,EAAE;MAC/C,MAAMsB,MAAM,GAAG5B,UAAU,CAACrD,iBAAiB,CAAC2D,aAAa,CAAC,CAACsB,MAAM;MACjE,MAAMC,KAAK,GAAGjF,UAAU,CAACkF,MAAM,CAAC;QAC9B,CAACnF,iBAAiB,CAAC2D,aAAa,GAAG,CAACsB,MAAM;MAC5C,CAAC,CAAC;MACF7B,OAAO,CAAC4B,IAAI,CAAE,6BAA4BE,KAAM,EAAC,CAAC;IACpD;;IAEA;IACA;IACA;IACA,IAAI,CAAC/C,IAAI,CAAC,SAAS,EAAEiB,OAAO,EAAE3B,GAAG,CAAC;IAElCY,MAAM,CAAC+C,KAAK,CAAChC,OAAO,CAACiC,MAAM,CAAC,MAAM,CAAC,CAACC,IAAI,CAAC,MAAM,CAAC,CAAC;IAEjD,MAAM9C,MAAM,GAAG,IAAIrC,SAAS,CAAC,CAACkC,MAAM,EAAEC,IAAI,CAAC,EAAE,IAAI,EAAE;MACjD3B,UAAU,EAAE,IAAI,CAACJ,OAAO,CAACI,UAAU;MACnC4E,eAAe,EAAEpC,OAAO;MACxBE,UAAU;MACVQ;IACF,CAAC,CAAC;IAEF,IAAI,IAAI,CAACpB,OAAO,EAAE;MAChB,IAAI,CAACA,OAAO,CAAC+C,GAAG,CAAChD,MAAM,CAAC;MACxBA,MAAM,CAACN,EAAE,CAAC,OAAO,EAAE,MAAM,IAAI,CAACO,OAAO,CAACgD,MAAM,CAACjD,MAAM,CAAC,CAAC;IACvD;IAEAH,MAAM,CAACqD,cAAc,CAAC,OAAO,EAAExC,WAAW,CAAC;IAC3CN,EAAE,CAACJ,MAAM,CAAC;EACZ;AACF;AAEAmD,MAAM,CAACC,OAAO,GAAGvF,eAAe;;AAEhC;AACA;AACA;AACA;AACA;AACA,SAAS6C,WAAW,GAAI;EACtB,IAAI,CAACJ,OAAO,EAAE;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASW,eAAe,CAAEpB,MAAM,EAAEiC,IAAI,EAAEC,OAAO,EAAE;EAC/C,IAAIlC,MAAM,CAACqC,QAAQ,EAAE;IACnBH,OAAO,GAAGA,OAAO,IAAIzE,IAAI,CAAC8B,YAAY,CAAC0C,IAAI,CAAC;IAC5CjC,MAAM,CAAC+C,KAAK,CACT,YAAWd,IAAK,IAAGxE,IAAI,CAAC8B,YAAY,CAAC0C,IAAI,CAAE,MAAK,GACjD,uBAAuB,GACvB,6BAA6B,GAC5B,mBAAkBlE,MAAM,CAACyF,UAAU,CAACtB,OAAO,CAAE,MAAK,GACnD,MAAM,GACNA,OAAO,CACR;EACH;EAEAlC,MAAM,CAACqD,cAAc,CAAC,OAAO,EAAExC,WAAW,CAAC;EAC3Cb,MAAM,CAACS,OAAO,EAAE;AAClB"},"metadata":{},"sourceType":"script"}