{"ast":null,"code":"'use strict';\n\n// The ABNF grammar in the spec is totally ambiguous.\n//\n// This parser follows the operator precedence defined in the\n// `Order of Precedence and Parentheses` section.\nmodule.exports = function (tokens) {\n  var index = 0;\n  function hasMore() {\n    return index < tokens.length;\n  }\n  function token() {\n    return hasMore() ? tokens[index] : null;\n  }\n  function next() {\n    if (!hasMore()) {\n      throw new Error();\n    }\n    index++;\n  }\n  function parseOperator(operator) {\n    var t = token();\n    if (t && t.type === 'OPERATOR' && operator === t.string) {\n      next();\n      return t.string;\n    }\n  }\n  function parseWith() {\n    if (parseOperator('WITH')) {\n      var t = token();\n      if (t && t.type === 'EXCEPTION') {\n        next();\n        return t.string;\n      }\n      throw new Error('Expected exception after `WITH`');\n    }\n  }\n  function parseLicenseRef() {\n    // TODO: Actually, everything is concatenated into one string\n    // for backward-compatibility but it could be better to return\n    // a nice structure.\n    var begin = index;\n    var string = '';\n    var t = token();\n    if (t.type === 'DOCUMENTREF') {\n      next();\n      string += 'DocumentRef-' + t.string + ':';\n      if (!parseOperator(':')) {\n        throw new Error('Expected `:` after `DocumentRef-...`');\n      }\n    }\n    t = token();\n    if (t.type === 'LICENSEREF') {\n      next();\n      string += 'LicenseRef-' + t.string;\n      return {\n        license: string\n      };\n    }\n    index = begin;\n  }\n  function parseLicense() {\n    var t = token();\n    if (t && t.type === 'LICENSE') {\n      next();\n      var node = {\n        license: t.string\n      };\n      if (parseOperator('+')) {\n        node.plus = true;\n      }\n      var exception = parseWith();\n      if (exception) {\n        node.exception = exception;\n      }\n      return node;\n    }\n  }\n  function parseParenthesizedExpression() {\n    var left = parseOperator('(');\n    if (!left) {\n      return;\n    }\n    var expr = parseExpression();\n    if (!parseOperator(')')) {\n      throw new Error('Expected `)`');\n    }\n    return expr;\n  }\n  function parseAtom() {\n    return parseParenthesizedExpression() || parseLicenseRef() || parseLicense();\n  }\n  function makeBinaryOpParser(operator, nextParser) {\n    return function parseBinaryOp() {\n      var left = nextParser();\n      if (!left) {\n        return;\n      }\n      if (!parseOperator(operator)) {\n        return left;\n      }\n      var right = parseBinaryOp();\n      if (!right) {\n        throw new Error('Expected expression');\n      }\n      return {\n        left: left,\n        conjunction: operator.toLowerCase(),\n        right: right\n      };\n    };\n  }\n  var parseAnd = makeBinaryOpParser('AND', parseAtom);\n  var parseExpression = makeBinaryOpParser('OR', parseAnd);\n  var node = parseExpression();\n  if (!node || hasMore()) {\n    throw new Error('Syntax error');\n  }\n  return node;\n};","map":{"version":3,"names":["module","exports","tokens","index","hasMore","length","token","next","Error","parseOperator","operator","t","type","string","parseWith","parseLicenseRef","begin","license","parseLicense","node","plus","exception","parseParenthesizedExpression","left","expr","parseExpression","parseAtom","makeBinaryOpParser","nextParser","parseBinaryOp","right","conjunction","toLowerCase","parseAnd"],"sources":["/home/user/Рабочий стол/pizza/project/node_modules/spdx-expression-parse/parse.js"],"sourcesContent":["'use strict'\n\n// The ABNF grammar in the spec is totally ambiguous.\n//\n// This parser follows the operator precedence defined in the\n// `Order of Precedence and Parentheses` section.\n\nmodule.exports = function (tokens) {\n  var index = 0\n\n  function hasMore () {\n    return index < tokens.length\n  }\n\n  function token () {\n    return hasMore() ? tokens[index] : null\n  }\n\n  function next () {\n    if (!hasMore()) {\n      throw new Error()\n    }\n    index++\n  }\n\n  function parseOperator (operator) {\n    var t = token()\n    if (t && t.type === 'OPERATOR' && operator === t.string) {\n      next()\n      return t.string\n    }\n  }\n\n  function parseWith () {\n    if (parseOperator('WITH')) {\n      var t = token()\n      if (t && t.type === 'EXCEPTION') {\n        next()\n        return t.string\n      }\n      throw new Error('Expected exception after `WITH`')\n    }\n  }\n\n  function parseLicenseRef () {\n    // TODO: Actually, everything is concatenated into one string\n    // for backward-compatibility but it could be better to return\n    // a nice structure.\n    var begin = index\n    var string = ''\n    var t = token()\n    if (t.type === 'DOCUMENTREF') {\n      next()\n      string += 'DocumentRef-' + t.string + ':'\n      if (!parseOperator(':')) {\n        throw new Error('Expected `:` after `DocumentRef-...`')\n      }\n    }\n    t = token()\n    if (t.type === 'LICENSEREF') {\n      next()\n      string += 'LicenseRef-' + t.string\n      return {license: string}\n    }\n    index = begin\n  }\n\n  function parseLicense () {\n    var t = token()\n    if (t && t.type === 'LICENSE') {\n      next()\n      var node = {license: t.string}\n      if (parseOperator('+')) {\n        node.plus = true\n      }\n      var exception = parseWith()\n      if (exception) {\n        node.exception = exception\n      }\n      return node\n    }\n  }\n\n  function parseParenthesizedExpression () {\n    var left = parseOperator('(')\n    if (!left) {\n      return\n    }\n\n    var expr = parseExpression()\n\n    if (!parseOperator(')')) {\n      throw new Error('Expected `)`')\n    }\n\n    return expr\n  }\n\n  function parseAtom () {\n    return (\n      parseParenthesizedExpression() ||\n      parseLicenseRef() ||\n      parseLicense()\n    )\n  }\n\n  function makeBinaryOpParser (operator, nextParser) {\n    return function parseBinaryOp () {\n      var left = nextParser()\n      if (!left) {\n        return\n      }\n\n      if (!parseOperator(operator)) {\n        return left\n      }\n\n      var right = parseBinaryOp()\n      if (!right) {\n        throw new Error('Expected expression')\n      }\n      return {\n        left: left,\n        conjunction: operator.toLowerCase(),\n        right: right\n      }\n    }\n  }\n\n  var parseAnd = makeBinaryOpParser('AND', parseAtom)\n  var parseExpression = makeBinaryOpParser('OR', parseAnd)\n\n  var node = parseExpression()\n  if (!node || hasMore()) {\n    throw new Error('Syntax error')\n  }\n  return node\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}