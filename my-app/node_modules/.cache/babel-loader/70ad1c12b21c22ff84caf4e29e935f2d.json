{"ast":null,"code":"\"use strict\";\n\nvar utils = require(\"./lib/utils\");\nvar debug = require(\"debug\")(\"resp-mod\");\nfunction RespModifier(opts) {\n  // options\n  opts = opts || {};\n  opts.blacklist = utils.toArray(opts.blacklist) || [];\n  opts.whitelist = utils.toArray(opts.whitelist) || [];\n  opts.hostBlacklist = utils.toArray(opts.hostBlacklist) || [];\n  opts.rules = opts.rules || [];\n  opts.ignore = opts.ignore || opts.excludeList || utils.defaultIgnoreTypes;\n\n  // helper functions\n  opts.regex = function () {\n    var matches = opts.rules.map(function (item) {\n      return item.match.source;\n    }).join(\"|\");\n    return new RegExp(matches);\n  }();\n  var respMod = this;\n  respMod.opts = opts;\n  respMod.middleware = respModifierMiddleware;\n  respMod.update = function (key, value) {\n    if (respMod.opts[key]) {\n      respMod.opts[key] = value;\n    }\n    return respMod;\n  };\n  function respModifierMiddleware(req, res, next) {\n    if (res._respModifier) {\n      debug(\"Reject req\", req.url);\n      return next();\n    }\n    debug(\"Accept req\", req.url);\n    res._respModifier = true;\n    var writeHead = res.writeHead;\n    var runPatches = true;\n    var write = res.write;\n    var end = res.end;\n    var singlerules = utils.isWhiteListedForSingle(req.url, respMod.opts.rules);\n    var withoutSingle = respMod.opts.rules.filter(function (rule) {\n      if (rule.paths && rule.paths.length) {\n        return false;\n      }\n      return true;\n    });\n\n    /**\n     * Exit early for blacklisted domains\n     */\n    if (respMod.opts.hostBlacklist.indexOf(req.headers.host) > -1) {\n      return next();\n    }\n    if (singlerules.length) {\n      modifyResponse(singlerules, true);\n    } else {\n      if (utils.isWhitelisted(req.url, respMod.opts.whitelist)) {\n        modifyResponse(withoutSingle, true);\n      } else {\n        if (!utils.hasAcceptHeaders(req) || utils.inBlackList(req.url, respMod.opts)) {\n          debug(\"Black listed or no text/html headers\", req.url);\n          return next();\n        } else {\n          modifyResponse(withoutSingle);\n        }\n      }\n    }\n    next();\n\n    /**\n     * Actually do the overwrite\n     * @param {Array} rules\n     * @param {Boolean} [force] - if true, will always attempt to perform\n     * an overwrite - regardless of whether it appears to be HTML or not\n     */\n    function modifyResponse(rules, force) {\n      req.headers[\"accept-encoding\"] = \"identity\";\n      function restore() {\n        res.writeHead = writeHead;\n        res.write = write;\n        res.end = end;\n      }\n      res.push = function (chunk) {\n        res.data = (res.data || \"\") + chunk;\n      };\n      res.write = function (string, encoding) {\n        if (!runPatches) {\n          return write.call(res, string, encoding);\n        }\n        if (string !== undefined) {\n          var body = string instanceof Buffer ? string.toString(encoding) : string;\n          // If this chunk appears to be valid, push onto the res.data stack\n          if (force || utils.isHtml(body) || utils.isHtml(res.data)) {\n            res.push(body);\n          } else {\n            restore();\n            return write.call(res, string, encoding);\n          }\n        }\n        return true;\n      };\n      res.writeHead = function () {\n        if (!runPatches) {\n          return writeHead.apply(res, arguments);\n        }\n        var headers = arguments[arguments.length - 1];\n        if (typeof headers === \"object\") {\n          for (var name in headers) {\n            if (/content-length/i.test(name)) {\n              delete headers[name];\n            }\n          }\n        }\n        if (res.getHeader(\"content-length\")) {\n          res.removeHeader(\"content-length\");\n        }\n        writeHead.apply(res, arguments);\n      };\n      res.end = function (string, encoding) {\n        res.data = res.data || \"\";\n        if (typeof string === \"string\") {\n          res.data += string;\n        }\n        if (string instanceof Buffer) {\n          res.data += string.toString();\n        }\n        if (!runPatches) {\n          return end.call(res, string, encoding);\n        }\n\n        // Check if our body is HTML, and if it does not already have the snippet.\n        if (force || utils.isHtml(res.data) && !utils.snip(res.data)) {\n          // Include, if necessary, replacing the entire res.data with the included snippet.\n          res.data = utils.applyRules(rules, res.data, req, res);\n          runPatches = false;\n        }\n        if (res.data !== undefined && !res._header) {\n          res.setHeader(\"content-length\", Buffer.byteLength(res.data, encoding));\n        }\n        end.call(res, res.data, encoding);\n      };\n    }\n  }\n  return respMod;\n}\nmodule.exports = function (opts) {\n  var resp = new RespModifier(opts);\n  return resp.middleware;\n};\nmodule.exports.create = function (opts) {\n  var resp = new RespModifier(opts);\n  return resp;\n};\nmodule.exports.utils = utils;","map":{"version":3,"names":["utils","require","debug","RespModifier","opts","blacklist","toArray","whitelist","hostBlacklist","rules","ignore","excludeList","defaultIgnoreTypes","regex","matches","map","item","match","source","join","RegExp","respMod","middleware","respModifierMiddleware","update","key","value","req","res","next","_respModifier","url","writeHead","runPatches","write","end","singlerules","isWhiteListedForSingle","withoutSingle","filter","rule","paths","length","indexOf","headers","host","modifyResponse","isWhitelisted","hasAcceptHeaders","inBlackList","force","restore","push","chunk","data","string","encoding","call","undefined","body","Buffer","toString","isHtml","apply","arguments","name","test","getHeader","removeHeader","snip","applyRules","_header","setHeader","byteLength","module","exports","resp","create"],"sources":["/home/user/Рабочий стол/pizza/project/node_modules/resp-modifier/index.js"],"sourcesContent":["\"use strict\";\n\nvar utils     = require(\"./lib/utils\");\nvar debug     = require(\"debug\")(\"resp-mod\");\n\nfunction RespModifier (opts) {\n\n    // options\n    opts               = opts || {};\n    opts.blacklist     = utils.toArray(opts.blacklist)     || [];\n    opts.whitelist     = utils.toArray(opts.whitelist)     || [];\n    opts.hostBlacklist = utils.toArray(opts.hostBlacklist) || [];\n    opts.rules         = opts.rules                        || [];\n    opts.ignore        = opts.ignore || opts.excludeList   || utils.defaultIgnoreTypes;\n\n    // helper functions\n    opts.regex = (function () {\n        var matches = opts.rules.map(function (item) {\n            return item.match.source;\n        }).join(\"|\");\n        return new RegExp(matches);\n    })();\n\n    var respMod        = this;\n\n    respMod.opts       = opts;\n    respMod.middleware = respModifierMiddleware;\n    respMod.update = function (key, value) {\n        if (respMod.opts[key]) {\n            respMod.opts[key] = value;\n        }\n        return respMod;\n    };\n\n    function respModifierMiddleware(req, res, next) {\n\n        if (res._respModifier) {\n            debug(\"Reject req\", req.url);\n            return next();\n        }\n        debug(\"Accept req\", req.url);\n\n        res._respModifier = true;\n\n        var writeHead   = res.writeHead;\n        var runPatches  = true;\n        var write       = res.write;\n        var end         = res.end;\n        var singlerules = utils.isWhiteListedForSingle(req.url, respMod.opts.rules);\n\n        var withoutSingle = respMod.opts.rules.filter(function (rule) {\n            if (rule.paths && rule.paths.length) {\n                return false;\n            }\n            return true;\n        });\n\n        /**\n         * Exit early for blacklisted domains\n         */\n        if (respMod.opts.hostBlacklist.indexOf(req.headers.host) > -1) {\n            return next();\n        }\n\n        if (singlerules.length) {\n            modifyResponse(singlerules, true);\n        } else {\n            if (utils.isWhitelisted(req.url, respMod.opts.whitelist)) {\n                modifyResponse(withoutSingle, true);\n            } else {\n                if (!utils.hasAcceptHeaders(req) || utils.inBlackList(req.url, respMod.opts)) {\n                    debug(\"Black listed or no text/html headers\", req.url);\n                    return next();\n                } else {\n                    modifyResponse(withoutSingle);\n                }\n            }\n        }\n\n        next();\n\n        /**\n         * Actually do the overwrite\n         * @param {Array} rules\n         * @param {Boolean} [force] - if true, will always attempt to perform\n         * an overwrite - regardless of whether it appears to be HTML or not\n         */\n        function modifyResponse(rules, force) {\n\n            req.headers[\"accept-encoding\"] = \"identity\";\n\n            function restore() {\n                res.writeHead = writeHead;\n                res.write = write;\n                res.end = end;\n            }\n\n            res.push = function (chunk) {\n                res.data = (res.data || \"\") + chunk;\n            };\n\n            res.write = function (string, encoding) {\n\n                if (!runPatches) {\n                    return write.call(res, string, encoding);\n                }\n\n                if (string !== undefined) {\n                    var body = string instanceof Buffer ? string.toString(encoding) : string;\n                    // If this chunk appears to be valid, push onto the res.data stack\n                    if (force || (utils.isHtml(body) || utils.isHtml(res.data))) {\n                        res.push(body);\n                    } else {\n                        restore();\n                        return write.call(res, string, encoding);\n                    }\n                }\n                return true;\n            };\n\n            res.writeHead = function () {\n                if (!runPatches) {\n                    return writeHead.apply(res, arguments);\n                }\n\n                var headers = arguments[arguments.length - 1];\n\n                if (typeof headers === \"object\") {\n                    for (var name in headers) {\n                        if (/content-length/i.test(name)) {\n                            delete headers[name];\n                        }\n                    }\n                }\n\n                if (res.getHeader(\"content-length\")) {\n                    res.removeHeader(\"content-length\");\n                }\n\n                writeHead.apply(res, arguments);\n            };\n\n            res.end = function (string, encoding) {\n\n                res.data = res.data || \"\";\n\n                if (typeof string === \"string\") {\n                    res.data += string;\n                }\n\n                if (string instanceof Buffer) {\n                    res.data += string.toString();\n                }\n\n                if (!runPatches) {\n                    return end.call(res, string, encoding);\n                }\n\n                // Check if our body is HTML, and if it does not already have the snippet.\n                if (force || utils.isHtml(res.data) && !utils.snip(res.data)) {\n                    // Include, if necessary, replacing the entire res.data with the included snippet.\n                    res.data = utils.applyRules(rules, res.data, req, res);\n                    runPatches = false;\n                }\n                if (res.data !== undefined && !res._header) {\n                    res.setHeader(\"content-length\", Buffer.byteLength(res.data, encoding));\n                }\n                end.call(res, res.data, encoding);\n            };\n        }\n    }\n\n    return respMod;\n}\n\nmodule.exports = function (opts) {\n    var resp = new RespModifier(opts);\n    return resp.middleware;\n};\n\nmodule.exports.create = function (opts) {\n    var resp = new RespModifier(opts);\n    return resp;\n};\n\nmodule.exports.utils = utils;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}