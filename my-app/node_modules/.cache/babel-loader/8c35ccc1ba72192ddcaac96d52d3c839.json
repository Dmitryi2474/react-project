{"ast":null,"code":"/*\n * Author: Alex Kocharin <alex@kocharin.ru>\n * GIT: https://github.com/rlidwka/jju\n * License: WTFPL, grab your copy here: http://www.wtfpl.net/txt/copying/\n */\n\n// RTFM: http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf\n\nvar Uni = require('./unicode');\nfunction isHexDigit(x) {\n  return x >= '0' && x <= '9' || x >= 'A' && x <= 'F' || x >= 'a' && x <= 'f';\n}\nfunction isOctDigit(x) {\n  return x >= '0' && x <= '7';\n}\nfunction isDecDigit(x) {\n  return x >= '0' && x <= '9';\n}\nvar unescapeMap = {\n  '\\'': '\\'',\n  '\"': '\"',\n  '\\\\': '\\\\',\n  'b': '\\b',\n  'f': '\\f',\n  'n': '\\n',\n  'r': '\\r',\n  't': '\\t',\n  'v': '\\v',\n  '/': '/'\n};\nfunction formatError(input, msg, position, lineno, column, json5) {\n  var result = msg + ' at ' + (lineno + 1) + ':' + (column + 1),\n    tmppos = position - column - 1,\n    srcline = '',\n    underline = '';\n  var isLineTerminator = json5 ? Uni.isLineTerminator : Uni.isLineTerminatorJSON;\n\n  // output no more than 70 characters before the wrong ones\n  if (tmppos < position - 70) {\n    tmppos = position - 70;\n  }\n  while (1) {\n    var chr = input[++tmppos];\n    if (isLineTerminator(chr) || tmppos === input.length) {\n      if (position >= tmppos) {\n        // ending line error, so show it after the last char\n        underline += '^';\n      }\n      break;\n    }\n    srcline += chr;\n    if (position === tmppos) {\n      underline += '^';\n    } else if (position > tmppos) {\n      underline += input[tmppos] === '\\t' ? '\\t' : ' ';\n    }\n\n    // output no more than 78 characters on the string\n    if (srcline.length > 78) break;\n  }\n  return result + '\\n' + srcline + '\\n' + underline;\n}\nfunction parse(input, options) {\n  // parse as a standard JSON mode\n  var json5 = !(options.mode === 'json' || options.legacy);\n  var isLineTerminator = json5 ? Uni.isLineTerminator : Uni.isLineTerminatorJSON;\n  var isWhiteSpace = json5 ? Uni.isWhiteSpace : Uni.isWhiteSpaceJSON;\n  var length = input.length,\n    lineno = 0,\n    linestart = 0,\n    position = 0,\n    stack = [];\n  var tokenStart = function () {};\n  var tokenEnd = function (v) {\n    return v;\n  };\n\n  /* tokenize({\n       raw: '...',\n       type: 'whitespace'|'comment'|'key'|'literal'|'separator'|'newline',\n       value: 'number'|'string'|'whatever',\n       path: [...],\n     })\n  */\n  if (options._tokenize) {\n    ;\n    (function () {\n      var start = null;\n      tokenStart = function () {\n        if (start !== null) throw Error('internal error, token overlap');\n        start = position;\n      };\n      tokenEnd = function (v, type) {\n        if (start != position) {\n          var hash = {\n            raw: input.substr(start, position - start),\n            type: type,\n            stack: stack.slice(0)\n          };\n          if (v !== undefined) hash.value = v;\n          options._tokenize.call(null, hash);\n        }\n        start = null;\n        return v;\n      };\n    })();\n  }\n  function fail(msg) {\n    var column = position - linestart;\n    if (!msg) {\n      if (position < length) {\n        var token = '\\'' + JSON.stringify(input[position]).replace(/^\"|\"$/g, '').replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"') + '\\'';\n        if (!msg) msg = 'Unexpected token ' + token;\n      } else {\n        if (!msg) msg = 'Unexpected end of input';\n      }\n    }\n    var error = SyntaxError(formatError(input, msg, position, lineno, column, json5));\n    error.row = lineno + 1;\n    error.column = column + 1;\n    throw error;\n  }\n  function newline(chr) {\n    // account for <cr><lf>\n    if (chr === '\\r' && input[position] === '\\n') position++;\n    linestart = position;\n    lineno++;\n  }\n  function parseGeneric() {\n    var result;\n    while (position < length) {\n      tokenStart();\n      var chr = input[position++];\n      if (chr === '\"' || chr === '\\'' && json5) {\n        return tokenEnd(parseString(chr), 'literal');\n      } else if (chr === '{') {\n        tokenEnd(undefined, 'separator');\n        return parseObject();\n      } else if (chr === '[') {\n        tokenEnd(undefined, 'separator');\n        return parseArray();\n      } else if (chr === '-' || chr === '.' || isDecDigit(chr)\n      //           + number       Infinity          NaN\n      || json5 && (chr === '+' || chr === 'I' || chr === 'N')) {\n        return tokenEnd(parseNumber(), 'literal');\n      } else if (chr === 'n') {\n        parseKeyword('null');\n        return tokenEnd(null, 'literal');\n      } else if (chr === 't') {\n        parseKeyword('true');\n        return tokenEnd(true, 'literal');\n      } else if (chr === 'f') {\n        parseKeyword('false');\n        return tokenEnd(false, 'literal');\n      } else {\n        position--;\n        return tokenEnd(undefined);\n      }\n    }\n  }\n  function parseKey() {\n    var result;\n    while (position < length) {\n      tokenStart();\n      var chr = input[position++];\n      if (chr === '\"' || chr === '\\'' && json5) {\n        return tokenEnd(parseString(chr), 'key');\n      } else if (chr === '{') {\n        tokenEnd(undefined, 'separator');\n        return parseObject();\n      } else if (chr === '[') {\n        tokenEnd(undefined, 'separator');\n        return parseArray();\n      } else if (chr === '.' || isDecDigit(chr)) {\n        return tokenEnd(parseNumber(true), 'key');\n      } else if (json5 && Uni.isIdentifierStart(chr) || chr === '\\\\' && input[position] === 'u') {\n        // unicode char or a unicode sequence\n        var rollback = position - 1;\n        var result = parseIdentifier();\n        if (result === undefined) {\n          position = rollback;\n          return tokenEnd(undefined);\n        } else {\n          return tokenEnd(result, 'key');\n        }\n      } else {\n        position--;\n        return tokenEnd(undefined);\n      }\n    }\n  }\n  function skipWhiteSpace() {\n    tokenStart();\n    while (position < length) {\n      var chr = input[position++];\n      if (isLineTerminator(chr)) {\n        position--;\n        tokenEnd(undefined, 'whitespace');\n        tokenStart();\n        position++;\n        newline(chr);\n        tokenEnd(undefined, 'newline');\n        tokenStart();\n      } else if (isWhiteSpace(chr)) {\n        // nothing\n      } else if (chr === '/' && json5 && (input[position] === '/' || input[position] === '*')) {\n        position--;\n        tokenEnd(undefined, 'whitespace');\n        tokenStart();\n        position++;\n        skipComment(input[position++] === '*');\n        tokenEnd(undefined, 'comment');\n        tokenStart();\n      } else {\n        position--;\n        break;\n      }\n    }\n    return tokenEnd(undefined, 'whitespace');\n  }\n  function skipComment(multi) {\n    while (position < length) {\n      var chr = input[position++];\n      if (isLineTerminator(chr)) {\n        // LineTerminator is an end of singleline comment\n        if (!multi) {\n          // let parent function deal with newline\n          position--;\n          return;\n        }\n        newline(chr);\n      } else if (chr === '*' && multi) {\n        // end of multiline comment\n        if (input[position] === '/') {\n          position++;\n          return;\n        }\n      } else {\n        // nothing\n      }\n    }\n    if (multi) {\n      fail('Unclosed multiline comment');\n    }\n  }\n  function parseKeyword(keyword) {\n    // keyword[0] is not checked because it should've checked earlier\n    var _pos = position;\n    var len = keyword.length;\n    for (var i = 1; i < len; i++) {\n      if (position >= length || keyword[i] != input[position]) {\n        position = _pos - 1;\n        fail();\n      }\n      position++;\n    }\n  }\n  function parseObject() {\n    var result = options.null_prototype ? Object.create(null) : {},\n      empty_object = {},\n      is_non_empty = false;\n    while (position < length) {\n      skipWhiteSpace();\n      var item1 = parseKey();\n      skipWhiteSpace();\n      tokenStart();\n      var chr = input[position++];\n      tokenEnd(undefined, 'separator');\n      if (chr === '}' && item1 === undefined) {\n        if (!json5 && is_non_empty) {\n          position--;\n          fail('Trailing comma in object');\n        }\n        return result;\n      } else if (chr === ':' && item1 !== undefined) {\n        skipWhiteSpace();\n        stack.push(item1);\n        var item2 = parseGeneric();\n        stack.pop();\n        if (item2 === undefined) fail('No value found for key ' + item1);\n        if (typeof item1 !== 'string') {\n          if (!json5 || typeof item1 !== 'number') {\n            fail('Wrong key type: ' + item1);\n          }\n        }\n        if ((item1 in empty_object || empty_object[item1] != null) && options.reserved_keys !== 'replace') {\n          if (options.reserved_keys === 'throw') {\n            fail('Reserved key: ' + item1);\n          } else {\n            // silently ignore it\n          }\n        } else {\n          if (typeof options.reviver === 'function') {\n            item2 = options.reviver.call(null, item1, item2);\n          }\n          if (item2 !== undefined) {\n            is_non_empty = true;\n            Object.defineProperty(result, item1, {\n              value: item2,\n              enumerable: true,\n              configurable: true,\n              writable: true\n            });\n          }\n        }\n        skipWhiteSpace();\n        tokenStart();\n        var chr = input[position++];\n        tokenEnd(undefined, 'separator');\n        if (chr === ',') {\n          continue;\n        } else if (chr === '}') {\n          return result;\n        } else {\n          fail();\n        }\n      } else {\n        position--;\n        fail();\n      }\n    }\n    fail();\n  }\n  function parseArray() {\n    var result = [];\n    while (position < length) {\n      skipWhiteSpace();\n      stack.push(result.length);\n      var item = parseGeneric();\n      stack.pop();\n      skipWhiteSpace();\n      tokenStart();\n      var chr = input[position++];\n      tokenEnd(undefined, 'separator');\n      if (item !== undefined) {\n        if (typeof options.reviver === 'function') {\n          item = options.reviver.call(null, String(result.length), item);\n        }\n        if (item === undefined) {\n          result.length++;\n          item = true; // hack for check below, not included into result\n        } else {\n          result.push(item);\n        }\n      }\n      if (chr === ',') {\n        if (item === undefined) {\n          fail('Elisions are not supported');\n        }\n      } else if (chr === ']') {\n        if (!json5 && item === undefined && result.length) {\n          position--;\n          fail('Trailing comma in array');\n        }\n        return result;\n      } else {\n        position--;\n        fail();\n      }\n    }\n  }\n  function parseNumber() {\n    // rewind because we don't know first char\n    position--;\n    var start = position,\n      chr = input[position++],\n      t;\n    var to_num = function (is_octal) {\n      var str = input.substr(start, position - start);\n      if (is_octal) {\n        var result = parseInt(str.replace(/^0o?/, ''), 8);\n      } else {\n        var result = Number(str);\n      }\n      if (Number.isNaN(result)) {\n        position--;\n        fail('Bad numeric literal - \"' + input.substr(start, position - start + 1) + '\"');\n      } else if (!json5 && !str.match(/^-?(0|[1-9][0-9]*)(\\.[0-9]+)?(e[+-]?[0-9]+)?$/i)) {\n        // additional restrictions imposed by json\n        position--;\n        fail('Non-json numeric literal - \"' + input.substr(start, position - start + 1) + '\"');\n      } else {\n        return result;\n      }\n    };\n\n    // ex: -5982475.249875e+29384\n    //     ^ skipping this\n    if (chr === '-' || chr === '+' && json5) chr = input[position++];\n    if (chr === 'N' && json5) {\n      parseKeyword('NaN');\n      return NaN;\n    }\n    if (chr === 'I' && json5) {\n      parseKeyword('Infinity');\n\n      // returning +inf or -inf\n      return to_num();\n    }\n    if (chr >= '1' && chr <= '9') {\n      // ex: -5982475.249875e+29384\n      //        ^^^ skipping these\n      while (position < length && isDecDigit(input[position])) position++;\n      chr = input[position++];\n    }\n\n    // special case for leading zero: 0.123456\n    if (chr === '0') {\n      chr = input[position++];\n\n      //             new syntax, \"0o777\"           old syntax, \"0777\"\n      var is_octal = chr === 'o' || chr === 'O' || isOctDigit(chr);\n      var is_hex = chr === 'x' || chr === 'X';\n      if (json5 && (is_octal || is_hex)) {\n        while (position < length && (is_hex ? isHexDigit : isOctDigit)(input[position])) position++;\n        var sign = 1;\n        if (input[start] === '-') {\n          sign = -1;\n          start++;\n        } else if (input[start] === '+') {\n          start++;\n        }\n        return sign * to_num(is_octal);\n      }\n    }\n    if (chr === '.') {\n      // ex: -5982475.249875e+29384\n      //                ^^^ skipping these\n      while (position < length && isDecDigit(input[position])) position++;\n      chr = input[position++];\n    }\n    if (chr === 'e' || chr === 'E') {\n      chr = input[position++];\n      if (chr === '-' || chr === '+') position++;\n      // ex: -5982475.249875e+29384\n      //                       ^^^ skipping these\n      while (position < length && isDecDigit(input[position])) position++;\n      chr = input[position++];\n    }\n\n    // we have char in the buffer, so count for it\n    position--;\n    return to_num();\n  }\n  function parseIdentifier() {\n    // rewind because we don't know first char\n    position--;\n    var result = '';\n    while (position < length) {\n      var chr = input[position++];\n      if (chr === '\\\\' && input[position] === 'u' && isHexDigit(input[position + 1]) && isHexDigit(input[position + 2]) && isHexDigit(input[position + 3]) && isHexDigit(input[position + 4])) {\n        // UnicodeEscapeSequence\n        chr = String.fromCharCode(parseInt(input.substr(position + 1, 4), 16));\n        position += 5;\n      }\n      if (result.length) {\n        // identifier started\n        if (Uni.isIdentifierPart(chr)) {\n          result += chr;\n        } else {\n          position--;\n          return result;\n        }\n      } else {\n        if (Uni.isIdentifierStart(chr)) {\n          result += chr;\n        } else {\n          return undefined;\n        }\n      }\n    }\n    fail();\n  }\n  function parseString(endChar) {\n    // 7.8.4 of ES262 spec\n    var result = '';\n    while (position < length) {\n      var chr = input[position++];\n      if (chr === endChar) {\n        return result;\n      } else if (chr === '\\\\') {\n        if (position >= length) fail();\n        chr = input[position++];\n        if (unescapeMap[chr] && (json5 || chr != 'v' && chr != \"'\")) {\n          result += unescapeMap[chr];\n        } else if (json5 && isLineTerminator(chr)) {\n          // line continuation\n          newline(chr);\n        } else if (chr === 'u' || chr === 'x' && json5) {\n          // unicode/character escape sequence\n          var off = chr === 'u' ? 4 : 2;\n\n          // validation for \\uXXXX\n          for (var i = 0; i < off; i++) {\n            if (position >= length) fail();\n            if (!isHexDigit(input[position])) fail('Bad escape sequence');\n            position++;\n          }\n          result += String.fromCharCode(parseInt(input.substr(position - off, off), 16));\n        } else if (json5 && isOctDigit(chr)) {\n          if (chr < '4' && isOctDigit(input[position]) && isOctDigit(input[position + 1])) {\n            // three-digit octal\n            var digits = 3;\n          } else if (isOctDigit(input[position])) {\n            // two-digit octal\n            var digits = 2;\n          } else {\n            var digits = 1;\n          }\n          position += digits - 1;\n          result += String.fromCharCode(parseInt(input.substr(position - digits, digits), 8));\n          /*if (!isOctDigit(input[position])) {\n            // \\0 is allowed still\n            result += '\\0'\n          } else {\n            fail('Octal literals are not supported')\n          }*/\n        } else if (json5) {\n          // \\X -> x\n          result += chr;\n        } else {\n          position--;\n          fail();\n        }\n      } else if (isLineTerminator(chr)) {\n        fail();\n      } else {\n        if (!json5 && chr.charCodeAt(0) < 32) {\n          position--;\n          fail('Unexpected control character');\n        }\n\n        // SourceCharacter but not one of \" or \\ or LineTerminator\n        result += chr;\n      }\n    }\n    fail();\n  }\n  skipWhiteSpace();\n  var return_value = parseGeneric();\n  if (return_value !== undefined || position < length) {\n    skipWhiteSpace();\n    if (position >= length) {\n      if (typeof options.reviver === 'function') {\n        return_value = options.reviver.call(null, '', return_value);\n      }\n      return return_value;\n    } else {\n      fail();\n    }\n  } else {\n    if (position) {\n      fail('No data, only a whitespace');\n    } else {\n      fail('No data, empty input');\n    }\n  }\n}\n\n/*\n * parse(text, options)\n * or\n * parse(text, reviver)\n *\n * where:\n * text - string\n * options - object\n * reviver - function\n */\nmodule.exports.parse = function parseJSON(input, options) {\n  // support legacy functions\n  if (typeof options === 'function') {\n    options = {\n      reviver: options\n    };\n  }\n  if (input === undefined) {\n    // parse(stringify(x)) should be equal x\n    // with JSON functions it is not 'cause of undefined\n    // so we're fixing it\n    return undefined;\n  }\n\n  // JSON.parse compat\n  if (typeof input !== 'string') input = String(input);\n  if (options == null) options = {};\n  if (options.reserved_keys == null) options.reserved_keys = 'ignore';\n  if (options.reserved_keys === 'throw' || options.reserved_keys === 'ignore') {\n    if (options.null_prototype == null) {\n      options.null_prototype = true;\n    }\n  }\n  try {\n    return parse(input, options);\n  } catch (err) {\n    // jju is a recursive parser, so JSON.parse(\"{{{{{{{\") could blow up the stack\n    //\n    // this catch is used to skip all those internal calls\n    if (err instanceof SyntaxError && err.row != null && err.column != null) {\n      var old_err = err;\n      err = SyntaxError(old_err.message);\n      err.column = old_err.column;\n      err.row = old_err.row;\n    }\n    throw err;\n  }\n};\nmodule.exports.tokenize = function tokenizeJSON(input, options) {\n  if (options == null) options = {};\n  options._tokenize = function (smth) {\n    if (options._addstack) smth.stack.unshift.apply(smth.stack, options._addstack);\n    tokens.push(smth);\n  };\n  var tokens = [];\n  tokens.data = module.exports.parse(input, options);\n  return tokens;\n};","map":{"version":3,"names":["Uni","require","isHexDigit","x","isOctDigit","isDecDigit","unescapeMap","formatError","input","msg","position","lineno","column","json5","result","tmppos","srcline","underline","isLineTerminator","isLineTerminatorJSON","chr","length","parse","options","mode","legacy","isWhiteSpace","isWhiteSpaceJSON","linestart","stack","tokenStart","tokenEnd","v","_tokenize","start","Error","type","hash","raw","substr","slice","undefined","value","call","fail","token","JSON","stringify","replace","error","SyntaxError","row","newline","parseGeneric","parseString","parseObject","parseArray","parseNumber","parseKeyword","parseKey","isIdentifierStart","rollback","parseIdentifier","skipWhiteSpace","skipComment","multi","keyword","_pos","len","i","null_prototype","Object","create","empty_object","is_non_empty","item1","push","item2","pop","reserved_keys","reviver","defineProperty","enumerable","configurable","writable","item","String","t","to_num","is_octal","str","parseInt","Number","isNaN","match","NaN","is_hex","sign","fromCharCode","isIdentifierPart","endChar","off","digits","charCodeAt","return_value","module","exports","parseJSON","err","old_err","message","tokenize","tokenizeJSON","smth","_addstack","unshift","apply","tokens","data"],"sources":["/home/user/Рабочий стол/pizza/project/node_modules/parse-json/vendor/parse.js"],"sourcesContent":["/*\n * Author: Alex Kocharin <alex@kocharin.ru>\n * GIT: https://github.com/rlidwka/jju\n * License: WTFPL, grab your copy here: http://www.wtfpl.net/txt/copying/\n */\n\n// RTFM: http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf\n\nvar Uni = require('./unicode')\n\nfunction isHexDigit(x) {\n  return (x >= '0' && x <= '9')\n      || (x >= 'A' && x <= 'F')\n      || (x >= 'a' && x <= 'f')\n}\n\nfunction isOctDigit(x) {\n  return x >= '0' && x <= '7'\n}\n\nfunction isDecDigit(x) {\n  return x >= '0' && x <= '9'\n}\n\nvar unescapeMap = {\n  '\\'': '\\'',\n  '\"' : '\"',\n  '\\\\': '\\\\',\n  'b' : '\\b',\n  'f' : '\\f',\n  'n' : '\\n',\n  'r' : '\\r',\n  't' : '\\t',\n  'v' : '\\v',\n  '/' : '/',\n}\n\nfunction formatError(input, msg, position, lineno, column, json5) {\n  var result = msg + ' at ' + (lineno + 1) + ':' + (column + 1)\n    , tmppos = position - column - 1\n    , srcline = ''\n    , underline = ''\n\n  var isLineTerminator = json5 ? Uni.isLineTerminator : Uni.isLineTerminatorJSON\n\n  // output no more than 70 characters before the wrong ones\n  if (tmppos < position - 70) {\n    tmppos = position - 70\n  }\n\n  while (1) {\n    var chr = input[++tmppos]\n\n    if (isLineTerminator(chr) || tmppos === input.length) {\n      if (position >= tmppos) {\n        // ending line error, so show it after the last char\n        underline += '^'\n      }\n      break\n    }\n    srcline += chr\n\n    if (position === tmppos) {\n      underline += '^'\n    } else if (position > tmppos) {\n      underline += input[tmppos] === '\\t' ? '\\t' : ' '\n    }\n\n    // output no more than 78 characters on the string\n    if (srcline.length > 78) break\n  }\n\n  return result + '\\n' + srcline + '\\n' + underline\n}\n\nfunction parse(input, options) {\n  // parse as a standard JSON mode\n  var json5 = !(options.mode === 'json' || options.legacy)\n  var isLineTerminator = json5 ? Uni.isLineTerminator : Uni.isLineTerminatorJSON\n  var isWhiteSpace = json5 ? Uni.isWhiteSpace : Uni.isWhiteSpaceJSON\n\n  var length = input.length\n    , lineno = 0\n    , linestart = 0\n    , position = 0\n    , stack = []\n\n  var tokenStart = function() {}\n  var tokenEnd = function(v) {return v}\n\n  /* tokenize({\n       raw: '...',\n       type: 'whitespace'|'comment'|'key'|'literal'|'separator'|'newline',\n       value: 'number'|'string'|'whatever',\n       path: [...],\n     })\n  */\n  if (options._tokenize) {\n    ;(function() {\n      var start = null\n      tokenStart = function() {\n        if (start !== null) throw Error('internal error, token overlap')\n        start = position\n      }\n\n      tokenEnd = function(v, type) {\n        if (start != position) {\n          var hash = {\n            raw: input.substr(start, position-start),\n            type: type,\n            stack: stack.slice(0),\n          }\n          if (v !== undefined) hash.value = v\n          options._tokenize.call(null, hash)\n        }\n        start = null\n        return v\n      }\n    })()\n  }\n\n  function fail(msg) {\n    var column = position - linestart\n\n    if (!msg) {\n      if (position < length) {\n        var token = '\\'' +\n          JSON\n            .stringify(input[position])\n            .replace(/^\"|\"$/g, '')\n            .replace(/'/g, \"\\\\'\")\n            .replace(/\\\\\"/g, '\"')\n          + '\\''\n\n        if (!msg) msg = 'Unexpected token ' + token\n      } else {\n        if (!msg) msg = 'Unexpected end of input'\n      }\n    }\n\n    var error = SyntaxError(formatError(input, msg, position, lineno, column, json5))\n    error.row = lineno + 1\n    error.column = column + 1\n    throw error\n  }\n\n  function newline(chr) {\n    // account for <cr><lf>\n    if (chr === '\\r' && input[position] === '\\n') position++\n    linestart = position\n    lineno++\n  }\n\n  function parseGeneric() {\n    var result\n\n    while (position < length) {\n      tokenStart()\n      var chr = input[position++]\n\n      if (chr === '\"' || (chr === '\\'' && json5)) {\n        return tokenEnd(parseString(chr), 'literal')\n\n      } else if (chr === '{') {\n        tokenEnd(undefined, 'separator')\n        return parseObject()\n\n      } else if (chr === '[') {\n        tokenEnd(undefined, 'separator')\n        return parseArray()\n\n      } else if (chr === '-'\n             ||  chr === '.'\n             ||  isDecDigit(chr)\n                 //           + number       Infinity          NaN\n             ||  (json5 && (chr === '+' || chr === 'I' || chr === 'N'))\n      ) {\n        return tokenEnd(parseNumber(), 'literal')\n\n      } else if (chr === 'n') {\n        parseKeyword('null')\n        return tokenEnd(null, 'literal')\n\n      } else if (chr === 't') {\n        parseKeyword('true')\n        return tokenEnd(true, 'literal')\n\n      } else if (chr === 'f') {\n        parseKeyword('false')\n        return tokenEnd(false, 'literal')\n\n      } else {\n        position--\n        return tokenEnd(undefined)\n      }\n    }\n  }\n\n  function parseKey() {\n    var result\n\n    while (position < length) {\n      tokenStart()\n      var chr = input[position++]\n\n      if (chr === '\"' || (chr === '\\'' && json5)) {\n        return tokenEnd(parseString(chr), 'key')\n\n      } else if (chr === '{') {\n        tokenEnd(undefined, 'separator')\n        return parseObject()\n\n      } else if (chr === '[') {\n        tokenEnd(undefined, 'separator')\n        return parseArray()\n\n      } else if (chr === '.'\n             ||  isDecDigit(chr)\n      ) {\n        return tokenEnd(parseNumber(true), 'key')\n\n      } else if (json5\n             &&  Uni.isIdentifierStart(chr) || (chr === '\\\\' && input[position] === 'u')) {\n        // unicode char or a unicode sequence\n        var rollback = position - 1\n        var result = parseIdentifier()\n\n        if (result === undefined) {\n          position = rollback\n          return tokenEnd(undefined)\n        } else {\n          return tokenEnd(result, 'key')\n        }\n\n      } else {\n        position--\n        return tokenEnd(undefined)\n      }\n    }\n  }\n\n  function skipWhiteSpace() {\n    tokenStart()\n    while (position < length) {\n      var chr = input[position++]\n\n      if (isLineTerminator(chr)) {\n        position--\n        tokenEnd(undefined, 'whitespace')\n        tokenStart()\n        position++\n        newline(chr)\n        tokenEnd(undefined, 'newline')\n        tokenStart()\n\n      } else if (isWhiteSpace(chr)) {\n        // nothing\n\n      } else if (chr === '/'\n             && json5\n             && (input[position] === '/' || input[position] === '*')\n      ) {\n        position--\n        tokenEnd(undefined, 'whitespace')\n        tokenStart()\n        position++\n        skipComment(input[position++] === '*')\n        tokenEnd(undefined, 'comment')\n        tokenStart()\n\n      } else {\n        position--\n        break\n      }\n    }\n    return tokenEnd(undefined, 'whitespace')\n  }\n\n  function skipComment(multi) {\n    while (position < length) {\n      var chr = input[position++]\n\n      if (isLineTerminator(chr)) {\n        // LineTerminator is an end of singleline comment\n        if (!multi) {\n          // let parent function deal with newline\n          position--\n          return\n        }\n\n        newline(chr)\n\n      } else if (chr === '*' && multi) {\n        // end of multiline comment\n        if (input[position] === '/') {\n          position++\n          return\n        }\n\n      } else {\n        // nothing\n      }\n    }\n\n    if (multi) {\n      fail('Unclosed multiline comment')\n    }\n  }\n\n  function parseKeyword(keyword) {\n    // keyword[0] is not checked because it should've checked earlier\n    var _pos = position\n    var len = keyword.length\n    for (var i=1; i<len; i++) {\n      if (position >= length || keyword[i] != input[position]) {\n        position = _pos-1\n        fail()\n      }\n      position++\n    }\n  }\n\n  function parseObject() {\n    var result = options.null_prototype ? Object.create(null) : {}\n      , empty_object = {}\n      , is_non_empty = false\n\n    while (position < length) {\n      skipWhiteSpace()\n      var item1 = parseKey()\n      skipWhiteSpace()\n      tokenStart()\n      var chr = input[position++]\n      tokenEnd(undefined, 'separator')\n\n      if (chr === '}' && item1 === undefined) {\n        if (!json5 && is_non_empty) {\n          position--\n          fail('Trailing comma in object')\n        }\n        return result\n\n      } else if (chr === ':' && item1 !== undefined) {\n        skipWhiteSpace()\n        stack.push(item1)\n        var item2 = parseGeneric()\n        stack.pop()\n\n        if (item2 === undefined) fail('No value found for key ' + item1)\n        if (typeof(item1) !== 'string') {\n          if (!json5 || typeof(item1) !== 'number') {\n            fail('Wrong key type: ' + item1)\n          }\n        }\n\n        if ((item1 in empty_object || empty_object[item1] != null) && options.reserved_keys !== 'replace') {\n          if (options.reserved_keys === 'throw') {\n            fail('Reserved key: ' + item1)\n          } else {\n            // silently ignore it\n          }\n        } else {\n          if (typeof(options.reviver) === 'function') {\n            item2 = options.reviver.call(null, item1, item2)\n          }\n\n          if (item2 !== undefined) {\n            is_non_empty = true\n            Object.defineProperty(result, item1, {\n              value: item2,\n              enumerable: true,\n              configurable: true,\n              writable: true,\n            })\n          }\n        }\n\n        skipWhiteSpace()\n\n        tokenStart()\n        var chr = input[position++]\n        tokenEnd(undefined, 'separator')\n\n        if (chr === ',') {\n          continue\n\n        } else if (chr === '}') {\n          return result\n\n        } else {\n          fail()\n        }\n\n      } else {\n        position--\n        fail()\n      }\n    }\n\n    fail()\n  }\n\n  function parseArray() {\n    var result = []\n\n    while (position < length) {\n      skipWhiteSpace()\n      stack.push(result.length)\n      var item = parseGeneric()\n      stack.pop()\n      skipWhiteSpace()\n      tokenStart()\n      var chr = input[position++]\n      tokenEnd(undefined, 'separator')\n\n      if (item !== undefined) {\n        if (typeof(options.reviver) === 'function') {\n          item = options.reviver.call(null, String(result.length), item)\n        }\n        if (item === undefined) {\n          result.length++\n          item = true // hack for check below, not included into result\n        } else {\n          result.push(item)\n        }\n      }\n\n      if (chr === ',') {\n        if (item === undefined) {\n          fail('Elisions are not supported')\n        }\n\n      } else if (chr === ']') {\n        if (!json5 && item === undefined && result.length) {\n          position--\n          fail('Trailing comma in array')\n        }\n        return result\n\n      } else {\n        position--\n        fail()\n      }\n    }\n  }\n\n  function parseNumber() {\n    // rewind because we don't know first char\n    position--\n\n    var start = position\n      , chr = input[position++]\n      , t\n\n    var to_num = function(is_octal) {\n      var str = input.substr(start, position - start)\n\n      if (is_octal) {\n        var result = parseInt(str.replace(/^0o?/, ''), 8)\n      } else {\n        var result = Number(str)\n      }\n\n      if (Number.isNaN(result)) {\n        position--\n        fail('Bad numeric literal - \"' + input.substr(start, position - start + 1) + '\"')\n      } else if (!json5 && !str.match(/^-?(0|[1-9][0-9]*)(\\.[0-9]+)?(e[+-]?[0-9]+)?$/i)) {\n        // additional restrictions imposed by json\n        position--\n        fail('Non-json numeric literal - \"' + input.substr(start, position - start + 1) + '\"')\n      } else {\n        return result\n      }\n    }\n\n    // ex: -5982475.249875e+29384\n    //     ^ skipping this\n    if (chr === '-' || (chr === '+' && json5)) chr = input[position++]\n\n    if (chr === 'N' && json5) {\n      parseKeyword('NaN')\n      return NaN\n    }\n\n    if (chr === 'I' && json5) {\n      parseKeyword('Infinity')\n\n      // returning +inf or -inf\n      return to_num()\n    }\n\n    if (chr >= '1' && chr <= '9') {\n      // ex: -5982475.249875e+29384\n      //        ^^^ skipping these\n      while (position < length && isDecDigit(input[position])) position++\n      chr = input[position++]\n    }\n\n    // special case for leading zero: 0.123456\n    if (chr === '0') {\n      chr = input[position++]\n\n      //             new syntax, \"0o777\"           old syntax, \"0777\"\n      var is_octal = chr === 'o' || chr === 'O' || isOctDigit(chr)\n      var is_hex = chr === 'x' || chr === 'X'\n\n      if (json5 && (is_octal || is_hex)) {\n        while (position < length\n           &&  (is_hex ? isHexDigit : isOctDigit)( input[position] )\n        ) position++\n\n        var sign = 1\n        if (input[start] === '-') {\n          sign = -1\n          start++\n        } else if (input[start] === '+') {\n          start++\n        }\n\n        return sign * to_num(is_octal)\n      }\n    }\n\n    if (chr === '.') {\n      // ex: -5982475.249875e+29384\n      //                ^^^ skipping these\n      while (position < length && isDecDigit(input[position])) position++\n      chr = input[position++]\n    }\n\n    if (chr === 'e' || chr === 'E') {\n      chr = input[position++]\n      if (chr === '-' || chr === '+') position++\n      // ex: -5982475.249875e+29384\n      //                       ^^^ skipping these\n      while (position < length && isDecDigit(input[position])) position++\n      chr = input[position++]\n    }\n\n    // we have char in the buffer, so count for it\n    position--\n    return to_num()\n  }\n\n  function parseIdentifier() {\n    // rewind because we don't know first char\n    position--\n\n    var result = ''\n\n    while (position < length) {\n      var chr = input[position++]\n\n      if (chr === '\\\\'\n      &&  input[position] === 'u'\n      &&  isHexDigit(input[position+1])\n      &&  isHexDigit(input[position+2])\n      &&  isHexDigit(input[position+3])\n      &&  isHexDigit(input[position+4])\n      ) {\n        // UnicodeEscapeSequence\n        chr = String.fromCharCode(parseInt(input.substr(position+1, 4), 16))\n        position += 5\n      }\n\n      if (result.length) {\n        // identifier started\n        if (Uni.isIdentifierPart(chr)) {\n          result += chr\n        } else {\n          position--\n          return result\n        }\n\n      } else {\n        if (Uni.isIdentifierStart(chr)) {\n          result += chr\n        } else {\n          return undefined\n        }\n      }\n    }\n\n    fail()\n  }\n\n  function parseString(endChar) {\n    // 7.8.4 of ES262 spec\n    var result = ''\n\n    while (position < length) {\n      var chr = input[position++]\n\n      if (chr === endChar) {\n        return result\n\n      } else if (chr === '\\\\') {\n        if (position >= length) fail()\n        chr = input[position++]\n\n        if (unescapeMap[chr] && (json5 || (chr != 'v' && chr != \"'\"))) {\n          result += unescapeMap[chr]\n\n        } else if (json5 && isLineTerminator(chr)) {\n          // line continuation\n          newline(chr)\n\n        } else if (chr === 'u' || (chr === 'x' && json5)) {\n          // unicode/character escape sequence\n          var off = chr === 'u' ? 4 : 2\n\n          // validation for \\uXXXX\n          for (var i=0; i<off; i++) {\n            if (position >= length) fail()\n            if (!isHexDigit(input[position])) fail('Bad escape sequence')\n            position++\n          }\n\n          result += String.fromCharCode(parseInt(input.substr(position-off, off), 16))\n        } else if (json5 && isOctDigit(chr)) {\n          if (chr < '4' && isOctDigit(input[position]) && isOctDigit(input[position+1])) {\n            // three-digit octal\n            var digits = 3\n          } else if (isOctDigit(input[position])) {\n            // two-digit octal\n            var digits = 2\n          } else {\n            var digits = 1\n          }\n          position += digits - 1\n          result += String.fromCharCode(parseInt(input.substr(position-digits, digits), 8))\n          /*if (!isOctDigit(input[position])) {\n            // \\0 is allowed still\n            result += '\\0'\n          } else {\n            fail('Octal literals are not supported')\n          }*/\n\n        } else if (json5) {\n          // \\X -> x\n          result += chr\n\n        } else {\n          position--\n          fail()\n        }\n\n      } else if (isLineTerminator(chr)) {\n        fail()\n\n      } else {\n        if (!json5 && chr.charCodeAt(0) < 32) {\n          position--\n          fail('Unexpected control character')\n        }\n\n        // SourceCharacter but not one of \" or \\ or LineTerminator\n        result += chr\n      }\n    }\n\n    fail()\n  }\n\n  skipWhiteSpace()\n  var return_value = parseGeneric()\n  if (return_value !== undefined || position < length) {\n    skipWhiteSpace()\n\n    if (position >= length) {\n      if (typeof(options.reviver) === 'function') {\n        return_value = options.reviver.call(null, '', return_value)\n      }\n      return return_value\n    } else {\n      fail()\n    }\n\n  } else {\n    if (position) {\n      fail('No data, only a whitespace')\n    } else {\n      fail('No data, empty input')\n    }\n  }\n}\n\n/*\n * parse(text, options)\n * or\n * parse(text, reviver)\n *\n * where:\n * text - string\n * options - object\n * reviver - function\n */\nmodule.exports.parse = function parseJSON(input, options) {\n  // support legacy functions\n  if (typeof(options) === 'function') {\n    options = {\n      reviver: options\n    }\n  }\n\n  if (input === undefined) {\n    // parse(stringify(x)) should be equal x\n    // with JSON functions it is not 'cause of undefined\n    // so we're fixing it\n    return undefined\n  }\n\n  // JSON.parse compat\n  if (typeof(input) !== 'string') input = String(input)\n  if (options == null) options = {}\n  if (options.reserved_keys == null) options.reserved_keys = 'ignore'\n\n  if (options.reserved_keys === 'throw' || options.reserved_keys === 'ignore') {\n    if (options.null_prototype == null) {\n      options.null_prototype = true\n    }\n  }\n\n  try {\n    return parse(input, options)\n  } catch(err) {\n    // jju is a recursive parser, so JSON.parse(\"{{{{{{{\") could blow up the stack\n    //\n    // this catch is used to skip all those internal calls\n    if (err instanceof SyntaxError && err.row != null && err.column != null) {\n      var old_err = err\n      err = SyntaxError(old_err.message)\n      err.column = old_err.column\n      err.row = old_err.row\n    }\n    throw err\n  }\n}\n\nmodule.exports.tokenize = function tokenizeJSON(input, options) {\n  if (options == null) options = {}\n\n  options._tokenize = function(smth) {\n    if (options._addstack) smth.stack.unshift.apply(smth.stack, options._addstack)\n    tokens.push(smth)\n  }\n\n  var tokens = []\n  tokens.data = module.exports.parse(input, options)\n  return tokens\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}