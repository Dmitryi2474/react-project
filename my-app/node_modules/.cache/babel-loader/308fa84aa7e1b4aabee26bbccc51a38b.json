{"ast":null,"code":"/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\n'use strict';\n\nconst safeBuffer = require('safe-buffer');\nconst crypto = require('crypto');\nconst PerMessageDeflate = require('./PerMessageDeflate');\nconst bufferUtil = require('./BufferUtil');\nconst ErrorCodes = require('./ErrorCodes');\nconst constants = require('./Constants');\nconst Buffer = safeBuffer.Buffer;\n\n/**\n * HyBi Sender implementation.\n */\nclass Sender {\n  /**\n   * Creates a Sender instance.\n   *\n   * @param {net.Socket} socket The connection socket\n   * @param {Object} extensions An object containing the negotiated extensions\n   */\n  constructor(socket, extensions) {\n    this._extensions = extensions || {};\n    this._socket = socket;\n    this._firstFragment = true;\n    this._compress = false;\n    this._bufferedBytes = 0;\n    this._deflating = false;\n    this._queue = [];\n  }\n\n  /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {Buffer} data The data to frame\n   * @param {Object} options Options object\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} options.readOnly Specifies whether `data` can be modified\n   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit\n   * @return {Buffer[]} The framed data as a list of `Buffer` instances\n   * @public\n   */\n  static frame(data, options) {\n    const merge = data.length < 1024 || options.mask && options.readOnly;\n    var offset = options.mask ? 6 : 2;\n    var payloadLength = data.length;\n    if (data.length >= 65536) {\n      offset += 8;\n      payloadLength = 127;\n    } else if (data.length > 125) {\n      offset += 2;\n      payloadLength = 126;\n    }\n    const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);\n    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n    if (options.rsv1) target[0] |= 0x40;\n    if (payloadLength === 126) {\n      target.writeUInt16BE(data.length, 2, true);\n    } else if (payloadLength === 127) {\n      target.writeUInt32BE(0, 2, true);\n      target.writeUInt32BE(data.length, 6, true);\n    }\n    if (!options.mask) {\n      target[1] = payloadLength;\n      if (merge) {\n        data.copy(target, offset);\n        return [target];\n      }\n      return [target, data];\n    }\n    const mask = crypto.randomBytes(4);\n    target[1] = payloadLength | 0x80;\n    target[offset - 4] = mask[0];\n    target[offset - 3] = mask[1];\n    target[offset - 2] = mask[2];\n    target[offset - 1] = mask[3];\n    if (merge) {\n      bufferUtil.mask(data, mask, target, offset, data.length);\n      return [target];\n    }\n    bufferUtil.mask(data, mask, data, 0, data.length);\n    return [target, data];\n  }\n\n  /**\n   * Sends a close message to the other peer.\n   *\n   * @param {(Number|undefined)} code The status code component of the body\n   * @param {String} data The message component of the body\n   * @param {Boolean} mask Specifies whether or not to mask the message\n   * @param {Function} cb Callback\n   * @public\n   */\n  close(code, data, mask, cb) {\n    var buf;\n    if (code === undefined) {\n      code = 1000;\n    } else if (typeof code !== 'number' || !ErrorCodes.isValidErrorCode(code)) {\n      throw new Error('first argument must be a valid error code number');\n    }\n    if (data === undefined || data === '') {\n      if (code === 1000) {\n        buf = constants.EMPTY_BUFFER;\n      } else {\n        buf = Buffer.allocUnsafe(2);\n        buf.writeUInt16BE(code, 0, true);\n      }\n    } else {\n      buf = Buffer.allocUnsafe(2 + Buffer.byteLength(data));\n      buf.writeUInt16BE(code, 0, true);\n      buf.write(data, 2);\n    }\n    if (this._deflating) {\n      this.enqueue([this.doClose, buf, mask, cb]);\n    } else {\n      this.doClose(buf, mask, cb);\n    }\n  }\n\n  /**\n   * Frames and sends a close message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @private\n   */\n  doClose(data, mask, cb) {\n    this.sendFrame(Sender.frame(data, {\n      fin: true,\n      rsv1: false,\n      opcode: 0x08,\n      mask,\n      readOnly: false\n    }), cb);\n  }\n\n  /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @public\n   */\n  ping(data, mask) {\n    var readOnly = true;\n    if (!Buffer.isBuffer(data)) {\n      if (data instanceof ArrayBuffer) {\n        data = Buffer.from(data);\n      } else if (ArrayBuffer.isView(data)) {\n        data = viewToBuffer(data);\n      } else {\n        data = Buffer.from(data);\n        readOnly = false;\n      }\n    }\n    if (this._deflating) {\n      this.enqueue([this.doPing, data, mask, readOnly]);\n    } else {\n      this.doPing(data, mask, readOnly);\n    }\n  }\n\n  /**\n   * Frames and sends a ping message.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Boolean} readOnly Specifies whether `data` can be modified\n   * @private\n   */\n  doPing(data, mask, readOnly) {\n    this.sendFrame(Sender.frame(data, {\n      fin: true,\n      rsv1: false,\n      opcode: 0x09,\n      mask,\n      readOnly\n    }));\n  }\n\n  /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @public\n   */\n  pong(data, mask) {\n    var readOnly = true;\n    if (!Buffer.isBuffer(data)) {\n      if (data instanceof ArrayBuffer) {\n        data = Buffer.from(data);\n      } else if (ArrayBuffer.isView(data)) {\n        data = viewToBuffer(data);\n      } else {\n        data = Buffer.from(data);\n        readOnly = false;\n      }\n    }\n    if (this._deflating) {\n      this.enqueue([this.doPong, data, mask, readOnly]);\n    } else {\n      this.doPong(data, mask, readOnly);\n    }\n  }\n\n  /**\n   * Frames and sends a pong message.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Boolean} readOnly Specifies whether `data` can be modified\n   * @private\n   */\n  doPong(data, mask, readOnly) {\n    this.sendFrame(Sender.frame(data, {\n      fin: true,\n      rsv1: false,\n      opcode: 0x0a,\n      mask,\n      readOnly\n    }));\n  }\n\n  /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} options.compress Specifies whether or not to compress `data`\n   * @param {Boolean} options.binary Specifies whether `data` is binary or text\n   * @param {Boolean} options.fin Specifies whether the fragment is the last one\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @public\n   */\n  send(data, options, cb) {\n    var opcode = options.binary ? 2 : 1;\n    var rsv1 = options.compress;\n    var readOnly = true;\n    if (!Buffer.isBuffer(data)) {\n      if (data instanceof ArrayBuffer) {\n        data = Buffer.from(data);\n      } else if (ArrayBuffer.isView(data)) {\n        data = viewToBuffer(data);\n      } else {\n        data = Buffer.from(data);\n        readOnly = false;\n      }\n    }\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    if (this._firstFragment) {\n      this._firstFragment = false;\n      if (rsv1 && perMessageDeflate) {\n        rsv1 = data.length >= perMessageDeflate._threshold;\n      }\n      this._compress = rsv1;\n    } else {\n      rsv1 = false;\n      opcode = 0;\n    }\n    if (options.fin) this._firstFragment = true;\n    if (perMessageDeflate) {\n      const opts = {\n        fin: options.fin,\n        rsv1,\n        opcode,\n        mask: options.mask,\n        readOnly\n      };\n      if (this._deflating) {\n        this.enqueue([this.dispatch, data, this._compress, opts, cb]);\n      } else {\n        this.dispatch(data, this._compress, opts, cb);\n      }\n    } else {\n      this.sendFrame(Sender.frame(data, {\n        fin: options.fin,\n        rsv1: false,\n        opcode,\n        mask: options.mask,\n        readOnly\n      }), cb);\n    }\n  }\n\n  /**\n   * Dispatches a data message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} compress Specifies whether or not to compress `data`\n   * @param {Object} options Options object\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} options.readOnly Specifies whether `data` can be modified\n   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit\n   * @param {Function} cb Callback\n   * @private\n   */\n  dispatch(data, compress, options, cb) {\n    if (!compress) {\n      this.sendFrame(Sender.frame(data, options), cb);\n      return;\n    }\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    this._deflating = true;\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\n      options.readOnly = false;\n      this.sendFrame(Sender.frame(buf, options), cb);\n      this._deflating = false;\n      this.dequeue();\n    });\n  }\n\n  /**\n   * Executes queued send operations.\n   *\n   * @private\n   */\n  dequeue() {\n    while (!this._deflating && this._queue.length) {\n      const params = this._queue.shift();\n      this._bufferedBytes -= params[1].length;\n      params[0].apply(this, params.slice(1));\n    }\n  }\n\n  /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */\n  enqueue(params) {\n    this._bufferedBytes += params[1].length;\n    this._queue.push(params);\n  }\n\n  /**\n   * Sends a frame.\n   *\n   * @param {Buffer[]} list The frame to send\n   * @param {Function} cb Callback\n   * @private\n   */\n  sendFrame(list, cb) {\n    if (list.length === 2) {\n      this._socket.write(list[0]);\n      this._socket.write(list[1], cb);\n    } else {\n      this._socket.write(list[0], cb);\n    }\n  }\n}\nmodule.exports = Sender;\n\n/**\n * Converts an `ArrayBuffer` view into a buffer.\n *\n * @param {(DataView|TypedArray)} view The view to convert\n * @return {Buffer} Converted view\n * @private\n */\nfunction viewToBuffer(view) {\n  const buf = Buffer.from(view.buffer);\n  if (view.byteLength !== view.buffer.byteLength) {\n    return buf.slice(view.byteOffset, view.byteOffset + view.byteLength);\n  }\n  return buf;\n}","map":{"version":3,"names":["safeBuffer","require","crypto","PerMessageDeflate","bufferUtil","ErrorCodes","constants","Buffer","Sender","constructor","socket","extensions","_extensions","_socket","_firstFragment","_compress","_bufferedBytes","_deflating","_queue","frame","data","options","merge","length","mask","readOnly","offset","payloadLength","target","allocUnsafe","fin","opcode","rsv1","writeUInt16BE","writeUInt32BE","copy","randomBytes","close","code","cb","buf","undefined","isValidErrorCode","Error","EMPTY_BUFFER","byteLength","write","enqueue","doClose","sendFrame","ping","isBuffer","ArrayBuffer","from","isView","viewToBuffer","doPing","pong","doPong","send","binary","compress","perMessageDeflate","extensionName","_threshold","opts","dispatch","_","dequeue","params","shift","apply","slice","push","list","module","exports","view","buffer","byteOffset"],"sources":["/home/user/Рабочий стол/pizza/project/node_modules/ws/lib/Sender.js"],"sourcesContent":["/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\n'use strict';\n\nconst safeBuffer = require('safe-buffer');\nconst crypto = require('crypto');\n\nconst PerMessageDeflate = require('./PerMessageDeflate');\nconst bufferUtil = require('./BufferUtil');\nconst ErrorCodes = require('./ErrorCodes');\nconst constants = require('./Constants');\n\nconst Buffer = safeBuffer.Buffer;\n\n/**\n * HyBi Sender implementation.\n */\nclass Sender {\n  /**\n   * Creates a Sender instance.\n   *\n   * @param {net.Socket} socket The connection socket\n   * @param {Object} extensions An object containing the negotiated extensions\n   */\n  constructor (socket, extensions) {\n    this._extensions = extensions || {};\n    this._socket = socket;\n\n    this._firstFragment = true;\n    this._compress = false;\n\n    this._bufferedBytes = 0;\n    this._deflating = false;\n    this._queue = [];\n  }\n\n  /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {Buffer} data The data to frame\n   * @param {Object} options Options object\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} options.readOnly Specifies whether `data` can be modified\n   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit\n   * @return {Buffer[]} The framed data as a list of `Buffer` instances\n   * @public\n   */\n  static frame (data, options) {\n    const merge = data.length < 1024 || (options.mask && options.readOnly);\n    var offset = options.mask ? 6 : 2;\n    var payloadLength = data.length;\n\n    if (data.length >= 65536) {\n      offset += 8;\n      payloadLength = 127;\n    } else if (data.length > 125) {\n      offset += 2;\n      payloadLength = 126;\n    }\n\n    const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);\n\n    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n    if (options.rsv1) target[0] |= 0x40;\n\n    if (payloadLength === 126) {\n      target.writeUInt16BE(data.length, 2, true);\n    } else if (payloadLength === 127) {\n      target.writeUInt32BE(0, 2, true);\n      target.writeUInt32BE(data.length, 6, true);\n    }\n\n    if (!options.mask) {\n      target[1] = payloadLength;\n      if (merge) {\n        data.copy(target, offset);\n        return [target];\n      }\n\n      return [target, data];\n    }\n\n    const mask = crypto.randomBytes(4);\n\n    target[1] = payloadLength | 0x80;\n    target[offset - 4] = mask[0];\n    target[offset - 3] = mask[1];\n    target[offset - 2] = mask[2];\n    target[offset - 1] = mask[3];\n\n    if (merge) {\n      bufferUtil.mask(data, mask, target, offset, data.length);\n      return [target];\n    }\n\n    bufferUtil.mask(data, mask, data, 0, data.length);\n    return [target, data];\n  }\n\n  /**\n   * Sends a close message to the other peer.\n   *\n   * @param {(Number|undefined)} code The status code component of the body\n   * @param {String} data The message component of the body\n   * @param {Boolean} mask Specifies whether or not to mask the message\n   * @param {Function} cb Callback\n   * @public\n   */\n  close (code, data, mask, cb) {\n    var buf;\n\n    if (code === undefined) {\n      code = 1000;\n    } else if (typeof code !== 'number' || !ErrorCodes.isValidErrorCode(code)) {\n      throw new Error('first argument must be a valid error code number');\n    }\n\n    if (data === undefined || data === '') {\n      if (code === 1000) {\n        buf = constants.EMPTY_BUFFER;\n      } else {\n        buf = Buffer.allocUnsafe(2);\n        buf.writeUInt16BE(code, 0, true);\n      }\n    } else {\n      buf = Buffer.allocUnsafe(2 + Buffer.byteLength(data));\n      buf.writeUInt16BE(code, 0, true);\n      buf.write(data, 2);\n    }\n\n    if (this._deflating) {\n      this.enqueue([this.doClose, buf, mask, cb]);\n    } else {\n      this.doClose(buf, mask, cb);\n    }\n  }\n\n  /**\n   * Frames and sends a close message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @private\n   */\n  doClose (data, mask, cb) {\n    this.sendFrame(Sender.frame(data, {\n      fin: true,\n      rsv1: false,\n      opcode: 0x08,\n      mask,\n      readOnly: false\n    }), cb);\n  }\n\n  /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @public\n   */\n  ping (data, mask) {\n    var readOnly = true;\n\n    if (!Buffer.isBuffer(data)) {\n      if (data instanceof ArrayBuffer) {\n        data = Buffer.from(data);\n      } else if (ArrayBuffer.isView(data)) {\n        data = viewToBuffer(data);\n      } else {\n        data = Buffer.from(data);\n        readOnly = false;\n      }\n    }\n\n    if (this._deflating) {\n      this.enqueue([this.doPing, data, mask, readOnly]);\n    } else {\n      this.doPing(data, mask, readOnly);\n    }\n  }\n\n  /**\n   * Frames and sends a ping message.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Boolean} readOnly Specifies whether `data` can be modified\n   * @private\n   */\n  doPing (data, mask, readOnly) {\n    this.sendFrame(Sender.frame(data, {\n      fin: true,\n      rsv1: false,\n      opcode: 0x09,\n      mask,\n      readOnly\n    }));\n  }\n\n  /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @public\n   */\n  pong (data, mask) {\n    var readOnly = true;\n\n    if (!Buffer.isBuffer(data)) {\n      if (data instanceof ArrayBuffer) {\n        data = Buffer.from(data);\n      } else if (ArrayBuffer.isView(data)) {\n        data = viewToBuffer(data);\n      } else {\n        data = Buffer.from(data);\n        readOnly = false;\n      }\n    }\n\n    if (this._deflating) {\n      this.enqueue([this.doPong, data, mask, readOnly]);\n    } else {\n      this.doPong(data, mask, readOnly);\n    }\n  }\n\n  /**\n   * Frames and sends a pong message.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Boolean} readOnly Specifies whether `data` can be modified\n   * @private\n   */\n  doPong (data, mask, readOnly) {\n    this.sendFrame(Sender.frame(data, {\n      fin: true,\n      rsv1: false,\n      opcode: 0x0a,\n      mask,\n      readOnly\n    }));\n  }\n\n  /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} options.compress Specifies whether or not to compress `data`\n   * @param {Boolean} options.binary Specifies whether `data` is binary or text\n   * @param {Boolean} options.fin Specifies whether the fragment is the last one\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @public\n   */\n  send (data, options, cb) {\n    var opcode = options.binary ? 2 : 1;\n    var rsv1 = options.compress;\n    var readOnly = true;\n\n    if (!Buffer.isBuffer(data)) {\n      if (data instanceof ArrayBuffer) {\n        data = Buffer.from(data);\n      } else if (ArrayBuffer.isView(data)) {\n        data = viewToBuffer(data);\n      } else {\n        data = Buffer.from(data);\n        readOnly = false;\n      }\n    }\n\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    if (this._firstFragment) {\n      this._firstFragment = false;\n      if (rsv1 && perMessageDeflate) {\n        rsv1 = data.length >= perMessageDeflate._threshold;\n      }\n      this._compress = rsv1;\n    } else {\n      rsv1 = false;\n      opcode = 0;\n    }\n\n    if (options.fin) this._firstFragment = true;\n\n    if (perMessageDeflate) {\n      const opts = {\n        fin: options.fin,\n        rsv1,\n        opcode,\n        mask: options.mask,\n        readOnly\n      };\n\n      if (this._deflating) {\n        this.enqueue([this.dispatch, data, this._compress, opts, cb]);\n      } else {\n        this.dispatch(data, this._compress, opts, cb);\n      }\n    } else {\n      this.sendFrame(Sender.frame(data, {\n        fin: options.fin,\n        rsv1: false,\n        opcode,\n        mask: options.mask,\n        readOnly\n      }), cb);\n    }\n  }\n\n  /**\n   * Dispatches a data message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} compress Specifies whether or not to compress `data`\n   * @param {Object} options Options object\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} options.readOnly Specifies whether `data` can be modified\n   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit\n   * @param {Function} cb Callback\n   * @private\n   */\n  dispatch (data, compress, options, cb) {\n    if (!compress) {\n      this.sendFrame(Sender.frame(data, options), cb);\n      return;\n    }\n\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    this._deflating = true;\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\n      options.readOnly = false;\n      this.sendFrame(Sender.frame(buf, options), cb);\n      this._deflating = false;\n      this.dequeue();\n    });\n  }\n\n  /**\n   * Executes queued send operations.\n   *\n   * @private\n   */\n  dequeue () {\n    while (!this._deflating && this._queue.length) {\n      const params = this._queue.shift();\n\n      this._bufferedBytes -= params[1].length;\n      params[0].apply(this, params.slice(1));\n    }\n  }\n\n  /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */\n  enqueue (params) {\n    this._bufferedBytes += params[1].length;\n    this._queue.push(params);\n  }\n\n  /**\n   * Sends a frame.\n   *\n   * @param {Buffer[]} list The frame to send\n   * @param {Function} cb Callback\n   * @private\n   */\n  sendFrame (list, cb) {\n    if (list.length === 2) {\n      this._socket.write(list[0]);\n      this._socket.write(list[1], cb);\n    } else {\n      this._socket.write(list[0], cb);\n    }\n  }\n}\n\nmodule.exports = Sender;\n\n/**\n * Converts an `ArrayBuffer` view into a buffer.\n *\n * @param {(DataView|TypedArray)} view The view to convert\n * @return {Buffer} Converted view\n * @private\n */\nfunction viewToBuffer (view) {\n  const buf = Buffer.from(view.buffer);\n\n  if (view.byteLength !== view.buffer.byteLength) {\n    return buf.slice(view.byteOffset, view.byteOffset + view.byteLength);\n  }\n\n  return buf;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}