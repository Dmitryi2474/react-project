{"ast":null,"code":"'use strict';\n\nvar has = Object.prototype.hasOwnProperty;\n\n/**\n * An auto incrementing id which we can use to create \"unique\" Ultron instances\n * so we can track the event emitters that are added through the Ultron\n * interface.\n *\n * @type {Number}\n * @private\n */\nvar id = 0;\n\n/**\n * Ultron is high-intelligence robot. It gathers intelligence so it can start improving\n * upon his rudimentary design. It will learn from your EventEmitting patterns\n * and exterminate them.\n *\n * @constructor\n * @param {EventEmitter} ee EventEmitter instance we need to wrap.\n * @api public\n */\nfunction Ultron(ee) {\n  if (!(this instanceof Ultron)) return new Ultron(ee);\n  this.id = id++;\n  this.ee = ee;\n}\n\n/**\n * Register a new EventListener for the given event.\n *\n * @param {String} event Name of the event.\n * @param {Functon} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @returns {Ultron}\n * @api public\n */\nUltron.prototype.on = function on(event, fn, context) {\n  fn.__ultron = this.id;\n  this.ee.on(event, fn, context);\n  return this;\n};\n/**\n * Add an EventListener that's only called once.\n *\n * @param {String} event Name of the event.\n * @param {Function} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @returns {Ultron}\n * @api public\n */\nUltron.prototype.once = function once(event, fn, context) {\n  fn.__ultron = this.id;\n  this.ee.once(event, fn, context);\n  return this;\n};\n\n/**\n * Remove the listeners we assigned for the given event.\n *\n * @returns {Ultron}\n * @api public\n */\nUltron.prototype.remove = function remove() {\n  var args = arguments,\n    ee = this.ee,\n    event;\n\n  //\n  // When no event names are provided we assume that we need to clear all the\n  // events that were assigned through us.\n  //\n  if (args.length === 1 && 'string' === typeof args[0]) {\n    args = args[0].split(/[, ]+/);\n  } else if (!args.length) {\n    if (ee.eventNames) {\n      args = ee.eventNames();\n    } else if (ee._events) {\n      args = [];\n      for (event in ee._events) {\n        if (has.call(ee._events, event)) args.push(event);\n      }\n      if (Object.getOwnPropertySymbols) {\n        args = args.concat(Object.getOwnPropertySymbols(ee._events));\n      }\n    }\n  }\n  for (var i = 0; i < args.length; i++) {\n    var listeners = ee.listeners(args[i]);\n    for (var j = 0; j < listeners.length; j++) {\n      event = listeners[j];\n\n      //\n      // Once listeners have a `listener` property that stores the real listener\n      // in the EventEmitter that ships with Node.js.\n      //\n      if (event.listener) {\n        if (event.listener.__ultron !== this.id) continue;\n      } else if (event.__ultron !== this.id) {\n        continue;\n      }\n      ee.removeListener(args[i], event);\n    }\n  }\n  return this;\n};\n\n/**\n * Destroy the Ultron instance, remove all listeners and release all references.\n *\n * @returns {Boolean}\n * @api public\n */\nUltron.prototype.destroy = function destroy() {\n  if (!this.ee) return false;\n  this.remove();\n  this.ee = null;\n  return true;\n};\n\n//\n// Expose the module.\n//\nmodule.exports = Ultron;","map":{"version":3,"names":["has","Object","prototype","hasOwnProperty","id","Ultron","ee","on","event","fn","context","__ultron","once","remove","args","arguments","length","split","eventNames","_events","call","push","getOwnPropertySymbols","concat","i","listeners","j","listener","removeListener","destroy","module","exports"],"sources":["/home/user/Рабочий стол/pizza/project/node_modules/ultron/index.js"],"sourcesContent":["'use strict';\n\nvar has = Object.prototype.hasOwnProperty;\n\n/**\n * An auto incrementing id which we can use to create \"unique\" Ultron instances\n * so we can track the event emitters that are added through the Ultron\n * interface.\n *\n * @type {Number}\n * @private\n */\nvar id = 0;\n\n/**\n * Ultron is high-intelligence robot. It gathers intelligence so it can start improving\n * upon his rudimentary design. It will learn from your EventEmitting patterns\n * and exterminate them.\n *\n * @constructor\n * @param {EventEmitter} ee EventEmitter instance we need to wrap.\n * @api public\n */\nfunction Ultron(ee) {\n  if (!(this instanceof Ultron)) return new Ultron(ee);\n\n  this.id = id++;\n  this.ee = ee;\n}\n\n/**\n * Register a new EventListener for the given event.\n *\n * @param {String} event Name of the event.\n * @param {Functon} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @returns {Ultron}\n * @api public\n */\nUltron.prototype.on = function on(event, fn, context) {\n  fn.__ultron = this.id;\n  this.ee.on(event, fn, context);\n\n  return this;\n};\n/**\n * Add an EventListener that's only called once.\n *\n * @param {String} event Name of the event.\n * @param {Function} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @returns {Ultron}\n * @api public\n */\nUltron.prototype.once = function once(event, fn, context) {\n  fn.__ultron = this.id;\n  this.ee.once(event, fn, context);\n\n  return this;\n};\n\n/**\n * Remove the listeners we assigned for the given event.\n *\n * @returns {Ultron}\n * @api public\n */\nUltron.prototype.remove = function remove() {\n  var args = arguments\n    , ee = this.ee\n    , event;\n\n  //\n  // When no event names are provided we assume that we need to clear all the\n  // events that were assigned through us.\n  //\n  if (args.length === 1 && 'string' === typeof args[0]) {\n    args = args[0].split(/[, ]+/);\n  } else if (!args.length) {\n    if (ee.eventNames) {\n      args = ee.eventNames();\n    } else if (ee._events) {\n      args = [];\n\n      for (event in ee._events) {\n        if (has.call(ee._events, event)) args.push(event);\n      }\n\n      if (Object.getOwnPropertySymbols) {\n        args = args.concat(Object.getOwnPropertySymbols(ee._events));\n      }\n    }\n  }\n\n  for (var i = 0; i < args.length; i++) {\n    var listeners = ee.listeners(args[i]);\n\n    for (var j = 0; j < listeners.length; j++) {\n      event = listeners[j];\n\n      //\n      // Once listeners have a `listener` property that stores the real listener\n      // in the EventEmitter that ships with Node.js.\n      //\n      if (event.listener) {\n        if (event.listener.__ultron !== this.id) continue;\n      } else if (event.__ultron !== this.id) {\n        continue;\n      }\n\n      ee.removeListener(args[i], event);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Destroy the Ultron instance, remove all listeners and release all references.\n *\n * @returns {Boolean}\n * @api public\n */\nUltron.prototype.destroy = function destroy() {\n  if (!this.ee) return false;\n\n  this.remove();\n  this.ee = null;\n\n  return true;\n};\n\n//\n// Expose the module.\n//\nmodule.exports = Ultron;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}