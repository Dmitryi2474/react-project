{"ast":null,"code":"/*!\n * extglob <https://github.com/jonschlinkert/extglob>\n *\n * Copyright (c) 2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\n/**\n * Module dependencies\n */\nvar isExtglob = require('is-extglob');\nvar re,\n  cache = {};\n\n/**\n * Expose `extglob`\n */\n\nmodule.exports = extglob;\n\n/**\n * Convert the given extglob `string` to a regex-compatible\n * string.\n *\n * ```js\n * var extglob = require('extglob');\n * extglob('!(a?(b))');\n * //=> '(?!a(?:b)?)[^/]*?'\n * ```\n *\n * @param {String} `str` The string to convert.\n * @param {Object} `options`\n *   @option {Boolean} [options] `esc` If `false` special characters will not be escaped. Defaults to `true`.\n *   @option {Boolean} [options] `regex` If `true` a regular expression is returned instead of a string.\n * @return {String}\n * @api public\n */\n\nfunction extglob(str, opts) {\n  opts = opts || {};\n  var o = {},\n    i = 0;\n\n  // fix common character reversals\n  // '*!(.js)' => '*.!(js)'\n  str = str.replace(/!\\(([^\\w*()])/g, '$1!(');\n\n  // support file extension negation\n  str = str.replace(/([*\\/])\\.!\\([*]\\)/g, function (m, ch) {\n    if (ch === '/') {\n      return escape('\\\\/[^.]+');\n    }\n    return escape('[^.]+');\n  });\n\n  // create a unique key for caching by\n  // combining the string and options\n  var key = str + String(!!opts.regex) + String(!!opts.contains) + String(!!opts.escape);\n  if (cache.hasOwnProperty(key)) {\n    return cache[key];\n  }\n  if (!(re instanceof RegExp)) {\n    re = regex();\n  }\n  opts.negate = false;\n  var m;\n  while (m = re.exec(str)) {\n    var prefix = m[1];\n    var inner = m[3];\n    if (prefix === '!') {\n      opts.negate = true;\n    }\n    var id = '__EXTGLOB_' + i++ + '__';\n    // use the prefix of the _last_ (outtermost) pattern\n    o[id] = wrap(inner, prefix, opts.escape);\n    str = str.split(m[0]).join(id);\n  }\n  var keys = Object.keys(o);\n  var len = keys.length;\n\n  // we have to loop again to allow us to convert\n  // patterns in reverse order (starting with the\n  // innermost/last pattern first)\n  while (len--) {\n    var prop = keys[len];\n    str = str.split(prop).join(o[prop]);\n  }\n  var result = opts.regex ? toRegex(str, opts.contains, opts.negate) : str;\n  result = result.split('.').join('\\\\.');\n\n  // cache the result and return it\n  return cache[key] = result;\n}\n\n/**\n * Convert `string` to a regex string.\n *\n * @param  {String} `str`\n * @param  {String} `prefix` Character that determines how to wrap the string.\n * @param  {Boolean} `esc` If `false` special characters will not be escaped. Defaults to `true`.\n * @return {String}\n */\n\nfunction wrap(inner, prefix, esc) {\n  if (esc) inner = escape(inner);\n  switch (prefix) {\n    case '!':\n      return '(?!' + inner + ')[^/]' + (esc ? '%%%~' : '*?');\n    case '@':\n      return '(?:' + inner + ')';\n    case '+':\n      return '(?:' + inner + ')+';\n    case '*':\n      return '(?:' + inner + ')' + (esc ? '%%' : '*');\n    case '?':\n      return '(?:' + inner + '|)';\n    default:\n      return inner;\n  }\n}\nfunction escape(str) {\n  str = str.split('*').join('[^/]%%%~');\n  str = str.split('.').join('\\\\.');\n  return str;\n}\n\n/**\n * extglob regex.\n */\n\nfunction regex() {\n  return /(\\\\?[@?!+*$]\\\\?)(\\(([^()]*?)\\))/;\n}\n\n/**\n * Negation regex\n */\n\nfunction negate(str) {\n  return '(?!^' + str + ').*$';\n}\n\n/**\n * Create the regex to do the matching. If\n * the leading character in the `pattern` is `!`\n * a negation regex is returned.\n *\n * @param {String} `pattern`\n * @param {Boolean} `contains` Allow loose matching.\n * @param {Boolean} `isNegated` True if the pattern is a negation pattern.\n */\n\nfunction toRegex(pattern, contains, isNegated) {\n  var prefix = contains ? '^' : '';\n  var after = contains ? '$' : '';\n  pattern = '(?:' + pattern + ')' + after;\n  if (isNegated) {\n    pattern = prefix + negate(pattern);\n  }\n  return new RegExp(prefix + pattern);\n}","map":{"version":3,"names":["isExtglob","require","re","cache","module","exports","extglob","str","opts","o","i","replace","m","ch","escape","key","String","regex","contains","hasOwnProperty","RegExp","negate","exec","prefix","inner","id","wrap","split","join","keys","Object","len","length","prop","result","toRegex","esc","pattern","isNegated","after"],"sources":["/home/user/Рабочий стол/pizza/project/node_modules/extglob/index.js"],"sourcesContent":["/*!\n * extglob <https://github.com/jonschlinkert/extglob>\n *\n * Copyright (c) 2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\n/**\n * Module dependencies\n */\n\nvar isExtglob = require('is-extglob');\nvar re, cache = {};\n\n/**\n * Expose `extglob`\n */\n\nmodule.exports = extglob;\n\n/**\n * Convert the given extglob `string` to a regex-compatible\n * string.\n *\n * ```js\n * var extglob = require('extglob');\n * extglob('!(a?(b))');\n * //=> '(?!a(?:b)?)[^/]*?'\n * ```\n *\n * @param {String} `str` The string to convert.\n * @param {Object} `options`\n *   @option {Boolean} [options] `esc` If `false` special characters will not be escaped. Defaults to `true`.\n *   @option {Boolean} [options] `regex` If `true` a regular expression is returned instead of a string.\n * @return {String}\n * @api public\n */\n\n\nfunction extglob(str, opts) {\n  opts = opts || {};\n  var o = {}, i = 0;\n\n  // fix common character reversals\n  // '*!(.js)' => '*.!(js)'\n  str = str.replace(/!\\(([^\\w*()])/g, '$1!(');\n\n  // support file extension negation\n  str = str.replace(/([*\\/])\\.!\\([*]\\)/g, function (m, ch) {\n    if (ch === '/') {\n      return escape('\\\\/[^.]+');\n    }\n    return escape('[^.]+');\n  });\n\n  // create a unique key for caching by\n  // combining the string and options\n  var key = str\n    + String(!!opts.regex)\n    + String(!!opts.contains)\n    + String(!!opts.escape);\n\n  if (cache.hasOwnProperty(key)) {\n    return cache[key];\n  }\n\n  if (!(re instanceof RegExp)) {\n    re = regex();\n  }\n\n  opts.negate = false;\n  var m;\n\n  while (m = re.exec(str)) {\n    var prefix = m[1];\n    var inner = m[3];\n    if (prefix === '!') {\n      opts.negate = true;\n    }\n\n    var id = '__EXTGLOB_' + (i++) + '__';\n    // use the prefix of the _last_ (outtermost) pattern\n    o[id] = wrap(inner, prefix, opts.escape);\n    str = str.split(m[0]).join(id);\n  }\n\n  var keys = Object.keys(o);\n  var len = keys.length;\n\n  // we have to loop again to allow us to convert\n  // patterns in reverse order (starting with the\n  // innermost/last pattern first)\n  while (len--) {\n    var prop = keys[len];\n    str = str.split(prop).join(o[prop]);\n  }\n\n  var result = opts.regex\n    ? toRegex(str, opts.contains, opts.negate)\n    : str;\n\n  result = result.split('.').join('\\\\.');\n\n  // cache the result and return it\n  return (cache[key] = result);\n}\n\n/**\n * Convert `string` to a regex string.\n *\n * @param  {String} `str`\n * @param  {String} `prefix` Character that determines how to wrap the string.\n * @param  {Boolean} `esc` If `false` special characters will not be escaped. Defaults to `true`.\n * @return {String}\n */\n\nfunction wrap(inner, prefix, esc) {\n  if (esc) inner = escape(inner);\n\n  switch (prefix) {\n    case '!':\n      return '(?!' + inner + ')[^/]' + (esc ? '%%%~' : '*?');\n    case '@':\n      return '(?:' + inner + ')';\n    case '+':\n      return '(?:' + inner + ')+';\n    case '*':\n      return '(?:' + inner + ')' + (esc ? '%%' : '*')\n    case '?':\n      return '(?:' + inner + '|)';\n    default:\n      return inner;\n  }\n}\n\nfunction escape(str) {\n  str = str.split('*').join('[^/]%%%~');\n  str = str.split('.').join('\\\\.');\n  return str;\n}\n\n/**\n * extglob regex.\n */\n\nfunction regex() {\n  return /(\\\\?[@?!+*$]\\\\?)(\\(([^()]*?)\\))/;\n}\n\n/**\n * Negation regex\n */\n\nfunction negate(str) {\n  return '(?!^' + str + ').*$';\n}\n\n/**\n * Create the regex to do the matching. If\n * the leading character in the `pattern` is `!`\n * a negation regex is returned.\n *\n * @param {String} `pattern`\n * @param {Boolean} `contains` Allow loose matching.\n * @param {Boolean} `isNegated` True if the pattern is a negation pattern.\n */\n\nfunction toRegex(pattern, contains, isNegated) {\n  var prefix = contains ? '^' : '';\n  var after = contains ? '$' : '';\n  pattern = ('(?:' + pattern + ')' + after);\n  if (isNegated) {\n    pattern = prefix + negate(pattern);\n  }\n  return new RegExp(prefix + pattern);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}