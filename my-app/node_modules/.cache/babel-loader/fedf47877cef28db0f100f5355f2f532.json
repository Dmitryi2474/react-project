{"ast":null,"code":"var Immutable = require(\"immutable\");\nvar Map = Immutable.Map;\nvar isMap = Immutable.Map.isMap;\nvar List = Immutable.List;\nvar qs = require(\"qs\");\nvar path = require(\"path\");\nvar fs = require(\"fs\");\nvar Plugin = Immutable.Record({\n  moduleName: \"\",\n  name: \"\",\n  active: true,\n  module: undefined,\n  options: Map({}),\n  via: \"inline\",\n  dir: process.cwd(),\n  init: undefined,\n  errors: List([])\n});\n/**\n * Accept a string/object\n * and resolve it into the plugin format above\n * @param item\n * @returns {*}\n */\nfunction resolvePlugin(item) {\n  /**\n   * Handle when string was given, such as plugins: ['bs-html-injector']\n   */\n  if (typeof item === \"string\") {\n    return getFromString(item);\n  }\n  if (!isMap(item)) {\n    return new Plugin().mergeDeep({\n      errors: [new Error(\"Plugin not supported in this format\")]\n    });\n  }\n  if (item.has(\"module\")) {\n    var nameOrObj = item.get(\"module\");\n    var options = item.get(\"options\");\n    /**\n     * The 'module' key can be a string, this allows\n     * inline plugin references, but with options\n     * eg:\n     *\n     * bs.init({\n     *     plugins: [\n     *         {\n     *             module: './myjs-file.js'\n     *             options: {\n     *                 files: \"*.html\"\n     *             }\n     *         }\n     *     ]\n     * });\n     */\n    if (typeof nameOrObj === \"string\") {\n      return getFromString(nameOrObj).mergeDeep({\n        options: options\n      });\n    }\n    /**\n     * If the plugin was given completely inline (because it needs options)\n     * eg:\n     *\n     * bs.init({\n     *     plugins: [\n     *         {\n     *             module: {\n     *                 plugin: function() {\n     *                     console.log('My plugin code')\n     *                 }\n     *             },\n     *             options: {\n     *                 files: \"*.html\"\n     *             }\n     *         }\n     *     ]\n     * })\n     */\n    if (Immutable.Map.isMap(nameOrObj)) {\n      return new Plugin({\n        module: nameOrObj,\n        options: options\n      });\n    }\n  }\n  /**\n   * If a module was given directly. For example, ater calling require.\n   *\n   * eg:\n   *    var myplugin = require('./some-js');\n   *    bs.init({plugins: [myplugin]});\n   */\n  if (item.has(\"plugin\")) {\n    return new Plugin({\n      module: item\n    });\n  }\n  /**\n   * If we reach here, the plugin option was used incorrectly\n   */\n  return new Plugin().mergeDeep({\n    errors: [new Error(\"Plugin was not configured correctly\")]\n  });\n}\nmodule.exports.resolvePlugin = resolvePlugin;\n/**\n * Load a plugin from disk\n * @param item\n * @returns {*}\n */\nfunction requirePlugin(item) {\n  /**\n   * if the \"module\" property already exists and\n   * is not a string, then we bail and don't bother looking\n   * for the file\n   */\n  if (item.get(\"module\") && typeof item.get(\"module\") !== \"string\") {\n    return item;\n  }\n  try {\n    /**\n     * Try a raw node require() call - this will be how\n     * regular \"npm installed\" plugins wil work\n     */\n    var maybe = require.resolve(item.get(\"name\"));\n    return item.set(\"module\", require(maybe));\n  } catch (e) {\n    /**\n     * If require threw an MODULE_NOT_FOUND error, try again\n     * by resolving from cwd. This is needed since cli\n     * users will not add ./ to the front of a path (which\n     * node requires to resolve from cwd)\n     */\n    if (e.code === \"MODULE_NOT_FOUND\") {\n      var maybe = path.resolve(process.cwd(), item.get(\"name\"));\n      if (fs.existsSync(maybe)) {\n        return item.set(\"module\", require(maybe));\n      } else {\n        /**\n         * Finally return a plugin that contains the error\n         * this will be picked up later and discarded\n         */\n        return item.update(\"errors\", function (errors) {\n          return errors.concat(e);\n        });\n      }\n    }\n    throw e;\n  }\n}\nmodule.exports.requirePlugin = requirePlugin;\nfunction getFromString(string) {\n  /**\n   * We allow query strings for plugins, so always split on ?\n   */\n  var split = string.split(\"?\");\n  var outGoing = new Plugin({\n    moduleName: split[0],\n    name: split[0]\n  });\n  if (split.length > 1) {\n    return outGoing.update(\"options\", function (opts) {\n      return opts.mergeDeep(qs.parse(split[1]));\n    });\n  }\n  return outGoing;\n}","map":{"version":3,"mappings":"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","names":["Immutable","require","Map","isMap","List","qs","path","fs","Plugin","Record","moduleName","name","active","module","undefined","options","via","dir","process","cwd","init","errors","resolvePlugin","item","getFromString","mergeDeep","Error","has","nameOrObj","get","exports","requirePlugin","maybe","resolve","set","e","code","existsSync","update","concat","string","split","outGoing","length","opts","parse"],"sources":["../lib/plugins.js"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}