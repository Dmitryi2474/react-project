{"ast":null,"code":"/*!\n * micromatch <https://github.com/jonschlinkert/micromatch>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nvar expand = require('./lib/expand');\nvar utils = require('./lib/utils');\n\n/**\n * The main function. Pass an array of filepaths,\n * and a string or array of glob patterns\n *\n * @param  {Array|String} `files`\n * @param  {Array|String} `patterns`\n * @param  {Object} `opts`\n * @return {Array} Array of matches\n */\n\nfunction micromatch(files, patterns, opts) {\n  if (!files || !patterns) return [];\n  opts = opts || {};\n  if (typeof opts.cache === 'undefined') {\n    opts.cache = true;\n  }\n  if (!Array.isArray(patterns)) {\n    return match(files, patterns, opts);\n  }\n  var len = patterns.length,\n    i = 0;\n  var omit = [],\n    keep = [];\n  while (len--) {\n    var glob = patterns[i++];\n    if (typeof glob === 'string' && glob.charCodeAt(0) === 33 /* ! */) {\n      omit.push.apply(omit, match(files, glob.slice(1), opts));\n    } else {\n      keep.push.apply(keep, match(files, glob, opts));\n    }\n  }\n  return utils.diff(keep, omit);\n}\n\n/**\n * Return an array of files that match the given glob pattern.\n *\n * This function is called by the main `micromatch` function If you only\n * need to pass a single pattern you might get very minor speed improvements\n * using this function.\n *\n * @param  {Array} `files`\n * @param  {String} `pattern`\n * @param  {Object} `options`\n * @return {Array}\n */\n\nfunction match(files, pattern, opts) {\n  if (utils.typeOf(files) !== 'string' && !Array.isArray(files)) {\n    throw new Error(msg('match', 'files', 'a string or array'));\n  }\n  files = utils.arrayify(files);\n  opts = opts || {};\n  var negate = opts.negate || false;\n  var orig = pattern;\n  if (typeof pattern === 'string') {\n    negate = pattern.charAt(0) === '!';\n    if (negate) {\n      pattern = pattern.slice(1);\n    }\n\n    // we need to remove the character regardless,\n    // so the above logic is still needed\n    if (opts.nonegate === true) {\n      negate = false;\n    }\n  }\n  var _isMatch = matcher(pattern, opts);\n  var len = files.length,\n    i = 0;\n  var res = [];\n  while (i < len) {\n    var file = files[i++];\n    var fp = utils.unixify(file, opts);\n    if (!_isMatch(fp)) {\n      continue;\n    }\n    res.push(fp);\n  }\n  if (res.length === 0) {\n    if (opts.failglob === true) {\n      throw new Error('micromatch.match() found no matches for: \"' + orig + '\".');\n    }\n    if (opts.nonull || opts.nullglob) {\n      res.push(utils.unescapeGlob(orig));\n    }\n  }\n\n  // if `negate` was defined, diff negated files\n  if (negate) {\n    res = utils.diff(files, res);\n  }\n\n  // if `ignore` was defined, diff ignored filed\n  if (opts.ignore && opts.ignore.length) {\n    pattern = opts.ignore;\n    opts = utils.omit(opts, ['ignore']);\n    res = utils.diff(res, micromatch(res, pattern, opts));\n  }\n  if (opts.nodupes) {\n    return utils.unique(res);\n  }\n  return res;\n}\n\n/**\n * Returns a function that takes a glob pattern or array of glob patterns\n * to be used with `Array#filter()`. (Internally this function generates\n * the matching function using the [matcher] method).\n *\n * ```js\n * var fn = mm.filter('[a-c]');\n * ['a', 'b', 'c', 'd', 'e'].filter(fn);\n * //=> ['a', 'b', 'c']\n * ```\n * @param  {String|Array} `patterns` Can be a glob or array of globs.\n * @param  {Options} `opts` Options to pass to the [matcher] method.\n * @return {Function} Filter function to be passed to `Array#filter()`.\n */\n\nfunction filter(patterns, opts) {\n  if (!Array.isArray(patterns) && typeof patterns !== 'string') {\n    throw new TypeError(msg('filter', 'patterns', 'a string or array'));\n  }\n  patterns = utils.arrayify(patterns);\n  var len = patterns.length,\n    i = 0;\n  var patternMatchers = Array(len);\n  while (i < len) {\n    patternMatchers[i] = matcher(patterns[i++], opts);\n  }\n  return function (fp) {\n    if (fp == null) return [];\n    var len = patternMatchers.length,\n      i = 0;\n    var res = true;\n    fp = utils.unixify(fp, opts);\n    while (i < len) {\n      var fn = patternMatchers[i++];\n      if (!fn(fp)) {\n        res = false;\n        break;\n      }\n    }\n    return res;\n  };\n}\n\n/**\n * Returns true if the filepath contains the given\n * pattern. Can also return a function for matching.\n *\n * ```js\n * isMatch('foo.md', '*.md', {});\n * //=> true\n *\n * isMatch('*.md', {})('foo.md')\n * //=> true\n * ```\n * @param  {String} `fp`\n * @param  {String} `pattern`\n * @param  {Object} `opts`\n * @return {Boolean}\n */\n\nfunction isMatch(fp, pattern, opts) {\n  if (typeof fp !== 'string') {\n    throw new TypeError(msg('isMatch', 'filepath', 'a string'));\n  }\n  fp = utils.unixify(fp, opts);\n  if (utils.typeOf(pattern) === 'object') {\n    return matcher(fp, pattern);\n  }\n  return matcher(pattern, opts)(fp);\n}\n\n/**\n * Returns true if the filepath matches the\n * given pattern.\n */\n\nfunction contains(fp, pattern, opts) {\n  if (typeof fp !== 'string') {\n    throw new TypeError(msg('contains', 'pattern', 'a string'));\n  }\n  opts = opts || {};\n  opts.contains = pattern !== '';\n  fp = utils.unixify(fp, opts);\n  if (opts.contains && !utils.isGlob(pattern)) {\n    return fp.indexOf(pattern) !== -1;\n  }\n  return matcher(pattern, opts)(fp);\n}\n\n/**\n * Returns true if a file path matches any of the\n * given patterns.\n *\n * @param  {String} `fp` The filepath to test.\n * @param  {String|Array} `patterns` Glob patterns to use.\n * @param  {Object} `opts` Options to pass to the `matcher()` function.\n * @return {String}\n */\n\nfunction any(fp, patterns, opts) {\n  if (!Array.isArray(patterns) && typeof patterns !== 'string') {\n    throw new TypeError(msg('any', 'patterns', 'a string or array'));\n  }\n  patterns = utils.arrayify(patterns);\n  var len = patterns.length;\n  fp = utils.unixify(fp, opts);\n  while (len--) {\n    var isMatch = matcher(patterns[len], opts);\n    if (isMatch(fp)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Filter the keys of an object with the given `glob` pattern\n * and `options`\n *\n * @param  {Object} `object`\n * @param  {Pattern} `object`\n * @return {Array}\n */\n\nfunction matchKeys(obj, glob, options) {\n  if (utils.typeOf(obj) !== 'object') {\n    throw new TypeError(msg('matchKeys', 'first argument', 'an object'));\n  }\n  var fn = matcher(glob, options);\n  var res = {};\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key) && fn(key)) {\n      res[key] = obj[key];\n    }\n  }\n  return res;\n}\n\n/**\n * Return a function for matching based on the\n * given `pattern` and `options`.\n *\n * @param  {String} `pattern`\n * @param  {Object} `options`\n * @return {Function}\n */\n\nfunction matcher(pattern, opts) {\n  // pattern is a function\n  if (typeof pattern === 'function') {\n    return pattern;\n  }\n  // pattern is a regex\n  if (pattern instanceof RegExp) {\n    return function (fp) {\n      return pattern.test(fp);\n    };\n  }\n  if (typeof pattern !== 'string') {\n    throw new TypeError(msg('matcher', 'pattern', 'a string, regex, or function'));\n  }\n\n  // strings, all the way down...\n  pattern = utils.unixify(pattern, opts);\n\n  // pattern is a non-glob string\n  if (!utils.isGlob(pattern)) {\n    return utils.matchPath(pattern, opts);\n  }\n  // pattern is a glob string\n  var re = makeRe(pattern, opts);\n\n  // `matchBase` is defined\n  if (opts && opts.matchBase) {\n    return utils.hasFilename(re, opts);\n  }\n  // `matchBase` is not defined\n  return function (fp) {\n    fp = utils.unixify(fp, opts);\n    return re.test(fp);\n  };\n}\n\n/**\n * Create and cache a regular expression for matching\n * file paths.\n *\n * If the leading character in the `glob` is `!`, a negation\n * regex is returned.\n *\n * @param  {String} `glob`\n * @param  {Object} `options`\n * @return {RegExp}\n */\n\nfunction toRegex(glob, options) {\n  // clone options to prevent  mutating the original object\n  var opts = Object.create(options || {});\n  var flags = opts.flags || '';\n  if (opts.nocase && flags.indexOf('i') === -1) {\n    flags += 'i';\n  }\n  var parsed = expand(glob, opts);\n\n  // pass in tokens to avoid parsing more than once\n  opts.negated = opts.negated || parsed.negated;\n  opts.negate = opts.negated;\n  glob = wrapGlob(parsed.pattern, opts);\n  var re;\n  try {\n    re = new RegExp(glob, flags);\n    return re;\n  } catch (err) {\n    err.reason = 'micromatch invalid regex: (' + re + ')';\n    if (opts.strict) throw new SyntaxError(err);\n  }\n\n  // we're only here if a bad pattern was used and the user\n  // passed `options.silent`, so match nothing\n  return /$^/;\n}\n\n/**\n * Create the regex to do the matching. If the leading\n * character in the `glob` is `!` a negation regex is returned.\n *\n * @param {String} `glob`\n * @param {Boolean} `negate`\n */\n\nfunction wrapGlob(glob, opts) {\n  var prefix = opts && !opts.contains ? '^' : '';\n  var after = opts && !opts.contains ? '$' : '';\n  glob = '(?:' + glob + ')' + after;\n  if (opts && opts.negate) {\n    return prefix + ('(?!^' + glob + ').*$');\n  }\n  return prefix + glob;\n}\n\n/**\n * Create and cache a regular expression for matching file paths.\n * If the leading character in the `glob` is `!`, a negation\n * regex is returned.\n *\n * @param  {String} `glob`\n * @param  {Object} `options`\n * @return {RegExp}\n */\n\nfunction makeRe(glob, opts) {\n  if (utils.typeOf(glob) !== 'string') {\n    throw new Error(msg('makeRe', 'glob', 'a string'));\n  }\n  return utils.cache(toRegex, glob, opts);\n}\n\n/**\n * Make error messages consistent. Follows this format:\n *\n * ```js\n * msg(methodName, argNumber, nativeType);\n * // example:\n * msg('matchKeys', 'first', 'an object');\n * ```\n *\n * @param  {String} `method`\n * @param  {String} `num`\n * @param  {String} `type`\n * @return {String}\n */\n\nfunction msg(method, what, type) {\n  return 'micromatch.' + method + '(): ' + what + ' should be ' + type + '.';\n}\n\n/**\n * Public methods\n */\n\n/* eslint no-multi-spaces: 0 */\nmicromatch.any = any;\nmicromatch.braces = micromatch.braceExpand = utils.braces;\nmicromatch.contains = contains;\nmicromatch.expand = expand;\nmicromatch.filter = filter;\nmicromatch.isMatch = isMatch;\nmicromatch.makeRe = makeRe;\nmicromatch.match = match;\nmicromatch.matcher = matcher;\nmicromatch.matchKeys = matchKeys;\n\n/**\n * Expose `micromatch`\n */\n\nmodule.exports = micromatch;","map":{"version":3,"names":["expand","require","utils","micromatch","files","patterns","opts","cache","Array","isArray","match","len","length","i","omit","keep","glob","charCodeAt","push","apply","slice","diff","pattern","typeOf","Error","msg","arrayify","negate","orig","charAt","nonegate","_isMatch","matcher","res","file","fp","unixify","failglob","nonull","nullglob","unescapeGlob","ignore","nodupes","unique","filter","TypeError","patternMatchers","fn","isMatch","contains","isGlob","indexOf","any","matchKeys","obj","options","key","hasOwnProperty","RegExp","test","matchPath","re","makeRe","matchBase","hasFilename","toRegex","Object","create","flags","nocase","parsed","negated","wrapGlob","err","reason","strict","SyntaxError","prefix","after","method","what","type","braces","braceExpand","module","exports"],"sources":["/home/user/Рабочий стол/pizza/project/node_modules/micromatch/index.js"],"sourcesContent":["/*!\n * micromatch <https://github.com/jonschlinkert/micromatch>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nvar expand = require('./lib/expand');\nvar utils = require('./lib/utils');\n\n/**\n * The main function. Pass an array of filepaths,\n * and a string or array of glob patterns\n *\n * @param  {Array|String} `files`\n * @param  {Array|String} `patterns`\n * @param  {Object} `opts`\n * @return {Array} Array of matches\n */\n\nfunction micromatch(files, patterns, opts) {\n  if (!files || !patterns) return [];\n  opts = opts || {};\n\n  if (typeof opts.cache === 'undefined') {\n    opts.cache = true;\n  }\n\n  if (!Array.isArray(patterns)) {\n    return match(files, patterns, opts);\n  }\n\n  var len = patterns.length, i = 0;\n  var omit = [], keep = [];\n\n  while (len--) {\n    var glob = patterns[i++];\n    if (typeof glob === 'string' && glob.charCodeAt(0) === 33 /* ! */) {\n      omit.push.apply(omit, match(files, glob.slice(1), opts));\n    } else {\n      keep.push.apply(keep, match(files, glob, opts));\n    }\n  }\n  return utils.diff(keep, omit);\n}\n\n/**\n * Return an array of files that match the given glob pattern.\n *\n * This function is called by the main `micromatch` function If you only\n * need to pass a single pattern you might get very minor speed improvements\n * using this function.\n *\n * @param  {Array} `files`\n * @param  {String} `pattern`\n * @param  {Object} `options`\n * @return {Array}\n */\n\nfunction match(files, pattern, opts) {\n  if (utils.typeOf(files) !== 'string' && !Array.isArray(files)) {\n    throw new Error(msg('match', 'files', 'a string or array'));\n  }\n\n  files = utils.arrayify(files);\n  opts = opts || {};\n\n  var negate = opts.negate || false;\n  var orig = pattern;\n\n  if (typeof pattern === 'string') {\n    negate = pattern.charAt(0) === '!';\n    if (negate) {\n      pattern = pattern.slice(1);\n    }\n\n    // we need to remove the character regardless,\n    // so the above logic is still needed\n    if (opts.nonegate === true) {\n      negate = false;\n    }\n  }\n\n  var _isMatch = matcher(pattern, opts);\n  var len = files.length, i = 0;\n  var res = [];\n\n  while (i < len) {\n    var file = files[i++];\n    var fp = utils.unixify(file, opts);\n\n    if (!_isMatch(fp)) { continue; }\n    res.push(fp);\n  }\n\n  if (res.length === 0) {\n    if (opts.failglob === true) {\n      throw new Error('micromatch.match() found no matches for: \"' + orig + '\".');\n    }\n\n    if (opts.nonull || opts.nullglob) {\n      res.push(utils.unescapeGlob(orig));\n    }\n  }\n\n  // if `negate` was defined, diff negated files\n  if (negate) { res = utils.diff(files, res); }\n\n  // if `ignore` was defined, diff ignored filed\n  if (opts.ignore && opts.ignore.length) {\n    pattern = opts.ignore;\n    opts = utils.omit(opts, ['ignore']);\n    res = utils.diff(res, micromatch(res, pattern, opts));\n  }\n\n  if (opts.nodupes) {\n    return utils.unique(res);\n  }\n  return res;\n}\n\n/**\n * Returns a function that takes a glob pattern or array of glob patterns\n * to be used with `Array#filter()`. (Internally this function generates\n * the matching function using the [matcher] method).\n *\n * ```js\n * var fn = mm.filter('[a-c]');\n * ['a', 'b', 'c', 'd', 'e'].filter(fn);\n * //=> ['a', 'b', 'c']\n * ```\n * @param  {String|Array} `patterns` Can be a glob or array of globs.\n * @param  {Options} `opts` Options to pass to the [matcher] method.\n * @return {Function} Filter function to be passed to `Array#filter()`.\n */\n\nfunction filter(patterns, opts) {\n  if (!Array.isArray(patterns) && typeof patterns !== 'string') {\n    throw new TypeError(msg('filter', 'patterns', 'a string or array'));\n  }\n\n  patterns = utils.arrayify(patterns);\n  var len = patterns.length, i = 0;\n  var patternMatchers = Array(len);\n  while (i < len) {\n    patternMatchers[i] = matcher(patterns[i++], opts);\n  }\n\n  return function(fp) {\n    if (fp == null) return [];\n    var len = patternMatchers.length, i = 0;\n    var res = true;\n\n    fp = utils.unixify(fp, opts);\n    while (i < len) {\n      var fn = patternMatchers[i++];\n      if (!fn(fp)) {\n        res = false;\n        break;\n      }\n    }\n    return res;\n  };\n}\n\n/**\n * Returns true if the filepath contains the given\n * pattern. Can also return a function for matching.\n *\n * ```js\n * isMatch('foo.md', '*.md', {});\n * //=> true\n *\n * isMatch('*.md', {})('foo.md')\n * //=> true\n * ```\n * @param  {String} `fp`\n * @param  {String} `pattern`\n * @param  {Object} `opts`\n * @return {Boolean}\n */\n\nfunction isMatch(fp, pattern, opts) {\n  if (typeof fp !== 'string') {\n    throw new TypeError(msg('isMatch', 'filepath', 'a string'));\n  }\n\n  fp = utils.unixify(fp, opts);\n  if (utils.typeOf(pattern) === 'object') {\n    return matcher(fp, pattern);\n  }\n  return matcher(pattern, opts)(fp);\n}\n\n/**\n * Returns true if the filepath matches the\n * given pattern.\n */\n\nfunction contains(fp, pattern, opts) {\n  if (typeof fp !== 'string') {\n    throw new TypeError(msg('contains', 'pattern', 'a string'));\n  }\n\n  opts = opts || {};\n  opts.contains = (pattern !== '');\n  fp = utils.unixify(fp, opts);\n\n  if (opts.contains && !utils.isGlob(pattern)) {\n    return fp.indexOf(pattern) !== -1;\n  }\n  return matcher(pattern, opts)(fp);\n}\n\n/**\n * Returns true if a file path matches any of the\n * given patterns.\n *\n * @param  {String} `fp` The filepath to test.\n * @param  {String|Array} `patterns` Glob patterns to use.\n * @param  {Object} `opts` Options to pass to the `matcher()` function.\n * @return {String}\n */\n\nfunction any(fp, patterns, opts) {\n  if (!Array.isArray(patterns) && typeof patterns !== 'string') {\n    throw new TypeError(msg('any', 'patterns', 'a string or array'));\n  }\n\n  patterns = utils.arrayify(patterns);\n  var len = patterns.length;\n\n  fp = utils.unixify(fp, opts);\n  while (len--) {\n    var isMatch = matcher(patterns[len], opts);\n    if (isMatch(fp)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Filter the keys of an object with the given `glob` pattern\n * and `options`\n *\n * @param  {Object} `object`\n * @param  {Pattern} `object`\n * @return {Array}\n */\n\nfunction matchKeys(obj, glob, options) {\n  if (utils.typeOf(obj) !== 'object') {\n    throw new TypeError(msg('matchKeys', 'first argument', 'an object'));\n  }\n\n  var fn = matcher(glob, options);\n  var res = {};\n\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key) && fn(key)) {\n      res[key] = obj[key];\n    }\n  }\n  return res;\n}\n\n/**\n * Return a function for matching based on the\n * given `pattern` and `options`.\n *\n * @param  {String} `pattern`\n * @param  {Object} `options`\n * @return {Function}\n */\n\nfunction matcher(pattern, opts) {\n  // pattern is a function\n  if (typeof pattern === 'function') {\n    return pattern;\n  }\n  // pattern is a regex\n  if (pattern instanceof RegExp) {\n    return function(fp) {\n      return pattern.test(fp);\n    };\n  }\n\n  if (typeof pattern !== 'string') {\n    throw new TypeError(msg('matcher', 'pattern', 'a string, regex, or function'));\n  }\n\n  // strings, all the way down...\n  pattern = utils.unixify(pattern, opts);\n\n  // pattern is a non-glob string\n  if (!utils.isGlob(pattern)) {\n    return utils.matchPath(pattern, opts);\n  }\n  // pattern is a glob string\n  var re = makeRe(pattern, opts);\n\n  // `matchBase` is defined\n  if (opts && opts.matchBase) {\n    return utils.hasFilename(re, opts);\n  }\n  // `matchBase` is not defined\n  return function(fp) {\n    fp = utils.unixify(fp, opts);\n    return re.test(fp);\n  };\n}\n\n/**\n * Create and cache a regular expression for matching\n * file paths.\n *\n * If the leading character in the `glob` is `!`, a negation\n * regex is returned.\n *\n * @param  {String} `glob`\n * @param  {Object} `options`\n * @return {RegExp}\n */\n\nfunction toRegex(glob, options) {\n  // clone options to prevent  mutating the original object\n  var opts = Object.create(options || {});\n  var flags = opts.flags || '';\n  if (opts.nocase && flags.indexOf('i') === -1) {\n    flags += 'i';\n  }\n\n  var parsed = expand(glob, opts);\n\n  // pass in tokens to avoid parsing more than once\n  opts.negated = opts.negated || parsed.negated;\n  opts.negate = opts.negated;\n  glob = wrapGlob(parsed.pattern, opts);\n  var re;\n\n  try {\n    re = new RegExp(glob, flags);\n    return re;\n  } catch (err) {\n    err.reason = 'micromatch invalid regex: (' + re + ')';\n    if (opts.strict) throw new SyntaxError(err);\n  }\n\n  // we're only here if a bad pattern was used and the user\n  // passed `options.silent`, so match nothing\n  return /$^/;\n}\n\n/**\n * Create the regex to do the matching. If the leading\n * character in the `glob` is `!` a negation regex is returned.\n *\n * @param {String} `glob`\n * @param {Boolean} `negate`\n */\n\nfunction wrapGlob(glob, opts) {\n  var prefix = (opts && !opts.contains) ? '^' : '';\n  var after = (opts && !opts.contains) ? '$' : '';\n  glob = ('(?:' + glob + ')' + after);\n  if (opts && opts.negate) {\n    return prefix + ('(?!^' + glob + ').*$');\n  }\n  return prefix + glob;\n}\n\n/**\n * Create and cache a regular expression for matching file paths.\n * If the leading character in the `glob` is `!`, a negation\n * regex is returned.\n *\n * @param  {String} `glob`\n * @param  {Object} `options`\n * @return {RegExp}\n */\n\nfunction makeRe(glob, opts) {\n  if (utils.typeOf(glob) !== 'string') {\n    throw new Error(msg('makeRe', 'glob', 'a string'));\n  }\n  return utils.cache(toRegex, glob, opts);\n}\n\n/**\n * Make error messages consistent. Follows this format:\n *\n * ```js\n * msg(methodName, argNumber, nativeType);\n * // example:\n * msg('matchKeys', 'first', 'an object');\n * ```\n *\n * @param  {String} `method`\n * @param  {String} `num`\n * @param  {String} `type`\n * @return {String}\n */\n\nfunction msg(method, what, type) {\n  return 'micromatch.' + method + '(): ' + what + ' should be ' + type + '.';\n}\n\n/**\n * Public methods\n */\n\n/* eslint no-multi-spaces: 0 */\nmicromatch.any       = any;\nmicromatch.braces    = micromatch.braceExpand = utils.braces;\nmicromatch.contains  = contains;\nmicromatch.expand    = expand;\nmicromatch.filter    = filter;\nmicromatch.isMatch   = isMatch;\nmicromatch.makeRe    = makeRe;\nmicromatch.match     = match;\nmicromatch.matcher   = matcher;\nmicromatch.matchKeys = matchKeys;\n\n/**\n * Expose `micromatch`\n */\n\nmodule.exports = micromatch;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,IAAIA,MAAM,GAAGC,OAAO,CAAC,cAAc,CAAC;AACpC,IAAIC,KAAK,GAAGD,OAAO,CAAC,aAAa,CAAC;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASE,UAAU,CAACC,KAAK,EAAEC,QAAQ,EAAEC,IAAI,EAAE;EACzC,IAAI,CAACF,KAAK,IAAI,CAACC,QAAQ,EAAE,OAAO,EAAE;EAClCC,IAAI,GAAGA,IAAI,IAAI,CAAC,CAAC;EAEjB,IAAI,OAAOA,IAAI,CAACC,KAAK,KAAK,WAAW,EAAE;IACrCD,IAAI,CAACC,KAAK,GAAG,IAAI;EACnB;EAEA,IAAI,CAACC,KAAK,CAACC,OAAO,CAACJ,QAAQ,CAAC,EAAE;IAC5B,OAAOK,KAAK,CAACN,KAAK,EAAEC,QAAQ,EAAEC,IAAI,CAAC;EACrC;EAEA,IAAIK,GAAG,GAAGN,QAAQ,CAACO,MAAM;IAAEC,CAAC,GAAG,CAAC;EAChC,IAAIC,IAAI,GAAG,EAAE;IAAEC,IAAI,GAAG,EAAE;EAExB,OAAOJ,GAAG,EAAE,EAAE;IACZ,IAAIK,IAAI,GAAGX,QAAQ,CAACQ,CAAC,EAAE,CAAC;IACxB,IAAI,OAAOG,IAAI,KAAK,QAAQ,IAAIA,IAAI,CAACC,UAAU,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC,SAAS;MACjEH,IAAI,CAACI,IAAI,CAACC,KAAK,CAACL,IAAI,EAAEJ,KAAK,CAACN,KAAK,EAAEY,IAAI,CAACI,KAAK,CAAC,CAAC,CAAC,EAAEd,IAAI,CAAC,CAAC;IAC1D,CAAC,MAAM;MACLS,IAAI,CAACG,IAAI,CAACC,KAAK,CAACJ,IAAI,EAAEL,KAAK,CAACN,KAAK,EAAEY,IAAI,EAAEV,IAAI,CAAC,CAAC;IACjD;EACF;EACA,OAAOJ,KAAK,CAACmB,IAAI,CAACN,IAAI,EAAED,IAAI,CAAC;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASJ,KAAK,CAACN,KAAK,EAAEkB,OAAO,EAAEhB,IAAI,EAAE;EACnC,IAAIJ,KAAK,CAACqB,MAAM,CAACnB,KAAK,CAAC,KAAK,QAAQ,IAAI,CAACI,KAAK,CAACC,OAAO,CAACL,KAAK,CAAC,EAAE;IAC7D,MAAM,IAAIoB,KAAK,CAACC,GAAG,CAAC,OAAO,EAAE,OAAO,EAAE,mBAAmB,CAAC,CAAC;EAC7D;EAEArB,KAAK,GAAGF,KAAK,CAACwB,QAAQ,CAACtB,KAAK,CAAC;EAC7BE,IAAI,GAAGA,IAAI,IAAI,CAAC,CAAC;EAEjB,IAAIqB,MAAM,GAAGrB,IAAI,CAACqB,MAAM,IAAI,KAAK;EACjC,IAAIC,IAAI,GAAGN,OAAO;EAElB,IAAI,OAAOA,OAAO,KAAK,QAAQ,EAAE;IAC/BK,MAAM,GAAGL,OAAO,CAACO,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG;IAClC,IAAIF,MAAM,EAAE;MACVL,OAAO,GAAGA,OAAO,CAACF,KAAK,CAAC,CAAC,CAAC;IAC5B;;IAEA;IACA;IACA,IAAId,IAAI,CAACwB,QAAQ,KAAK,IAAI,EAAE;MAC1BH,MAAM,GAAG,KAAK;IAChB;EACF;EAEA,IAAII,QAAQ,GAAGC,OAAO,CAACV,OAAO,EAAEhB,IAAI,CAAC;EACrC,IAAIK,GAAG,GAAGP,KAAK,CAACQ,MAAM;IAAEC,CAAC,GAAG,CAAC;EAC7B,IAAIoB,GAAG,GAAG,EAAE;EAEZ,OAAOpB,CAAC,GAAGF,GAAG,EAAE;IACd,IAAIuB,IAAI,GAAG9B,KAAK,CAACS,CAAC,EAAE,CAAC;IACrB,IAAIsB,EAAE,GAAGjC,KAAK,CAACkC,OAAO,CAACF,IAAI,EAAE5B,IAAI,CAAC;IAElC,IAAI,CAACyB,QAAQ,CAACI,EAAE,CAAC,EAAE;MAAE;IAAU;IAC/BF,GAAG,CAACf,IAAI,CAACiB,EAAE,CAAC;EACd;EAEA,IAAIF,GAAG,CAACrB,MAAM,KAAK,CAAC,EAAE;IACpB,IAAIN,IAAI,CAAC+B,QAAQ,KAAK,IAAI,EAAE;MAC1B,MAAM,IAAIb,KAAK,CAAC,4CAA4C,GAAGI,IAAI,GAAG,IAAI,CAAC;IAC7E;IAEA,IAAItB,IAAI,CAACgC,MAAM,IAAIhC,IAAI,CAACiC,QAAQ,EAAE;MAChCN,GAAG,CAACf,IAAI,CAAChB,KAAK,CAACsC,YAAY,CAACZ,IAAI,CAAC,CAAC;IACpC;EACF;;EAEA;EACA,IAAID,MAAM,EAAE;IAAEM,GAAG,GAAG/B,KAAK,CAACmB,IAAI,CAACjB,KAAK,EAAE6B,GAAG,CAAC;EAAE;;EAE5C;EACA,IAAI3B,IAAI,CAACmC,MAAM,IAAInC,IAAI,CAACmC,MAAM,CAAC7B,MAAM,EAAE;IACrCU,OAAO,GAAGhB,IAAI,CAACmC,MAAM;IACrBnC,IAAI,GAAGJ,KAAK,CAACY,IAAI,CAACR,IAAI,EAAE,CAAC,QAAQ,CAAC,CAAC;IACnC2B,GAAG,GAAG/B,KAAK,CAACmB,IAAI,CAACY,GAAG,EAAE9B,UAAU,CAAC8B,GAAG,EAAEX,OAAO,EAAEhB,IAAI,CAAC,CAAC;EACvD;EAEA,IAAIA,IAAI,CAACoC,OAAO,EAAE;IAChB,OAAOxC,KAAK,CAACyC,MAAM,CAACV,GAAG,CAAC;EAC1B;EACA,OAAOA,GAAG;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASW,MAAM,CAACvC,QAAQ,EAAEC,IAAI,EAAE;EAC9B,IAAI,CAACE,KAAK,CAACC,OAAO,CAACJ,QAAQ,CAAC,IAAI,OAAOA,QAAQ,KAAK,QAAQ,EAAE;IAC5D,MAAM,IAAIwC,SAAS,CAACpB,GAAG,CAAC,QAAQ,EAAE,UAAU,EAAE,mBAAmB,CAAC,CAAC;EACrE;EAEApB,QAAQ,GAAGH,KAAK,CAACwB,QAAQ,CAACrB,QAAQ,CAAC;EACnC,IAAIM,GAAG,GAAGN,QAAQ,CAACO,MAAM;IAAEC,CAAC,GAAG,CAAC;EAChC,IAAIiC,eAAe,GAAGtC,KAAK,CAACG,GAAG,CAAC;EAChC,OAAOE,CAAC,GAAGF,GAAG,EAAE;IACdmC,eAAe,CAACjC,CAAC,CAAC,GAAGmB,OAAO,CAAC3B,QAAQ,CAACQ,CAAC,EAAE,CAAC,EAAEP,IAAI,CAAC;EACnD;EAEA,OAAO,UAAS6B,EAAE,EAAE;IAClB,IAAIA,EAAE,IAAI,IAAI,EAAE,OAAO,EAAE;IACzB,IAAIxB,GAAG,GAAGmC,eAAe,CAAClC,MAAM;MAAEC,CAAC,GAAG,CAAC;IACvC,IAAIoB,GAAG,GAAG,IAAI;IAEdE,EAAE,GAAGjC,KAAK,CAACkC,OAAO,CAACD,EAAE,EAAE7B,IAAI,CAAC;IAC5B,OAAOO,CAAC,GAAGF,GAAG,EAAE;MACd,IAAIoC,EAAE,GAAGD,eAAe,CAACjC,CAAC,EAAE,CAAC;MAC7B,IAAI,CAACkC,EAAE,CAACZ,EAAE,CAAC,EAAE;QACXF,GAAG,GAAG,KAAK;QACX;MACF;IACF;IACA,OAAOA,GAAG;EACZ,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASe,OAAO,CAACb,EAAE,EAAEb,OAAO,EAAEhB,IAAI,EAAE;EAClC,IAAI,OAAO6B,EAAE,KAAK,QAAQ,EAAE;IAC1B,MAAM,IAAIU,SAAS,CAACpB,GAAG,CAAC,SAAS,EAAE,UAAU,EAAE,UAAU,CAAC,CAAC;EAC7D;EAEAU,EAAE,GAAGjC,KAAK,CAACkC,OAAO,CAACD,EAAE,EAAE7B,IAAI,CAAC;EAC5B,IAAIJ,KAAK,CAACqB,MAAM,CAACD,OAAO,CAAC,KAAK,QAAQ,EAAE;IACtC,OAAOU,OAAO,CAACG,EAAE,EAAEb,OAAO,CAAC;EAC7B;EACA,OAAOU,OAAO,CAACV,OAAO,EAAEhB,IAAI,CAAC,CAAC6B,EAAE,CAAC;AACnC;;AAEA;AACA;AACA;AACA;;AAEA,SAASc,QAAQ,CAACd,EAAE,EAAEb,OAAO,EAAEhB,IAAI,EAAE;EACnC,IAAI,OAAO6B,EAAE,KAAK,QAAQ,EAAE;IAC1B,MAAM,IAAIU,SAAS,CAACpB,GAAG,CAAC,UAAU,EAAE,SAAS,EAAE,UAAU,CAAC,CAAC;EAC7D;EAEAnB,IAAI,GAAGA,IAAI,IAAI,CAAC,CAAC;EACjBA,IAAI,CAAC2C,QAAQ,GAAI3B,OAAO,KAAK,EAAG;EAChCa,EAAE,GAAGjC,KAAK,CAACkC,OAAO,CAACD,EAAE,EAAE7B,IAAI,CAAC;EAE5B,IAAIA,IAAI,CAAC2C,QAAQ,IAAI,CAAC/C,KAAK,CAACgD,MAAM,CAAC5B,OAAO,CAAC,EAAE;IAC3C,OAAOa,EAAE,CAACgB,OAAO,CAAC7B,OAAO,CAAC,KAAK,CAAC,CAAC;EACnC;EACA,OAAOU,OAAO,CAACV,OAAO,EAAEhB,IAAI,CAAC,CAAC6B,EAAE,CAAC;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASiB,GAAG,CAACjB,EAAE,EAAE9B,QAAQ,EAAEC,IAAI,EAAE;EAC/B,IAAI,CAACE,KAAK,CAACC,OAAO,CAACJ,QAAQ,CAAC,IAAI,OAAOA,QAAQ,KAAK,QAAQ,EAAE;IAC5D,MAAM,IAAIwC,SAAS,CAACpB,GAAG,CAAC,KAAK,EAAE,UAAU,EAAE,mBAAmB,CAAC,CAAC;EAClE;EAEApB,QAAQ,GAAGH,KAAK,CAACwB,QAAQ,CAACrB,QAAQ,CAAC;EACnC,IAAIM,GAAG,GAAGN,QAAQ,CAACO,MAAM;EAEzBuB,EAAE,GAAGjC,KAAK,CAACkC,OAAO,CAACD,EAAE,EAAE7B,IAAI,CAAC;EAC5B,OAAOK,GAAG,EAAE,EAAE;IACZ,IAAIqC,OAAO,GAAGhB,OAAO,CAAC3B,QAAQ,CAACM,GAAG,CAAC,EAAEL,IAAI,CAAC;IAC1C,IAAI0C,OAAO,CAACb,EAAE,CAAC,EAAE;MACf,OAAO,IAAI;IACb;EACF;EACA,OAAO,KAAK;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASkB,SAAS,CAACC,GAAG,EAAEtC,IAAI,EAAEuC,OAAO,EAAE;EACrC,IAAIrD,KAAK,CAACqB,MAAM,CAAC+B,GAAG,CAAC,KAAK,QAAQ,EAAE;IAClC,MAAM,IAAIT,SAAS,CAACpB,GAAG,CAAC,WAAW,EAAE,gBAAgB,EAAE,WAAW,CAAC,CAAC;EACtE;EAEA,IAAIsB,EAAE,GAAGf,OAAO,CAAChB,IAAI,EAAEuC,OAAO,CAAC;EAC/B,IAAItB,GAAG,GAAG,CAAC,CAAC;EAEZ,KAAK,IAAIuB,GAAG,IAAIF,GAAG,EAAE;IACnB,IAAIA,GAAG,CAACG,cAAc,CAACD,GAAG,CAAC,IAAIT,EAAE,CAACS,GAAG,CAAC,EAAE;MACtCvB,GAAG,CAACuB,GAAG,CAAC,GAAGF,GAAG,CAACE,GAAG,CAAC;IACrB;EACF;EACA,OAAOvB,GAAG;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASD,OAAO,CAACV,OAAO,EAAEhB,IAAI,EAAE;EAC9B;EACA,IAAI,OAAOgB,OAAO,KAAK,UAAU,EAAE;IACjC,OAAOA,OAAO;EAChB;EACA;EACA,IAAIA,OAAO,YAAYoC,MAAM,EAAE;IAC7B,OAAO,UAASvB,EAAE,EAAE;MAClB,OAAOb,OAAO,CAACqC,IAAI,CAACxB,EAAE,CAAC;IACzB,CAAC;EACH;EAEA,IAAI,OAAOb,OAAO,KAAK,QAAQ,EAAE;IAC/B,MAAM,IAAIuB,SAAS,CAACpB,GAAG,CAAC,SAAS,EAAE,SAAS,EAAE,8BAA8B,CAAC,CAAC;EAChF;;EAEA;EACAH,OAAO,GAAGpB,KAAK,CAACkC,OAAO,CAACd,OAAO,EAAEhB,IAAI,CAAC;;EAEtC;EACA,IAAI,CAACJ,KAAK,CAACgD,MAAM,CAAC5B,OAAO,CAAC,EAAE;IAC1B,OAAOpB,KAAK,CAAC0D,SAAS,CAACtC,OAAO,EAAEhB,IAAI,CAAC;EACvC;EACA;EACA,IAAIuD,EAAE,GAAGC,MAAM,CAACxC,OAAO,EAAEhB,IAAI,CAAC;;EAE9B;EACA,IAAIA,IAAI,IAAIA,IAAI,CAACyD,SAAS,EAAE;IAC1B,OAAO7D,KAAK,CAAC8D,WAAW,CAACH,EAAE,EAAEvD,IAAI,CAAC;EACpC;EACA;EACA,OAAO,UAAS6B,EAAE,EAAE;IAClBA,EAAE,GAAGjC,KAAK,CAACkC,OAAO,CAACD,EAAE,EAAE7B,IAAI,CAAC;IAC5B,OAAOuD,EAAE,CAACF,IAAI,CAACxB,EAAE,CAAC;EACpB,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS8B,OAAO,CAACjD,IAAI,EAAEuC,OAAO,EAAE;EAC9B;EACA,IAAIjD,IAAI,GAAG4D,MAAM,CAACC,MAAM,CAACZ,OAAO,IAAI,CAAC,CAAC,CAAC;EACvC,IAAIa,KAAK,GAAG9D,IAAI,CAAC8D,KAAK,IAAI,EAAE;EAC5B,IAAI9D,IAAI,CAAC+D,MAAM,IAAID,KAAK,CAACjB,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE;IAC5CiB,KAAK,IAAI,GAAG;EACd;EAEA,IAAIE,MAAM,GAAGtE,MAAM,CAACgB,IAAI,EAAEV,IAAI,CAAC;;EAE/B;EACAA,IAAI,CAACiE,OAAO,GAAGjE,IAAI,CAACiE,OAAO,IAAID,MAAM,CAACC,OAAO;EAC7CjE,IAAI,CAACqB,MAAM,GAAGrB,IAAI,CAACiE,OAAO;EAC1BvD,IAAI,GAAGwD,QAAQ,CAACF,MAAM,CAAChD,OAAO,EAAEhB,IAAI,CAAC;EACrC,IAAIuD,EAAE;EAEN,IAAI;IACFA,EAAE,GAAG,IAAIH,MAAM,CAAC1C,IAAI,EAAEoD,KAAK,CAAC;IAC5B,OAAOP,EAAE;EACX,CAAC,CAAC,OAAOY,GAAG,EAAE;IACZA,GAAG,CAACC,MAAM,GAAG,6BAA6B,GAAGb,EAAE,GAAG,GAAG;IACrD,IAAIvD,IAAI,CAACqE,MAAM,EAAE,MAAM,IAAIC,WAAW,CAACH,GAAG,CAAC;EAC7C;;EAEA;EACA;EACA,OAAO,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASD,QAAQ,CAACxD,IAAI,EAAEV,IAAI,EAAE;EAC5B,IAAIuE,MAAM,GAAIvE,IAAI,IAAI,CAACA,IAAI,CAAC2C,QAAQ,GAAI,GAAG,GAAG,EAAE;EAChD,IAAI6B,KAAK,GAAIxE,IAAI,IAAI,CAACA,IAAI,CAAC2C,QAAQ,GAAI,GAAG,GAAG,EAAE;EAC/CjC,IAAI,GAAI,KAAK,GAAGA,IAAI,GAAG,GAAG,GAAG8D,KAAM;EACnC,IAAIxE,IAAI,IAAIA,IAAI,CAACqB,MAAM,EAAE;IACvB,OAAOkD,MAAM,IAAI,MAAM,GAAG7D,IAAI,GAAG,MAAM,CAAC;EAC1C;EACA,OAAO6D,MAAM,GAAG7D,IAAI;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS8C,MAAM,CAAC9C,IAAI,EAAEV,IAAI,EAAE;EAC1B,IAAIJ,KAAK,CAACqB,MAAM,CAACP,IAAI,CAAC,KAAK,QAAQ,EAAE;IACnC,MAAM,IAAIQ,KAAK,CAACC,GAAG,CAAC,QAAQ,EAAE,MAAM,EAAE,UAAU,CAAC,CAAC;EACpD;EACA,OAAOvB,KAAK,CAACK,KAAK,CAAC0D,OAAO,EAAEjD,IAAI,EAAEV,IAAI,CAAC;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASmB,GAAG,CAACsD,MAAM,EAAEC,IAAI,EAAEC,IAAI,EAAE;EAC/B,OAAO,aAAa,GAAGF,MAAM,GAAG,MAAM,GAAGC,IAAI,GAAG,aAAa,GAAGC,IAAI,GAAG,GAAG;AAC5E;;AAEA;AACA;AACA;;AAEA;AACA9E,UAAU,CAACiD,GAAG,GAASA,GAAG;AAC1BjD,UAAU,CAAC+E,MAAM,GAAM/E,UAAU,CAACgF,WAAW,GAAGjF,KAAK,CAACgF,MAAM;AAC5D/E,UAAU,CAAC8C,QAAQ,GAAIA,QAAQ;AAC/B9C,UAAU,CAACH,MAAM,GAAMA,MAAM;AAC7BG,UAAU,CAACyC,MAAM,GAAMA,MAAM;AAC7BzC,UAAU,CAAC6C,OAAO,GAAKA,OAAO;AAC9B7C,UAAU,CAAC2D,MAAM,GAAMA,MAAM;AAC7B3D,UAAU,CAACO,KAAK,GAAOA,KAAK;AAC5BP,UAAU,CAAC6B,OAAO,GAAKA,OAAO;AAC9B7B,UAAU,CAACkD,SAAS,GAAGA,SAAS;;AAEhC;AACA;AACA;;AAEA+B,MAAM,CAACC,OAAO,GAAGlF,UAAU"},"metadata":{},"sourceType":"script"}