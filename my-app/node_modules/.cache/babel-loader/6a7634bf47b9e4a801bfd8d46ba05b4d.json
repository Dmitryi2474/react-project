{"ast":null,"code":"/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\n'use strict';\n\nconst safeBuffer = require('safe-buffer');\nconst PerMessageDeflate = require('./PerMessageDeflate');\nconst isValidUTF8 = require('./Validation');\nconst bufferUtil = require('./BufferUtil');\nconst ErrorCodes = require('./ErrorCodes');\nconst constants = require('./Constants');\nconst Buffer = safeBuffer.Buffer;\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\n\n/**\n * HyBi Receiver implementation.\n */\nclass Receiver {\n  /**\n   * Creates a Receiver instance.\n   *\n   * @param {Object} extensions An object containing the negotiated extensions\n   * @param {Number} maxPayload The maximum allowed message length\n   * @param {String} binaryType The type for binary data\n   */\n  constructor(extensions, maxPayload, binaryType) {\n    this._binaryType = binaryType || constants.BINARY_TYPES[0];\n    this._extensions = extensions || {};\n    this._maxPayload = maxPayload | 0;\n    this._bufferedBytes = 0;\n    this._buffers = [];\n    this._compressed = false;\n    this._payloadLength = 0;\n    this._fragmented = 0;\n    this._masked = false;\n    this._fin = false;\n    this._mask = null;\n    this._opcode = 0;\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragments = [];\n    this._cleanupCallback = null;\n    this._hadError = false;\n    this._dead = false;\n    this._loop = false;\n    this.onmessage = null;\n    this.onclose = null;\n    this.onerror = null;\n    this.onping = null;\n    this.onpong = null;\n    this._state = GET_INFO;\n  }\n\n  /**\n   * Consumes bytes from the available buffered data.\n   *\n   * @param {Number} bytes The number of bytes to consume\n   * @return {Buffer} Consumed bytes\n   * @private\n   */\n  readBuffer(bytes) {\n    var offset = 0;\n    var dst;\n    var l;\n    this._bufferedBytes -= bytes;\n    if (bytes === this._buffers[0].length) return this._buffers.shift();\n    if (bytes < this._buffers[0].length) {\n      dst = this._buffers[0].slice(0, bytes);\n      this._buffers[0] = this._buffers[0].slice(bytes);\n      return dst;\n    }\n    dst = Buffer.allocUnsafe(bytes);\n    while (bytes > 0) {\n      l = this._buffers[0].length;\n      if (bytes >= l) {\n        this._buffers[0].copy(dst, offset);\n        offset += l;\n        this._buffers.shift();\n      } else {\n        this._buffers[0].copy(dst, offset, 0, bytes);\n        this._buffers[0] = this._buffers[0].slice(bytes);\n      }\n      bytes -= l;\n    }\n    return dst;\n  }\n\n  /**\n   * Checks if the number of buffered bytes is bigger or equal than `n` and\n   * calls `cleanup` if necessary.\n   *\n   * @param {Number} n The number of bytes to check against\n   * @return {Boolean} `true` if `bufferedBytes >= n`, else `false`\n   * @private\n   */\n  hasBufferedBytes(n) {\n    if (this._bufferedBytes >= n) return true;\n    this._loop = false;\n    if (this._dead) this.cleanup(this._cleanupCallback);\n    return false;\n  }\n\n  /**\n   * Adds new data to the parser.\n   *\n   * @public\n   */\n  add(data) {\n    if (this._dead) return;\n    this._bufferedBytes += data.length;\n    this._buffers.push(data);\n    this.startLoop();\n  }\n\n  /**\n   * Starts the parsing loop.\n   *\n   * @private\n   */\n  startLoop() {\n    this._loop = true;\n    while (this._loop) {\n      switch (this._state) {\n        case GET_INFO:\n          this.getInfo();\n          break;\n        case GET_PAYLOAD_LENGTH_16:\n          this.getPayloadLength16();\n          break;\n        case GET_PAYLOAD_LENGTH_64:\n          this.getPayloadLength64();\n          break;\n        case GET_MASK:\n          this.getMask();\n          break;\n        case GET_DATA:\n          this.getData();\n          break;\n        default:\n          // `INFLATING`\n          this._loop = false;\n      }\n    }\n  }\n\n  /**\n   * Reads the first two bytes of a frame.\n   *\n   * @private\n   */\n  getInfo() {\n    if (!this.hasBufferedBytes(2)) return;\n    const buf = this.readBuffer(2);\n    if ((buf[0] & 0x30) !== 0x00) {\n      this.error(new Error('RSV2 and RSV3 must be clear'), 1002);\n      return;\n    }\n    const compressed = (buf[0] & 0x40) === 0x40;\n    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n      this.error(new Error('RSV1 must be clear'), 1002);\n      return;\n    }\n    this._fin = (buf[0] & 0x80) === 0x80;\n    this._opcode = buf[0] & 0x0f;\n    this._payloadLength = buf[1] & 0x7f;\n    if (this._opcode === 0x00) {\n      if (compressed) {\n        this.error(new Error('RSV1 must be clear'), 1002);\n        return;\n      }\n      if (!this._fragmented) {\n        this.error(new Error(`invalid opcode: ${this._opcode}`), 1002);\n        return;\n      } else {\n        this._opcode = this._fragmented;\n      }\n    } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n      if (this._fragmented) {\n        this.error(new Error(`invalid opcode: ${this._opcode}`), 1002);\n        return;\n      }\n      this._compressed = compressed;\n    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n      if (!this._fin) {\n        this.error(new Error('FIN must be set'), 1002);\n        return;\n      }\n      if (compressed) {\n        this.error(new Error('RSV1 must be clear'), 1002);\n        return;\n      }\n      if (this._payloadLength > 0x7d) {\n        this.error(new Error('invalid payload length'), 1002);\n        return;\n      }\n    } else {\n      this.error(new Error(`invalid opcode: ${this._opcode}`), 1002);\n      return;\n    }\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n    this._masked = (buf[1] & 0x80) === 0x80;\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;else this.haveLength();\n  }\n\n  /**\n   * Gets extended payload length (7+16).\n   *\n   * @private\n   */\n  getPayloadLength16() {\n    if (!this.hasBufferedBytes(2)) return;\n    this._payloadLength = this.readBuffer(2).readUInt16BE(0, true);\n    this.haveLength();\n  }\n\n  /**\n   * Gets extended payload length (7+64).\n   *\n   * @private\n   */\n  getPayloadLength64() {\n    if (!this.hasBufferedBytes(8)) return;\n    const buf = this.readBuffer(8);\n    const num = buf.readUInt32BE(0, true);\n\n    //\n    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n    // if payload length is greater than this number.\n    //\n    if (num > Math.pow(2, 53 - 32) - 1) {\n      this.error(new Error('max payload size exceeded'), 1009);\n      return;\n    }\n    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4, true);\n    this.haveLength();\n  }\n\n  /**\n   * Payload length has been read.\n   *\n   * @private\n   */\n  haveLength() {\n    if (this._opcode < 0x08 && this.maxPayloadExceeded(this._payloadLength)) {\n      return;\n    }\n    if (this._masked) this._state = GET_MASK;else this._state = GET_DATA;\n  }\n\n  /**\n   * Reads mask bytes.\n   *\n   * @private\n   */\n  getMask() {\n    if (!this.hasBufferedBytes(4)) return;\n    this._mask = this.readBuffer(4);\n    this._state = GET_DATA;\n  }\n\n  /**\n   * Reads data bytes.\n   *\n   * @private\n   */\n  getData() {\n    var data = constants.EMPTY_BUFFER;\n    if (this._payloadLength) {\n      if (!this.hasBufferedBytes(this._payloadLength)) return;\n      data = this.readBuffer(this._payloadLength);\n      if (this._masked) bufferUtil.unmask(data, this._mask);\n    }\n    if (this._opcode > 0x07) {\n      this.controlMessage(data);\n    } else if (this._compressed) {\n      this._state = INFLATING;\n      this.decompress(data);\n    } else if (this.pushFragment(data)) {\n      this.dataMessage();\n    }\n  }\n\n  /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @private\n   */\n  decompress(data) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n      if (err) {\n        this.error(err, err.closeCode === 1009 ? 1009 : 1007);\n        return;\n      }\n      if (this.pushFragment(buf)) this.dataMessage();\n      this.startLoop();\n    });\n  }\n\n  /**\n   * Handles a data message.\n   *\n   * @private\n   */\n  dataMessage() {\n    if (this._fin) {\n      const messageLength = this._messageLength;\n      const fragments = this._fragments;\n      this._totalPayloadLength = 0;\n      this._messageLength = 0;\n      this._fragmented = 0;\n      this._fragments = [];\n      if (this._opcode === 2) {\n        var data;\n        if (this._binaryType === 'nodebuffer') {\n          data = toBuffer(fragments, messageLength);\n        } else if (this._binaryType === 'arraybuffer') {\n          data = toArrayBuffer(toBuffer(fragments, messageLength));\n        } else {\n          data = fragments;\n        }\n        this.onmessage(data);\n      } else {\n        const buf = toBuffer(fragments, messageLength);\n        if (!isValidUTF8(buf)) {\n          this.error(new Error('invalid utf8 sequence'), 1007);\n          return;\n        }\n        this.onmessage(buf.toString());\n      }\n    }\n    this._state = GET_INFO;\n  }\n\n  /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @private\n   */\n  controlMessage(data) {\n    if (this._opcode === 0x08) {\n      if (data.length === 0) {\n        this.onclose(1000, '');\n        this._loop = false;\n        this.cleanup(this._cleanupCallback);\n      } else if (data.length === 1) {\n        this.error(new Error('invalid payload length'), 1002);\n      } else {\n        const code = data.readUInt16BE(0, true);\n        if (!ErrorCodes.isValidErrorCode(code)) {\n          this.error(new Error(`invalid status code: ${code}`), 1002);\n          return;\n        }\n        const buf = data.slice(2);\n        if (!isValidUTF8(buf)) {\n          this.error(new Error('invalid utf8 sequence'), 1007);\n          return;\n        }\n        this.onclose(code, buf.toString());\n        this._loop = false;\n        this.cleanup(this._cleanupCallback);\n      }\n      return;\n    }\n    if (this._opcode === 0x09) this.onping(data);else this.onpong(data);\n    this._state = GET_INFO;\n  }\n\n  /**\n   * Handles an error.\n   *\n   * @param {Error} err The error\n   * @param {Number} code Close code\n   * @private\n   */\n  error(err, code) {\n    this.onerror(err, code);\n    this._hadError = true;\n    this._loop = false;\n    this.cleanup(this._cleanupCallback);\n  }\n\n  /**\n   * Checks payload size, disconnects socket when it exceeds `maxPayload`.\n   *\n   * @param {Number} length Payload length\n   * @private\n   */\n  maxPayloadExceeded(length) {\n    if (length === 0 || this._maxPayload < 1) return false;\n    const fullLength = this._totalPayloadLength + length;\n    if (fullLength <= this._maxPayload) {\n      this._totalPayloadLength = fullLength;\n      return false;\n    }\n    this.error(new Error('max payload size exceeded'), 1009);\n    return true;\n  }\n\n  /**\n   * Appends a fragment in the fragments array after checking that the sum of\n   * fragment lengths does not exceed `maxPayload`.\n   *\n   * @param {Buffer} fragment The fragment to add\n   * @return {Boolean} `true` if `maxPayload` is not exceeded, else `false`\n   * @private\n   */\n  pushFragment(fragment) {\n    if (fragment.length === 0) return true;\n    const totalLength = this._messageLength + fragment.length;\n    if (this._maxPayload < 1 || totalLength <= this._maxPayload) {\n      this._messageLength = totalLength;\n      this._fragments.push(fragment);\n      return true;\n    }\n    this.error(new Error('max payload size exceeded'), 1009);\n    return false;\n  }\n\n  /**\n   * Releases resources used by the receiver.\n   *\n   * @param {Function} cb Callback\n   * @public\n   */\n  cleanup(cb) {\n    this._dead = true;\n    if (!this._hadError && (this._loop || this._state === INFLATING)) {\n      this._cleanupCallback = cb;\n    } else {\n      this._extensions = null;\n      this._fragments = null;\n      this._buffers = null;\n      this._mask = null;\n      this._cleanupCallback = null;\n      this.onmessage = null;\n      this.onclose = null;\n      this.onerror = null;\n      this.onping = null;\n      this.onpong = null;\n      if (cb) cb();\n    }\n  }\n}\nmodule.exports = Receiver;\n\n/**\n * Makes a buffer from a list of fragments.\n *\n * @param {Buffer[]} fragments The list of fragments composing the message\n * @param {Number} messageLength The length of the message\n * @return {Buffer}\n * @private\n */\nfunction toBuffer(fragments, messageLength) {\n  if (fragments.length === 1) return fragments[0];\n  if (fragments.length > 1) return bufferUtil.concat(fragments, messageLength);\n  return constants.EMPTY_BUFFER;\n}\n\n/**\n * Converts a buffer to an `ArrayBuffer`.\n *\n * @param {Buffer} The buffer to convert\n * @return {ArrayBuffer} Converted buffer\n */\nfunction toArrayBuffer(buf) {\n  if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {\n    return buf.buffer;\n  }\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n}","map":{"version":3,"names":["safeBuffer","require","PerMessageDeflate","isValidUTF8","bufferUtil","ErrorCodes","constants","Buffer","GET_INFO","GET_PAYLOAD_LENGTH_16","GET_PAYLOAD_LENGTH_64","GET_MASK","GET_DATA","INFLATING","Receiver","constructor","extensions","maxPayload","binaryType","_binaryType","BINARY_TYPES","_extensions","_maxPayload","_bufferedBytes","_buffers","_compressed","_payloadLength","_fragmented","_masked","_fin","_mask","_opcode","_totalPayloadLength","_messageLength","_fragments","_cleanupCallback","_hadError","_dead","_loop","onmessage","onclose","onerror","onping","onpong","_state","readBuffer","bytes","offset","dst","l","length","shift","slice","allocUnsafe","copy","hasBufferedBytes","n","cleanup","add","data","push","startLoop","getInfo","getPayloadLength16","getPayloadLength64","getMask","getData","buf","error","Error","compressed","extensionName","haveLength","readUInt16BE","num","readUInt32BE","Math","pow","maxPayloadExceeded","EMPTY_BUFFER","unmask","controlMessage","decompress","pushFragment","dataMessage","perMessageDeflate","err","closeCode","messageLength","fragments","toBuffer","toArrayBuffer","toString","code","isValidErrorCode","fullLength","fragment","totalLength","cb","module","exports","concat","byteOffset","byteLength","buffer"],"sources":["/home/user/Рабочий стол/pizza/project/node_modules/ws/lib/Receiver.js"],"sourcesContent":["/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\n'use strict';\n\nconst safeBuffer = require('safe-buffer');\n\nconst PerMessageDeflate = require('./PerMessageDeflate');\nconst isValidUTF8 = require('./Validation');\nconst bufferUtil = require('./BufferUtil');\nconst ErrorCodes = require('./ErrorCodes');\nconst constants = require('./Constants');\n\nconst Buffer = safeBuffer.Buffer;\n\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\n\n/**\n * HyBi Receiver implementation.\n */\nclass Receiver {\n  /**\n   * Creates a Receiver instance.\n   *\n   * @param {Object} extensions An object containing the negotiated extensions\n   * @param {Number} maxPayload The maximum allowed message length\n   * @param {String} binaryType The type for binary data\n   */\n  constructor (extensions, maxPayload, binaryType) {\n    this._binaryType = binaryType || constants.BINARY_TYPES[0];\n    this._extensions = extensions || {};\n    this._maxPayload = maxPayload | 0;\n\n    this._bufferedBytes = 0;\n    this._buffers = [];\n\n    this._compressed = false;\n    this._payloadLength = 0;\n    this._fragmented = 0;\n    this._masked = false;\n    this._fin = false;\n    this._mask = null;\n    this._opcode = 0;\n\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragments = [];\n\n    this._cleanupCallback = null;\n    this._hadError = false;\n    this._dead = false;\n    this._loop = false;\n\n    this.onmessage = null;\n    this.onclose = null;\n    this.onerror = null;\n    this.onping = null;\n    this.onpong = null;\n\n    this._state = GET_INFO;\n  }\n\n  /**\n   * Consumes bytes from the available buffered data.\n   *\n   * @param {Number} bytes The number of bytes to consume\n   * @return {Buffer} Consumed bytes\n   * @private\n   */\n  readBuffer (bytes) {\n    var offset = 0;\n    var dst;\n    var l;\n\n    this._bufferedBytes -= bytes;\n\n    if (bytes === this._buffers[0].length) return this._buffers.shift();\n\n    if (bytes < this._buffers[0].length) {\n      dst = this._buffers[0].slice(0, bytes);\n      this._buffers[0] = this._buffers[0].slice(bytes);\n      return dst;\n    }\n\n    dst = Buffer.allocUnsafe(bytes);\n\n    while (bytes > 0) {\n      l = this._buffers[0].length;\n\n      if (bytes >= l) {\n        this._buffers[0].copy(dst, offset);\n        offset += l;\n        this._buffers.shift();\n      } else {\n        this._buffers[0].copy(dst, offset, 0, bytes);\n        this._buffers[0] = this._buffers[0].slice(bytes);\n      }\n\n      bytes -= l;\n    }\n\n    return dst;\n  }\n\n  /**\n   * Checks if the number of buffered bytes is bigger or equal than `n` and\n   * calls `cleanup` if necessary.\n   *\n   * @param {Number} n The number of bytes to check against\n   * @return {Boolean} `true` if `bufferedBytes >= n`, else `false`\n   * @private\n   */\n  hasBufferedBytes (n) {\n    if (this._bufferedBytes >= n) return true;\n\n    this._loop = false;\n    if (this._dead) this.cleanup(this._cleanupCallback);\n    return false;\n  }\n\n  /**\n   * Adds new data to the parser.\n   *\n   * @public\n   */\n  add (data) {\n    if (this._dead) return;\n\n    this._bufferedBytes += data.length;\n    this._buffers.push(data);\n    this.startLoop();\n  }\n\n  /**\n   * Starts the parsing loop.\n   *\n   * @private\n   */\n  startLoop () {\n    this._loop = true;\n\n    while (this._loop) {\n      switch (this._state) {\n        case GET_INFO:\n          this.getInfo();\n          break;\n        case GET_PAYLOAD_LENGTH_16:\n          this.getPayloadLength16();\n          break;\n        case GET_PAYLOAD_LENGTH_64:\n          this.getPayloadLength64();\n          break;\n        case GET_MASK:\n          this.getMask();\n          break;\n        case GET_DATA:\n          this.getData();\n          break;\n        default: // `INFLATING`\n          this._loop = false;\n      }\n    }\n  }\n\n  /**\n   * Reads the first two bytes of a frame.\n   *\n   * @private\n   */\n  getInfo () {\n    if (!this.hasBufferedBytes(2)) return;\n\n    const buf = this.readBuffer(2);\n\n    if ((buf[0] & 0x30) !== 0x00) {\n      this.error(new Error('RSV2 and RSV3 must be clear'), 1002);\n      return;\n    }\n\n    const compressed = (buf[0] & 0x40) === 0x40;\n\n    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n      this.error(new Error('RSV1 must be clear'), 1002);\n      return;\n    }\n\n    this._fin = (buf[0] & 0x80) === 0x80;\n    this._opcode = buf[0] & 0x0f;\n    this._payloadLength = buf[1] & 0x7f;\n\n    if (this._opcode === 0x00) {\n      if (compressed) {\n        this.error(new Error('RSV1 must be clear'), 1002);\n        return;\n      }\n\n      if (!this._fragmented) {\n        this.error(new Error(`invalid opcode: ${this._opcode}`), 1002);\n        return;\n      } else {\n        this._opcode = this._fragmented;\n      }\n    } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n      if (this._fragmented) {\n        this.error(new Error(`invalid opcode: ${this._opcode}`), 1002);\n        return;\n      }\n\n      this._compressed = compressed;\n    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n      if (!this._fin) {\n        this.error(new Error('FIN must be set'), 1002);\n        return;\n      }\n\n      if (compressed) {\n        this.error(new Error('RSV1 must be clear'), 1002);\n        return;\n      }\n\n      if (this._payloadLength > 0x7d) {\n        this.error(new Error('invalid payload length'), 1002);\n        return;\n      }\n    } else {\n      this.error(new Error(`invalid opcode: ${this._opcode}`), 1002);\n      return;\n    }\n\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n\n    this._masked = (buf[1] & 0x80) === 0x80;\n\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\n    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\n    else this.haveLength();\n  }\n\n  /**\n   * Gets extended payload length (7+16).\n   *\n   * @private\n   */\n  getPayloadLength16 () {\n    if (!this.hasBufferedBytes(2)) return;\n\n    this._payloadLength = this.readBuffer(2).readUInt16BE(0, true);\n    this.haveLength();\n  }\n\n  /**\n   * Gets extended payload length (7+64).\n   *\n   * @private\n   */\n  getPayloadLength64 () {\n    if (!this.hasBufferedBytes(8)) return;\n\n    const buf = this.readBuffer(8);\n    const num = buf.readUInt32BE(0, true);\n\n    //\n    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n    // if payload length is greater than this number.\n    //\n    if (num > Math.pow(2, 53 - 32) - 1) {\n      this.error(new Error('max payload size exceeded'), 1009);\n      return;\n    }\n\n    this._payloadLength = (num * Math.pow(2, 32)) + buf.readUInt32BE(4, true);\n    this.haveLength();\n  }\n\n  /**\n   * Payload length has been read.\n   *\n   * @private\n   */\n  haveLength () {\n    if (this._opcode < 0x08 && this.maxPayloadExceeded(this._payloadLength)) {\n      return;\n    }\n\n    if (this._masked) this._state = GET_MASK;\n    else this._state = GET_DATA;\n  }\n\n  /**\n   * Reads mask bytes.\n   *\n   * @private\n   */\n  getMask () {\n    if (!this.hasBufferedBytes(4)) return;\n\n    this._mask = this.readBuffer(4);\n    this._state = GET_DATA;\n  }\n\n  /**\n   * Reads data bytes.\n   *\n   * @private\n   */\n  getData () {\n    var data = constants.EMPTY_BUFFER;\n\n    if (this._payloadLength) {\n      if (!this.hasBufferedBytes(this._payloadLength)) return;\n\n      data = this.readBuffer(this._payloadLength);\n      if (this._masked) bufferUtil.unmask(data, this._mask);\n    }\n\n    if (this._opcode > 0x07) {\n      this.controlMessage(data);\n    } else if (this._compressed) {\n      this._state = INFLATING;\n      this.decompress(data);\n    } else if (this.pushFragment(data)) {\n      this.dataMessage();\n    }\n  }\n\n  /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @private\n   */\n  decompress (data) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n      if (err) {\n        this.error(err, err.closeCode === 1009 ? 1009 : 1007);\n        return;\n      }\n\n      if (this.pushFragment(buf)) this.dataMessage();\n      this.startLoop();\n    });\n  }\n\n  /**\n   * Handles a data message.\n   *\n   * @private\n   */\n  dataMessage () {\n    if (this._fin) {\n      const messageLength = this._messageLength;\n      const fragments = this._fragments;\n\n      this._totalPayloadLength = 0;\n      this._messageLength = 0;\n      this._fragmented = 0;\n      this._fragments = [];\n\n      if (this._opcode === 2) {\n        var data;\n\n        if (this._binaryType === 'nodebuffer') {\n          data = toBuffer(fragments, messageLength);\n        } else if (this._binaryType === 'arraybuffer') {\n          data = toArrayBuffer(toBuffer(fragments, messageLength));\n        } else {\n          data = fragments;\n        }\n\n        this.onmessage(data);\n      } else {\n        const buf = toBuffer(fragments, messageLength);\n\n        if (!isValidUTF8(buf)) {\n          this.error(new Error('invalid utf8 sequence'), 1007);\n          return;\n        }\n\n        this.onmessage(buf.toString());\n      }\n    }\n\n    this._state = GET_INFO;\n  }\n\n  /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @private\n   */\n  controlMessage (data) {\n    if (this._opcode === 0x08) {\n      if (data.length === 0) {\n        this.onclose(1000, '');\n        this._loop = false;\n        this.cleanup(this._cleanupCallback);\n      } else if (data.length === 1) {\n        this.error(new Error('invalid payload length'), 1002);\n      } else {\n        const code = data.readUInt16BE(0, true);\n\n        if (!ErrorCodes.isValidErrorCode(code)) {\n          this.error(new Error(`invalid status code: ${code}`), 1002);\n          return;\n        }\n\n        const buf = data.slice(2);\n\n        if (!isValidUTF8(buf)) {\n          this.error(new Error('invalid utf8 sequence'), 1007);\n          return;\n        }\n\n        this.onclose(code, buf.toString());\n        this._loop = false;\n        this.cleanup(this._cleanupCallback);\n      }\n\n      return;\n    }\n\n    if (this._opcode === 0x09) this.onping(data);\n    else this.onpong(data);\n\n    this._state = GET_INFO;\n  }\n\n  /**\n   * Handles an error.\n   *\n   * @param {Error} err The error\n   * @param {Number} code Close code\n   * @private\n   */\n  error (err, code) {\n    this.onerror(err, code);\n    this._hadError = true;\n    this._loop = false;\n    this.cleanup(this._cleanupCallback);\n  }\n\n  /**\n   * Checks payload size, disconnects socket when it exceeds `maxPayload`.\n   *\n   * @param {Number} length Payload length\n   * @private\n   */\n  maxPayloadExceeded (length) {\n    if (length === 0 || this._maxPayload < 1) return false;\n\n    const fullLength = this._totalPayloadLength + length;\n\n    if (fullLength <= this._maxPayload) {\n      this._totalPayloadLength = fullLength;\n      return false;\n    }\n\n    this.error(new Error('max payload size exceeded'), 1009);\n    return true;\n  }\n\n  /**\n   * Appends a fragment in the fragments array after checking that the sum of\n   * fragment lengths does not exceed `maxPayload`.\n   *\n   * @param {Buffer} fragment The fragment to add\n   * @return {Boolean} `true` if `maxPayload` is not exceeded, else `false`\n   * @private\n   */\n  pushFragment (fragment) {\n    if (fragment.length === 0) return true;\n\n    const totalLength = this._messageLength + fragment.length;\n\n    if (this._maxPayload < 1 || totalLength <= this._maxPayload) {\n      this._messageLength = totalLength;\n      this._fragments.push(fragment);\n      return true;\n    }\n\n    this.error(new Error('max payload size exceeded'), 1009);\n    return false;\n  }\n\n  /**\n   * Releases resources used by the receiver.\n   *\n   * @param {Function} cb Callback\n   * @public\n   */\n  cleanup (cb) {\n    this._dead = true;\n\n    if (!this._hadError && (this._loop || this._state === INFLATING)) {\n      this._cleanupCallback = cb;\n    } else {\n      this._extensions = null;\n      this._fragments = null;\n      this._buffers = null;\n      this._mask = null;\n\n      this._cleanupCallback = null;\n      this.onmessage = null;\n      this.onclose = null;\n      this.onerror = null;\n      this.onping = null;\n      this.onpong = null;\n\n      if (cb) cb();\n    }\n  }\n}\n\nmodule.exports = Receiver;\n\n/**\n * Makes a buffer from a list of fragments.\n *\n * @param {Buffer[]} fragments The list of fragments composing the message\n * @param {Number} messageLength The length of the message\n * @return {Buffer}\n * @private\n */\nfunction toBuffer (fragments, messageLength) {\n  if (fragments.length === 1) return fragments[0];\n  if (fragments.length > 1) return bufferUtil.concat(fragments, messageLength);\n  return constants.EMPTY_BUFFER;\n}\n\n/**\n * Converts a buffer to an `ArrayBuffer`.\n *\n * @param {Buffer} The buffer to convert\n * @return {ArrayBuffer} Converted buffer\n */\nfunction toArrayBuffer (buf) {\n  if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {\n    return buf.buffer;\n  }\n\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}