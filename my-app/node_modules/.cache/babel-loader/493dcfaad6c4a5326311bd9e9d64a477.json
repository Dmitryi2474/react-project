{"ast":null,"code":"var http = require('http'),\n  https = require('https'),\n  common = require('../common');\n\n/*!\n * Array of passes.\n *\n * A `pass` is just a function that is executed on `req, socket, options`\n * so that you can easily add new checks while still keeping the base\n * flexible.\n */\n\n/*\n * Websockets Passes\n *\n */\n\nmodule.exports = {\n  /**\n   * WebSocket requests must have the `GET` method and\n   * the `upgrade:websocket` header\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {Socket} Websocket\n   *\n   * @api private\n   */\n\n  checkMethodAndHeader: function checkMethodAndHeader(req, socket) {\n    if (req.method !== 'GET' || !req.headers.upgrade) {\n      socket.destroy();\n      return true;\n    }\n    if (req.headers.upgrade.toLowerCase() !== 'websocket') {\n      socket.destroy();\n      return true;\n    }\n  },\n  /**\n   * Sets `x-forwarded-*` headers if specified in config.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {Socket} Websocket\n   * @param {Object} Options Config object passed to the proxy\n   *\n   * @api private\n   */\n\n  XHeaders: function XHeaders(req, socket, options) {\n    if (!options.xfwd) return;\n    var values = {\n      for: req.connection.remoteAddress || req.socket.remoteAddress,\n      port: common.getPort(req),\n      proto: common.hasEncryptedConnection(req) ? 'wss' : 'ws'\n    };\n    ['for', 'port', 'proto'].forEach(function (header) {\n      req.headers['x-forwarded-' + header] = (req.headers['x-forwarded-' + header] || '') + (req.headers['x-forwarded-' + header] ? ',' : '') + values[header];\n    });\n  },\n  /**\n   * Does the actual proxying. Make the request and upgrade it\n   * send the Switching Protocols request and pipe the sockets.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {Socket} Websocket\n   * @param {Object} Options Config object passed to the proxy\n   *\n   * @api private\n   */\n  stream: function stream(req, socket, options, head, server, clb) {\n    common.setupSocket(socket);\n    if (head && head.length) socket.unshift(head);\n    var proxyReq = (common.isSSL.test(options.target.protocol) ? https : http).request(common.setupOutgoing(options.ssl || {}, options, req));\n\n    // Enable developers to modify the proxyReq before headers are sent\n    if (server) {\n      server.emit('proxyReqWs', proxyReq, req, socket, options, head);\n    }\n\n    // Error Handler\n    proxyReq.on('error', onOutgoingError);\n    proxyReq.on('response', function (res) {\n      // if upgrade event isn't going to happen, close the socket\n      if (!res.upgrade) socket.end();\n    });\n    proxyReq.on('upgrade', function (proxyRes, proxySocket, proxyHead) {\n      proxySocket.on('error', onOutgoingError);\n\n      // Allow us to listen when the websocket has completed\n      proxySocket.on('end', function () {\n        server.emit('close', proxyRes, proxySocket, proxyHead);\n      });\n\n      // The pipe below will end proxySocket if socket closes cleanly, but not\n      // if it errors (eg, vanishes from the net and starts returning\n      // EHOSTUNREACH). We need to do that explicitly.\n      socket.on('error', function () {\n        proxySocket.end();\n      });\n      common.setupSocket(proxySocket);\n      if (proxyHead && proxyHead.length) proxySocket.unshift(proxyHead);\n\n      //\n      // Remark: Handle writing the headers to the socket when switching protocols\n      // Also handles when a header is an array\n      //\n      socket.write(Object.keys(proxyRes.headers).reduce(function (head, key) {\n        var value = proxyRes.headers[key];\n        if (!Array.isArray(value)) {\n          head.push(key + ': ' + value);\n          return head;\n        }\n        for (var i = 0; i < value.length; i++) {\n          head.push(key + ': ' + value[i]);\n        }\n        return head;\n      }, ['HTTP/1.1 101 Switching Protocols']).join('\\r\\n') + '\\r\\n\\r\\n');\n      proxySocket.pipe(socket).pipe(proxySocket);\n      server.emit('open', proxySocket);\n      server.emit('proxySocket', proxySocket); //DEPRECATED.\n    });\n\n    return proxyReq.end(); // XXX: CHECK IF THIS IS THIS CORRECT\n\n    function onOutgoingError(err) {\n      if (clb) {\n        clb(err, req, socket);\n      } else {\n        server.emit('error', err, req, socket);\n      }\n      socket.end();\n    }\n  }\n};","map":{"version":3,"names":["http","require","https","common","module","exports","checkMethodAndHeader","req","socket","method","headers","upgrade","destroy","toLowerCase","XHeaders","options","xfwd","values","for","connection","remoteAddress","port","getPort","proto","hasEncryptedConnection","forEach","header","stream","head","server","clb","setupSocket","length","unshift","proxyReq","isSSL","test","target","protocol","request","setupOutgoing","ssl","emit","on","onOutgoingError","res","end","proxyRes","proxySocket","proxyHead","write","Object","keys","reduce","key","value","Array","isArray","push","i","join","pipe","err"],"sources":["/home/user/Рабочий стол/pizza/project/node_modules/http-proxy/lib/http-proxy/passes/ws-incoming.js"],"sourcesContent":["var http   = require('http'),\n    https  = require('https'),\n    common = require('../common');\n\n/*!\n * Array of passes.\n *\n * A `pass` is just a function that is executed on `req, socket, options`\n * so that you can easily add new checks while still keeping the base\n * flexible.\n */\n\n/*\n * Websockets Passes\n *\n */\n\n\nmodule.exports = {\n  /**\n   * WebSocket requests must have the `GET` method and\n   * the `upgrade:websocket` header\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {Socket} Websocket\n   *\n   * @api private\n   */\n\n  checkMethodAndHeader : function checkMethodAndHeader(req, socket) {\n    if (req.method !== 'GET' || !req.headers.upgrade) {\n      socket.destroy();\n      return true;\n    }\n\n    if (req.headers.upgrade.toLowerCase() !== 'websocket') {\n      socket.destroy();\n      return true;\n    }\n  },\n\n  /**\n   * Sets `x-forwarded-*` headers if specified in config.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {Socket} Websocket\n   * @param {Object} Options Config object passed to the proxy\n   *\n   * @api private\n   */\n\n  XHeaders : function XHeaders(req, socket, options) {\n    if(!options.xfwd) return;\n\n    var values = {\n      for  : req.connection.remoteAddress || req.socket.remoteAddress,\n      port : common.getPort(req),\n      proto: common.hasEncryptedConnection(req) ? 'wss' : 'ws'\n    };\n\n    ['for', 'port', 'proto'].forEach(function(header) {\n      req.headers['x-forwarded-' + header] =\n        (req.headers['x-forwarded-' + header] || '') +\n        (req.headers['x-forwarded-' + header] ? ',' : '') +\n        values[header];\n    });\n  },\n\n  /**\n   * Does the actual proxying. Make the request and upgrade it\n   * send the Switching Protocols request and pipe the sockets.\n   *\n   * @param {ClientRequest} Req Request object\n   * @param {Socket} Websocket\n   * @param {Object} Options Config object passed to the proxy\n   *\n   * @api private\n   */\n  stream : function stream(req, socket, options, head, server, clb) {\n    common.setupSocket(socket);\n\n    if (head && head.length) socket.unshift(head);\n\n\n    var proxyReq = (common.isSSL.test(options.target.protocol) ? https : http).request(\n      common.setupOutgoing(options.ssl || {}, options, req)\n    );\n\n    // Enable developers to modify the proxyReq before headers are sent\n    if (server) { server.emit('proxyReqWs', proxyReq, req, socket, options, head); }\n\n    // Error Handler\n    proxyReq.on('error', onOutgoingError);\n    proxyReq.on('response', function (res) {\n      // if upgrade event isn't going to happen, close the socket\n      if (!res.upgrade) socket.end();\n    });\n\n    proxyReq.on('upgrade', function(proxyRes, proxySocket, proxyHead) {\n      proxySocket.on('error', onOutgoingError);\n\n      // Allow us to listen when the websocket has completed\n      proxySocket.on('end', function () {\n        server.emit('close', proxyRes, proxySocket, proxyHead);\n      });\n\n      // The pipe below will end proxySocket if socket closes cleanly, but not\n      // if it errors (eg, vanishes from the net and starts returning\n      // EHOSTUNREACH). We need to do that explicitly.\n      socket.on('error', function () {\n        proxySocket.end();\n      });\n\n      common.setupSocket(proxySocket);\n\n      if (proxyHead && proxyHead.length) proxySocket.unshift(proxyHead);\n\n      //\n      // Remark: Handle writing the headers to the socket when switching protocols\n      // Also handles when a header is an array\n      //\n      socket.write(\n        Object.keys(proxyRes.headers).reduce(function (head, key) {\n          var value = proxyRes.headers[key];\n\n          if (!Array.isArray(value)) {\n            head.push(key + ': ' + value);\n            return head;\n          }\n\n          for (var i = 0; i < value.length; i++) {\n            head.push(key + ': ' + value[i]);\n          }\n          return head;\n        }, ['HTTP/1.1 101 Switching Protocols'])\n        .join('\\r\\n') + '\\r\\n\\r\\n'\n      );\n\n      proxySocket.pipe(socket).pipe(proxySocket);\n\n      server.emit('open', proxySocket);\n      server.emit('proxySocket', proxySocket);  //DEPRECATED.\n    });\n\n    return proxyReq.end(); // XXX: CHECK IF THIS IS THIS CORRECT\n\n    function onOutgoingError(err) {\n      if (clb) {\n        clb(err, req, socket);\n      } else {\n        server.emit('error', err, req, socket);\n      }\n      socket.end();\n    }\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}