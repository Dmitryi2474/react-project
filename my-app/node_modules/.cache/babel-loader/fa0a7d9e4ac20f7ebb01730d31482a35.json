{"ast":null,"code":"'use strict';\n\nvar stringWidth = require('string-width');\nvar stripAnsi = require('strip-ansi');\nvar ESCAPES = ['\\u001b', '\\u009b'];\nvar END_CODE = 39;\nvar ESCAPE_CODES = {\n  0: 0,\n  1: 22,\n  2: 22,\n  3: 23,\n  4: 24,\n  7: 27,\n  8: 28,\n  9: 29,\n  30: 39,\n  31: 39,\n  32: 39,\n  33: 39,\n  34: 39,\n  35: 39,\n  36: 39,\n  37: 39,\n  90: 39,\n  40: 49,\n  41: 49,\n  42: 49,\n  43: 49,\n  44: 49,\n  45: 49,\n  46: 49,\n  47: 49\n};\nfunction wrapAnsi(code) {\n  return ESCAPES[0] + '[' + code + 'm';\n}\n\n// calculate the length of words split on ' ', ignoring\n// the extra characters added by ansi escape codes.\nfunction wordLengths(str) {\n  return str.split(' ').map(function (s) {\n    return stringWidth(s);\n  });\n}\n\n// wrap a long word across multiple rows.\n// ansi escape codes do not count towards length.\nfunction wrapWord(rows, word, cols) {\n  var insideEscape = false;\n  var visible = stripAnsi(rows[rows.length - 1]).length;\n  for (var i = 0; i < word.length; i++) {\n    var x = word[i];\n    rows[rows.length - 1] += x;\n    if (ESCAPES.indexOf(x) !== -1) {\n      insideEscape = true;\n    } else if (insideEscape && x === 'm') {\n      insideEscape = false;\n      continue;\n    }\n    if (insideEscape) {\n      continue;\n    }\n    visible++;\n    if (visible >= cols && i < word.length - 1) {\n      rows.push('');\n      visible = 0;\n    }\n  }\n\n  // it's possible that the last row we copy over is only\n  // ansi escape characters, handle this edge-case.\n  if (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {\n    rows[rows.length - 2] += rows.pop();\n  }\n}\n\n// the wrap-ansi module can be invoked\n// in either 'hard' or 'soft' wrap mode.\n//\n// 'hard' will never allow a string to take up more\n// than cols characters.\n//\n// 'soft' allows long words to expand past the column length.\nfunction exec(str, cols, opts) {\n  var options = opts || {};\n  var pre = '';\n  var ret = '';\n  var escapeCode;\n  var lengths = wordLengths(str);\n  var words = str.split(' ');\n  var rows = [''];\n  for (var i = 0, word; (word = words[i]) !== undefined; i++) {\n    var rowLength = stringWidth(rows[rows.length - 1]);\n    if (rowLength) {\n      rows[rows.length - 1] += ' ';\n      rowLength++;\n    }\n\n    // in 'hard' wrap mode, the length of a line is\n    // never allowed to extend past 'cols'.\n    if (lengths[i] > cols && options.hard) {\n      if (rowLength) {\n        rows.push('');\n      }\n      wrapWord(rows, word, cols);\n      continue;\n    }\n    if (rowLength + lengths[i] > cols && rowLength > 0) {\n      if (options.wordWrap === false && rowLength < cols) {\n        wrapWord(rows, word, cols);\n        continue;\n      }\n      rows.push('');\n    }\n    rows[rows.length - 1] += word;\n  }\n  pre = rows.map(function (r) {\n    return r.trim();\n  }).join('\\n');\n  for (var j = 0; j < pre.length; j++) {\n    var y = pre[j];\n    ret += y;\n    if (ESCAPES.indexOf(y) !== -1) {\n      var code = parseFloat(/[0-9][^m]*/.exec(pre.slice(j, j + 4)));\n      escapeCode = code === END_CODE ? null : code;\n    }\n    if (escapeCode && ESCAPE_CODES[escapeCode]) {\n      if (pre[j + 1] === '\\n') {\n        ret += wrapAnsi(ESCAPE_CODES[escapeCode]);\n      } else if (y === '\\n') {\n        ret += wrapAnsi(escapeCode);\n      }\n    }\n  }\n  return ret;\n}\n\n// for each line break, invoke the method separately.\nmodule.exports = function (str, cols, opts) {\n  return String(str).split('\\n').map(function (substr) {\n    return exec(substr, cols, opts);\n  }).join('\\n');\n};","map":{"version":3,"names":["stringWidth","require","stripAnsi","ESCAPES","END_CODE","ESCAPE_CODES","wrapAnsi","code","wordLengths","str","split","map","s","wrapWord","rows","word","cols","insideEscape","visible","length","i","x","indexOf","push","pop","exec","opts","options","pre","ret","escapeCode","lengths","words","undefined","rowLength","hard","wordWrap","r","trim","join","j","y","parseFloat","slice","module","exports","String","substr"],"sources":["/home/user/Рабочий стол/pizza/project/node_modules/wrap-ansi/index.js"],"sourcesContent":["'use strict';\nvar stringWidth = require('string-width');\nvar stripAnsi = require('strip-ansi');\n\nvar ESCAPES = [\n\t'\\u001b',\n\t'\\u009b'\n];\n\nvar END_CODE = 39;\n\nvar ESCAPE_CODES = {\n\t0: 0,\n\t1: 22,\n\t2: 22,\n\t3: 23,\n\t4: 24,\n\t7: 27,\n\t8: 28,\n\t9: 29,\n\t30: 39,\n\t31: 39,\n\t32: 39,\n\t33: 39,\n\t34: 39,\n\t35: 39,\n\t36: 39,\n\t37: 39,\n\t90: 39,\n\t40: 49,\n\t41: 49,\n\t42: 49,\n\t43: 49,\n\t44: 49,\n\t45: 49,\n\t46: 49,\n\t47: 49\n};\n\nfunction wrapAnsi(code) {\n\treturn ESCAPES[0] + '[' + code + 'm';\n}\n\n// calculate the length of words split on ' ', ignoring\n// the extra characters added by ansi escape codes.\nfunction wordLengths(str) {\n\treturn str.split(' ').map(function (s) {\n\t\treturn stringWidth(s);\n\t});\n}\n\n// wrap a long word across multiple rows.\n// ansi escape codes do not count towards length.\nfunction wrapWord(rows, word, cols) {\n\tvar insideEscape = false;\n\tvar visible = stripAnsi(rows[rows.length - 1]).length;\n\n\tfor (var i = 0; i < word.length; i++) {\n\t\tvar x = word[i];\n\n\t\trows[rows.length - 1] += x;\n\n\t\tif (ESCAPES.indexOf(x) !== -1) {\n\t\t\tinsideEscape = true;\n\t\t} else if (insideEscape && x === 'm') {\n\t\t\tinsideEscape = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insideEscape) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tvisible++;\n\n\t\tif (visible >= cols && i < word.length - 1) {\n\t\t\trows.push('');\n\t\t\tvisible = 0;\n\t\t}\n\t}\n\n\t// it's possible that the last row we copy over is only\n\t// ansi escape characters, handle this edge-case.\n\tif (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {\n\t\trows[rows.length - 2] += rows.pop();\n\t}\n}\n\n// the wrap-ansi module can be invoked\n// in either 'hard' or 'soft' wrap mode.\n//\n// 'hard' will never allow a string to take up more\n// than cols characters.\n//\n// 'soft' allows long words to expand past the column length.\nfunction exec(str, cols, opts) {\n\tvar options = opts || {};\n\n\tvar pre = '';\n\tvar ret = '';\n\tvar escapeCode;\n\n\tvar lengths = wordLengths(str);\n\tvar words = str.split(' ');\n\tvar rows = [''];\n\n\tfor (var i = 0, word; (word = words[i]) !== undefined; i++) {\n\t\tvar rowLength = stringWidth(rows[rows.length - 1]);\n\n\t\tif (rowLength) {\n\t\t\trows[rows.length - 1] += ' ';\n\t\t\trowLength++;\n\t\t}\n\n\t\t// in 'hard' wrap mode, the length of a line is\n\t\t// never allowed to extend past 'cols'.\n\t\tif (lengths[i] > cols && options.hard) {\n\t\t\tif (rowLength) {\n\t\t\t\trows.push('');\n\t\t\t}\n\t\t\twrapWord(rows, word, cols);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (rowLength + lengths[i] > cols && rowLength > 0) {\n\t\t\tif (options.wordWrap === false && rowLength < cols) {\n\t\t\t\twrapWord(rows, word, cols);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\trows.push('');\n\t\t}\n\n\t\trows[rows.length - 1] += word;\n\t}\n\n\tpre = rows.map(function (r) {\n\t\treturn r.trim();\n\t}).join('\\n');\n\n\tfor (var j = 0; j < pre.length; j++) {\n\t\tvar y = pre[j];\n\n\t\tret += y;\n\n\t\tif (ESCAPES.indexOf(y) !== -1) {\n\t\t\tvar code = parseFloat(/[0-9][^m]*/.exec(pre.slice(j, j + 4)));\n\t\t\tescapeCode = code === END_CODE ? null : code;\n\t\t}\n\n\t\tif (escapeCode && ESCAPE_CODES[escapeCode]) {\n\t\t\tif (pre[j + 1] === '\\n') {\n\t\t\t\tret += wrapAnsi(ESCAPE_CODES[escapeCode]);\n\t\t\t} else if (y === '\\n') {\n\t\t\t\tret += wrapAnsi(escapeCode);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n// for each line break, invoke the method separately.\nmodule.exports = function (str, cols, opts) {\n\treturn String(str).split('\\n').map(function (substr) {\n\t\treturn exec(substr, cols, opts);\n\t}).join('\\n');\n};\n"],"mappings":"AAAA,YAAY;;AACZ,IAAIA,WAAW,GAAGC,OAAO,CAAC,cAAc,CAAC;AACzC,IAAIC,SAAS,GAAGD,OAAO,CAAC,YAAY,CAAC;AAErC,IAAIE,OAAO,GAAG,CACb,QAAQ,EACR,QAAQ,CACR;AAED,IAAIC,QAAQ,GAAG,EAAE;AAEjB,IAAIC,YAAY,GAAG;EAClB,CAAC,EAAE,CAAC;EACJ,CAAC,EAAE,EAAE;EACL,CAAC,EAAE,EAAE;EACL,CAAC,EAAE,EAAE;EACL,CAAC,EAAE,EAAE;EACL,CAAC,EAAE,EAAE;EACL,CAAC,EAAE,EAAE;EACL,CAAC,EAAE,EAAE;EACL,EAAE,EAAE,EAAE;EACN,EAAE,EAAE,EAAE;EACN,EAAE,EAAE,EAAE;EACN,EAAE,EAAE,EAAE;EACN,EAAE,EAAE,EAAE;EACN,EAAE,EAAE,EAAE;EACN,EAAE,EAAE,EAAE;EACN,EAAE,EAAE,EAAE;EACN,EAAE,EAAE,EAAE;EACN,EAAE,EAAE,EAAE;EACN,EAAE,EAAE,EAAE;EACN,EAAE,EAAE,EAAE;EACN,EAAE,EAAE,EAAE;EACN,EAAE,EAAE,EAAE;EACN,EAAE,EAAE,EAAE;EACN,EAAE,EAAE,EAAE;EACN,EAAE,EAAE;AACL,CAAC;AAED,SAASC,QAAQ,CAACC,IAAI,EAAE;EACvB,OAAOJ,OAAO,CAAC,CAAC,CAAC,GAAG,GAAG,GAAGI,IAAI,GAAG,GAAG;AACrC;;AAEA;AACA;AACA,SAASC,WAAW,CAACC,GAAG,EAAE;EACzB,OAAOA,GAAG,CAACC,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,CAAC,UAAUC,CAAC,EAAE;IACtC,OAAOZ,WAAW,CAACY,CAAC,CAAC;EACtB,CAAC,CAAC;AACH;;AAEA;AACA;AACA,SAASC,QAAQ,CAACC,IAAI,EAAEC,IAAI,EAAEC,IAAI,EAAE;EACnC,IAAIC,YAAY,GAAG,KAAK;EACxB,IAAIC,OAAO,GAAGhB,SAAS,CAACY,IAAI,CAACA,IAAI,CAACK,MAAM,GAAG,CAAC,CAAC,CAAC,CAACA,MAAM;EAErD,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,IAAI,CAACI,MAAM,EAAEC,CAAC,EAAE,EAAE;IACrC,IAAIC,CAAC,GAAGN,IAAI,CAACK,CAAC,CAAC;IAEfN,IAAI,CAACA,IAAI,CAACK,MAAM,GAAG,CAAC,CAAC,IAAIE,CAAC;IAE1B,IAAIlB,OAAO,CAACmB,OAAO,CAACD,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE;MAC9BJ,YAAY,GAAG,IAAI;IACpB,CAAC,MAAM,IAAIA,YAAY,IAAII,CAAC,KAAK,GAAG,EAAE;MACrCJ,YAAY,GAAG,KAAK;MACpB;IACD;IAEA,IAAIA,YAAY,EAAE;MACjB;IACD;IAEAC,OAAO,EAAE;IAET,IAAIA,OAAO,IAAIF,IAAI,IAAII,CAAC,GAAGL,IAAI,CAACI,MAAM,GAAG,CAAC,EAAE;MAC3CL,IAAI,CAACS,IAAI,CAAC,EAAE,CAAC;MACbL,OAAO,GAAG,CAAC;IACZ;EACD;;EAEA;EACA;EACA,IAAI,CAACA,OAAO,IAAIJ,IAAI,CAACA,IAAI,CAACK,MAAM,GAAG,CAAC,CAAC,CAACA,MAAM,GAAG,CAAC,IAAIL,IAAI,CAACK,MAAM,GAAG,CAAC,EAAE;IACpEL,IAAI,CAACA,IAAI,CAACK,MAAM,GAAG,CAAC,CAAC,IAAIL,IAAI,CAACU,GAAG,EAAE;EACpC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,IAAI,CAAChB,GAAG,EAAEO,IAAI,EAAEU,IAAI,EAAE;EAC9B,IAAIC,OAAO,GAAGD,IAAI,IAAI,CAAC,CAAC;EAExB,IAAIE,GAAG,GAAG,EAAE;EACZ,IAAIC,GAAG,GAAG,EAAE;EACZ,IAAIC,UAAU;EAEd,IAAIC,OAAO,GAAGvB,WAAW,CAACC,GAAG,CAAC;EAC9B,IAAIuB,KAAK,GAAGvB,GAAG,CAACC,KAAK,CAAC,GAAG,CAAC;EAC1B,IAAII,IAAI,GAAG,CAAC,EAAE,CAAC;EAEf,KAAK,IAAIM,CAAC,GAAG,CAAC,EAAEL,IAAI,EAAE,CAACA,IAAI,GAAGiB,KAAK,CAACZ,CAAC,CAAC,MAAMa,SAAS,EAAEb,CAAC,EAAE,EAAE;IAC3D,IAAIc,SAAS,GAAGlC,WAAW,CAACc,IAAI,CAACA,IAAI,CAACK,MAAM,GAAG,CAAC,CAAC,CAAC;IAElD,IAAIe,SAAS,EAAE;MACdpB,IAAI,CAACA,IAAI,CAACK,MAAM,GAAG,CAAC,CAAC,IAAI,GAAG;MAC5Be,SAAS,EAAE;IACZ;;IAEA;IACA;IACA,IAAIH,OAAO,CAACX,CAAC,CAAC,GAAGJ,IAAI,IAAIW,OAAO,CAACQ,IAAI,EAAE;MACtC,IAAID,SAAS,EAAE;QACdpB,IAAI,CAACS,IAAI,CAAC,EAAE,CAAC;MACd;MACAV,QAAQ,CAACC,IAAI,EAAEC,IAAI,EAAEC,IAAI,CAAC;MAC1B;IACD;IAEA,IAAIkB,SAAS,GAAGH,OAAO,CAACX,CAAC,CAAC,GAAGJ,IAAI,IAAIkB,SAAS,GAAG,CAAC,EAAE;MACnD,IAAIP,OAAO,CAACS,QAAQ,KAAK,KAAK,IAAIF,SAAS,GAAGlB,IAAI,EAAE;QACnDH,QAAQ,CAACC,IAAI,EAAEC,IAAI,EAAEC,IAAI,CAAC;QAC1B;MACD;MAEAF,IAAI,CAACS,IAAI,CAAC,EAAE,CAAC;IACd;IAEAT,IAAI,CAACA,IAAI,CAACK,MAAM,GAAG,CAAC,CAAC,IAAIJ,IAAI;EAC9B;EAEAa,GAAG,GAAGd,IAAI,CAACH,GAAG,CAAC,UAAU0B,CAAC,EAAE;IAC3B,OAAOA,CAAC,CAACC,IAAI,EAAE;EAChB,CAAC,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC;EAEb,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,GAAG,CAACT,MAAM,EAAEqB,CAAC,EAAE,EAAE;IACpC,IAAIC,CAAC,GAAGb,GAAG,CAACY,CAAC,CAAC;IAEdX,GAAG,IAAIY,CAAC;IAER,IAAItC,OAAO,CAACmB,OAAO,CAACmB,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE;MAC9B,IAAIlC,IAAI,GAAGmC,UAAU,CAAC,YAAY,CAACjB,IAAI,CAACG,GAAG,CAACe,KAAK,CAACH,CAAC,EAAEA,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;MAC7DV,UAAU,GAAGvB,IAAI,KAAKH,QAAQ,GAAG,IAAI,GAAGG,IAAI;IAC7C;IAEA,IAAIuB,UAAU,IAAIzB,YAAY,CAACyB,UAAU,CAAC,EAAE;MAC3C,IAAIF,GAAG,CAACY,CAAC,GAAG,CAAC,CAAC,KAAK,IAAI,EAAE;QACxBX,GAAG,IAAIvB,QAAQ,CAACD,YAAY,CAACyB,UAAU,CAAC,CAAC;MAC1C,CAAC,MAAM,IAAIW,CAAC,KAAK,IAAI,EAAE;QACtBZ,GAAG,IAAIvB,QAAQ,CAACwB,UAAU,CAAC;MAC5B;IACD;EACD;EAEA,OAAOD,GAAG;AACX;;AAEA;AACAe,MAAM,CAACC,OAAO,GAAG,UAAUpC,GAAG,EAAEO,IAAI,EAAEU,IAAI,EAAE;EAC3C,OAAOoB,MAAM,CAACrC,GAAG,CAAC,CAACC,KAAK,CAAC,IAAI,CAAC,CAACC,GAAG,CAAC,UAAUoC,MAAM,EAAE;IACpD,OAAOtB,IAAI,CAACsB,MAAM,EAAE/B,IAAI,EAAEU,IAAI,CAAC;EAChC,CAAC,CAAC,CAACa,IAAI,CAAC,IAAI,CAAC;AACd,CAAC"},"metadata":{},"sourceType":"script"}