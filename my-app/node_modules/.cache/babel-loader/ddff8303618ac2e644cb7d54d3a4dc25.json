{"ast":null,"code":"'use strict';\n\nvar url = require('url');\nvar gitHosts = require('./git-host-info.js');\nvar GitHost = module.exports = require('./git-host.js');\nvar protocolToRepresentationMap = {\n  'git+ssh': 'sshurl',\n  'git+https': 'https',\n  'ssh': 'sshurl',\n  'git': 'git'\n};\nfunction protocolToRepresentation(protocol) {\n  if (protocol.substr(-1) === ':') protocol = protocol.slice(0, -1);\n  return protocolToRepresentationMap[protocol] || protocol;\n}\nvar authProtocols = {\n  'git:': true,\n  'https:': true,\n  'git+https:': true,\n  'http:': true,\n  'git+http:': true\n};\nvar cache = {};\nmodule.exports.fromUrl = function (giturl, opts) {\n  if (typeof giturl !== 'string') return;\n  var key = giturl + JSON.stringify(opts || {});\n  if (!(key in cache)) {\n    cache[key] = fromUrl(giturl, opts);\n  }\n  return cache[key];\n};\nfunction fromUrl(giturl, opts) {\n  if (giturl == null || giturl === '') return;\n  var url = fixupUnqualifiedGist(isGitHubShorthand(giturl) ? 'github:' + giturl : giturl);\n  var parsed = parseGitUrl(url);\n  var shortcutMatch = url.match(new RegExp('^([^:]+):(?:(?:[^@:]+(?:[^@]+)?@)?([^/]*))[/](.+?)(?:[.]git)?($|#)'));\n  var matches = Object.keys(gitHosts).map(function (gitHostName) {\n    try {\n      var gitHostInfo = gitHosts[gitHostName];\n      var auth = null;\n      if (parsed.auth && authProtocols[parsed.protocol]) {\n        auth = decodeURIComponent(parsed.auth);\n      }\n      var committish = parsed.hash ? decodeURIComponent(parsed.hash.substr(1)) : null;\n      var user = null;\n      var project = null;\n      var defaultRepresentation = null;\n      if (shortcutMatch && shortcutMatch[1] === gitHostName) {\n        user = shortcutMatch[2] && decodeURIComponent(shortcutMatch[2]);\n        project = decodeURIComponent(shortcutMatch[3]);\n        defaultRepresentation = 'shortcut';\n      } else {\n        if (parsed.host && parsed.host !== gitHostInfo.domain && parsed.host.replace(/^www[.]/, '') !== gitHostInfo.domain) return;\n        if (!gitHostInfo.protocols_re.test(parsed.protocol)) return;\n        if (!parsed.path) return;\n        var pathmatch = gitHostInfo.pathmatch;\n        var matched = parsed.path.match(pathmatch);\n        if (!matched) return;\n        if (matched[1] != null) user = decodeURIComponent(matched[1].replace(/^:/, ''));\n        if (matched[2] != null) project = decodeURIComponent(matched[2]);\n        defaultRepresentation = protocolToRepresentation(parsed.protocol);\n      }\n      return new GitHost(gitHostName, user, auth, project, committish, defaultRepresentation, opts);\n    } catch (ex) {\n      if (!(ex instanceof URIError)) throw ex;\n    }\n  }).filter(function (gitHostInfo) {\n    return gitHostInfo;\n  });\n  if (matches.length !== 1) return;\n  return matches[0];\n}\nfunction isGitHubShorthand(arg) {\n  // Note: This does not fully test the git ref format.\n  // See https://www.kernel.org/pub/software/scm/git/docs/git-check-ref-format.html\n  //\n  // The only way to do this properly would be to shell out to\n  // git-check-ref-format, and as this is a fast sync function,\n  // we don't want to do that.  Just let git fail if it turns\n  // out that the commit-ish is invalid.\n  // GH usernames cannot start with . or -\n  return /^[^:@%/\\s.-][^:@%/\\s]*[/][^:@\\s/%]+(?:#.*)?$/.test(arg);\n}\nfunction fixupUnqualifiedGist(giturl) {\n  // necessary for round-tripping gists\n  var parsed = url.parse(giturl);\n  if (parsed.protocol === 'gist:' && parsed.host && !parsed.path) {\n    return parsed.protocol + '/' + parsed.host;\n  } else {\n    return giturl;\n  }\n}\nfunction parseGitUrl(giturl) {\n  if (typeof giturl !== 'string') giturl = '' + giturl;\n  var matched = giturl.match(/^([^@]+)@([^:/]+):[/]?((?:[^/]+[/])?[^/]+?)(?:[.]git)?(#.*)?$/);\n  if (!matched) return url.parse(giturl);\n  return {\n    protocol: 'git+ssh:',\n    slashes: true,\n    auth: matched[1],\n    host: matched[2],\n    port: null,\n    hostname: matched[2],\n    hash: matched[4],\n    search: null,\n    query: null,\n    pathname: '/' + matched[3],\n    path: '/' + matched[3],\n    href: 'git+ssh://' + matched[1] + '@' + matched[2] + '/' + matched[3] + (matched[4] || '')\n  };\n}","map":{"version":3,"names":["url","require","gitHosts","GitHost","module","exports","protocolToRepresentationMap","protocolToRepresentation","protocol","substr","slice","authProtocols","cache","fromUrl","giturl","opts","key","JSON","stringify","fixupUnqualifiedGist","isGitHubShorthand","parsed","parseGitUrl","shortcutMatch","match","RegExp","matches","Object","keys","map","gitHostName","gitHostInfo","auth","decodeURIComponent","committish","hash","user","project","defaultRepresentation","host","domain","replace","protocols_re","test","path","pathmatch","matched","ex","URIError","filter","length","arg","parse","slashes","port","hostname","search","query","pathname","href"],"sources":["/home/user/Рабочий стол/pizza/project/node_modules/hosted-git-info/index.js"],"sourcesContent":["'use strict'\nvar url = require('url')\nvar gitHosts = require('./git-host-info.js')\nvar GitHost = module.exports = require('./git-host.js')\n\nvar protocolToRepresentationMap = {\n  'git+ssh': 'sshurl',\n  'git+https': 'https',\n  'ssh': 'sshurl',\n  'git': 'git'\n}\n\nfunction protocolToRepresentation (protocol) {\n  if (protocol.substr(-1) === ':') protocol = protocol.slice(0, -1)\n  return protocolToRepresentationMap[protocol] || protocol\n}\n\nvar authProtocols = {\n  'git:': true,\n  'https:': true,\n  'git+https:': true,\n  'http:': true,\n  'git+http:': true\n}\n\nvar cache = {}\n\nmodule.exports.fromUrl = function (giturl, opts) {\n  if (typeof giturl !== 'string') return\n  var key = giturl + JSON.stringify(opts || {})\n\n  if (!(key in cache)) {\n    cache[key] = fromUrl(giturl, opts)\n  }\n\n  return cache[key]\n}\n\nfunction fromUrl (giturl, opts) {\n  if (giturl == null || giturl === '') return\n  var url = fixupUnqualifiedGist(\n    isGitHubShorthand(giturl) ? 'github:' + giturl : giturl\n  )\n  var parsed = parseGitUrl(url)\n  var shortcutMatch = url.match(new RegExp('^([^:]+):(?:(?:[^@:]+(?:[^@]+)?@)?([^/]*))[/](.+?)(?:[.]git)?($|#)'))\n  var matches = Object.keys(gitHosts).map(function (gitHostName) {\n    try {\n      var gitHostInfo = gitHosts[gitHostName]\n      var auth = null\n      if (parsed.auth && authProtocols[parsed.protocol]) {\n        auth = decodeURIComponent(parsed.auth)\n      }\n      var committish = parsed.hash ? decodeURIComponent(parsed.hash.substr(1)) : null\n      var user = null\n      var project = null\n      var defaultRepresentation = null\n      if (shortcutMatch && shortcutMatch[1] === gitHostName) {\n        user = shortcutMatch[2] && decodeURIComponent(shortcutMatch[2])\n        project = decodeURIComponent(shortcutMatch[3])\n        defaultRepresentation = 'shortcut'\n      } else {\n        if (parsed.host && parsed.host !== gitHostInfo.domain && parsed.host.replace(/^www[.]/, '') !== gitHostInfo.domain) return\n        if (!gitHostInfo.protocols_re.test(parsed.protocol)) return\n        if (!parsed.path) return\n        var pathmatch = gitHostInfo.pathmatch\n        var matched = parsed.path.match(pathmatch)\n        if (!matched) return\n        if (matched[1] != null) user = decodeURIComponent(matched[1].replace(/^:/, ''))\n        if (matched[2] != null) project = decodeURIComponent(matched[2])\n        defaultRepresentation = protocolToRepresentation(parsed.protocol)\n      }\n      return new GitHost(gitHostName, user, auth, project, committish, defaultRepresentation, opts)\n    } catch (ex) {\n      if (!(ex instanceof URIError)) throw ex\n    }\n  }).filter(function (gitHostInfo) { return gitHostInfo })\n  if (matches.length !== 1) return\n  return matches[0]\n}\n\nfunction isGitHubShorthand (arg) {\n  // Note: This does not fully test the git ref format.\n  // See https://www.kernel.org/pub/software/scm/git/docs/git-check-ref-format.html\n  //\n  // The only way to do this properly would be to shell out to\n  // git-check-ref-format, and as this is a fast sync function,\n  // we don't want to do that.  Just let git fail if it turns\n  // out that the commit-ish is invalid.\n  // GH usernames cannot start with . or -\n  return /^[^:@%/\\s.-][^:@%/\\s]*[/][^:@\\s/%]+(?:#.*)?$/.test(arg)\n}\n\nfunction fixupUnqualifiedGist (giturl) {\n  // necessary for round-tripping gists\n  var parsed = url.parse(giturl)\n  if (parsed.protocol === 'gist:' && parsed.host && !parsed.path) {\n    return parsed.protocol + '/' + parsed.host\n  } else {\n    return giturl\n  }\n}\n\nfunction parseGitUrl (giturl) {\n  if (typeof giturl !== 'string') giturl = '' + giturl\n  var matched = giturl.match(/^([^@]+)@([^:/]+):[/]?((?:[^/]+[/])?[^/]+?)(?:[.]git)?(#.*)?$/)\n  if (!matched) return url.parse(giturl)\n  return {\n    protocol: 'git+ssh:',\n    slashes: true,\n    auth: matched[1],\n    host: matched[2],\n    port: null,\n    hostname: matched[2],\n    hash: matched[4],\n    search: null,\n    query: null,\n    pathname: '/' + matched[3],\n    path: '/' + matched[3],\n    href: 'git+ssh://' + matched[1] + '@' + matched[2] +\n          '/' + matched[3] + (matched[4] || '')\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}