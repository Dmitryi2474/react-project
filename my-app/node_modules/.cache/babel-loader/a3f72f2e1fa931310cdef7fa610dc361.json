{"ast":null,"code":"var url = require('url');\nvar EventEmitter = require('events').EventEmitter;\nvar axios = require('axios');\nvar debug = require('debug')('localtunnel:client');\nvar TunnelCluster = require('./TunnelCluster');\nvar Tunnel = function (opt) {\n  if (!(this instanceof Tunnel)) {\n    return new Tunnel(opt);\n  }\n  var self = this;\n  self._closed = false;\n  self._opt = opt || {};\n  self._opt.host = self._opt.host || 'https://localtunnel.me';\n};\nTunnel.prototype.__proto__ = EventEmitter.prototype;\n\n// initialize connection\n// callback with connection info\nTunnel.prototype._init = function (cb) {\n  var self = this;\n  var opt = self._opt;\n  var params = {\n    responseType: 'json'\n  };\n  var base_uri = opt.host + '/';\n\n  // optionally override the upstream server\n  var upstream = url.parse(opt.host);\n\n  // no subdomain at first, maybe use requested domain\n  var assigned_domain = opt.subdomain;\n\n  // where to quest\n  var uri = base_uri + (assigned_domain ? assigned_domain : '?new');\n  (function get_url() {\n    axios.get(uri, params).then(function (res) {\n      var body = res.data;\n      if (res.status !== 200) {\n        var err = new Error(body && body.message || 'localtunnel server returned an error, please try again');\n        return cb(err);\n      }\n      var port = body.port;\n      var host = upstream.hostname;\n      var max_conn = body.max_conn_count || 1;\n      cb(null, {\n        remote_host: upstream.hostname,\n        remote_port: body.port,\n        name: body.id,\n        url: body.url,\n        max_conn: max_conn\n      });\n    }).catch(function (err) {\n      // TODO (shtylman) don't print to stdout?\n      console.log('tunnel server offline: ' + err.message + ', retry 1s');\n      return setTimeout(get_url, 1000);\n    });\n  })();\n};\nTunnel.prototype._establish = function (info) {\n  var self = this;\n  var opt = self._opt;\n\n  // increase max event listeners so that localtunnel consumers don't get\n  // warning messages as soon as they setup even one listener. See #71\n  self.setMaxListeners(info.max_conn + (EventEmitter.defaultMaxListeners || 10));\n  info.local_host = opt.local_host;\n  info.local_port = opt.port;\n  var tunnels = self.tunnel_cluster = TunnelCluster(info);\n\n  // only emit the url the first time\n  tunnels.once('open', function () {\n    self.emit('url', info.url);\n  });\n\n  // re-emit socket error\n  tunnels.on('error', function (err) {\n    self.emit('error', err);\n  });\n  var tunnel_count = 0;\n\n  // track open count\n  tunnels.on('open', function (tunnel) {\n    tunnel_count++;\n    debug('tunnel open [total: %d]', tunnel_count);\n    var close_handler = function () {\n      tunnel.destroy();\n    };\n    if (self._closed) {\n      return close_handler();\n    }\n    self.once('close', close_handler);\n    tunnel.once('close', function () {\n      self.removeListener('close', close_handler);\n    });\n  });\n\n  // when a tunnel dies, open a new one\n  tunnels.on('dead', function (tunnel) {\n    tunnel_count--;\n    debug('tunnel dead [total: %d]', tunnel_count);\n    if (self._closed) {\n      return;\n    }\n    tunnels.open();\n  });\n  tunnels.on('request', function (info) {\n    self.emit('request', info);\n  });\n\n  // establish as many tunnels as allowed\n  for (var count = 0; count < info.max_conn; ++count) {\n    tunnels.open();\n  }\n};\nTunnel.prototype.open = function (cb) {\n  var self = this;\n  self._init(function (err, info) {\n    if (err) {\n      return cb(err);\n    }\n    self.url = info.url;\n    self._establish(info);\n    cb();\n  });\n};\n\n// shutdown tunnels\nTunnel.prototype.close = function () {\n  var self = this;\n  self._closed = true;\n  self.emit('close');\n};\nmodule.exports = Tunnel;","map":{"version":3,"names":["url","require","EventEmitter","axios","debug","TunnelCluster","Tunnel","opt","self","_closed","_opt","host","prototype","__proto__","_init","cb","params","responseType","base_uri","upstream","parse","assigned_domain","subdomain","uri","get_url","get","then","res","body","data","status","err","Error","message","port","hostname","max_conn","max_conn_count","remote_host","remote_port","name","id","catch","console","log","setTimeout","_establish","info","setMaxListeners","defaultMaxListeners","local_host","local_port","tunnels","tunnel_cluster","once","emit","on","tunnel_count","tunnel","close_handler","destroy","removeListener","open","count","close","module","exports"],"sources":["/home/user/Рабочий стол/pizza/project/node_modules/localtunnel/lib/Tunnel.js"],"sourcesContent":["var url = require('url');\nvar EventEmitter = require('events').EventEmitter;\nvar axios = require('axios');\nvar debug = require('debug')('localtunnel:client');\n\nvar TunnelCluster = require('./TunnelCluster');\n\nvar Tunnel = function(opt) {\n    if (!(this instanceof Tunnel)) {\n        return new Tunnel(opt);\n    }\n\n    var self = this;\n    self._closed = false;\n    self._opt = opt || {};\n\n    self._opt.host = self._opt.host || 'https://localtunnel.me';\n};\n\nTunnel.prototype.__proto__ = EventEmitter.prototype;\n\n// initialize connection\n// callback with connection info\nTunnel.prototype._init = function(cb) {\n    var self = this;\n    var opt = self._opt;\n\n    var params = {\n        responseType: 'json'\n    };\n\n    var base_uri = opt.host + '/';\n\n    // optionally override the upstream server\n    var upstream = url.parse(opt.host);\n\n    // no subdomain at first, maybe use requested domain\n    var assigned_domain = opt.subdomain;\n\n    // where to quest\n    var uri = base_uri + ((assigned_domain) ? assigned_domain : '?new');\n\n    (function get_url() {\n        axios.get(uri, params)\n        .then(function(res){\n            var body = res.data;\n            if (res.status !== 200) {\n                var err =  new Error((body && body.message) || 'localtunnel server returned an error, please try again');\n                return cb(err);\n            }\n            var port = body.port;\n            var host = upstream.hostname;\n            var max_conn = body.max_conn_count || 1;\n            cb(null, {\n                remote_host: upstream.hostname,\n                remote_port: body.port,\n                name: body.id,\n                url: body.url,\n                max_conn: max_conn\n            });\n        })\n        .catch(function(err){\n            // TODO (shtylman) don't print to stdout?\n            console.log('tunnel server offline: ' + err.message + ', retry 1s');\n            return setTimeout(get_url, 1000);\n        })\n    })();\n};\n\nTunnel.prototype._establish = function(info) {\n    var self = this;\n    var opt = self._opt;\n\n    // increase max event listeners so that localtunnel consumers don't get\n    // warning messages as soon as they setup even one listener. See #71\n    self.setMaxListeners(info.max_conn + (EventEmitter.defaultMaxListeners || 10));\n\n    info.local_host = opt.local_host;\n    info.local_port = opt.port;\n\n    var tunnels = self.tunnel_cluster = TunnelCluster(info);\n\n    // only emit the url the first time\n    tunnels.once('open', function() {\n        self.emit('url', info.url);\n    });\n\n    // re-emit socket error\n    tunnels.on('error', function(err) {\n        self.emit('error', err);\n    });\n\n    var tunnel_count = 0;\n\n    // track open count\n    tunnels.on('open', function(tunnel) {\n        tunnel_count++;\n        debug('tunnel open [total: %d]', tunnel_count);\n\n        var close_handler = function() {\n            tunnel.destroy();\n        };\n\n        if (self._closed) {\n            return close_handler();\n        }\n\n        self.once('close', close_handler);\n        tunnel.once('close', function() {\n            self.removeListener('close', close_handler);\n        });\n    });\n\n    // when a tunnel dies, open a new one\n    tunnels.on('dead', function(tunnel) {\n        tunnel_count--;\n        debug('tunnel dead [total: %d]', tunnel_count);\n\n        if (self._closed) {\n            return;\n        }\n\n        tunnels.open();\n    });\n\n    tunnels.on('request', function(info) {\n        self.emit('request', info);\n    });\n\n    // establish as many tunnels as allowed\n    for (var count = 0 ; count < info.max_conn ; ++count) {\n        tunnels.open();\n    }\n};\n\nTunnel.prototype.open = function(cb) {\n    var self = this;\n\n    self._init(function(err, info) {\n        if (err) {\n            return cb(err);\n        }\n\n        self.url = info.url;\n        self._establish(info);\n        cb();\n    });\n};\n\n// shutdown tunnels\nTunnel.prototype.close = function() {\n    var self = this;\n\n    self._closed = true;\n    self.emit('close');\n};\n\nmodule.exports = Tunnel;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}