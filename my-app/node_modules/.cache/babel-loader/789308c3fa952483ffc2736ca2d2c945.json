{"ast":null,"code":"'use strict';\n\nvar fs = require('fs'),\n  join = require('path').join,\n  resolve = require('path').resolve,\n  dirname = require('path').dirname,\n  defaultOptions = {\n    extensions: ['js', 'json', 'coffee'],\n    recurse: true,\n    rename: function (name) {\n      return name;\n    },\n    visit: function (obj) {\n      return obj;\n    }\n  };\nfunction checkFileInclusion(path, filename, options) {\n  return (\n    // verify file has valid extension\n    new RegExp('\\\\.(' + options.extensions.join('|') + ')$', 'i').test(filename) &&\n    // if options.include is a RegExp, evaluate it and make sure the path passes\n    !(options.include && options.include instanceof RegExp && !options.include.test(path)) &&\n    // if options.include is a function, evaluate it and make sure the path passes\n    !(options.include && typeof options.include === 'function' && !options.include(path, filename)) &&\n    // if options.exclude is a RegExp, evaluate it and make sure the path doesn't pass\n    !(options.exclude && options.exclude instanceof RegExp && options.exclude.test(path)) &&\n    // if options.exclude is a function, evaluate it and make sure the path doesn't pass\n    !(options.exclude && typeof options.exclude === 'function' && options.exclude(path, filename))\n  );\n}\nfunction requireDirectory(m, path, options) {\n  var retval = {};\n\n  // path is optional\n  if (path && !options && typeof path !== 'string') {\n    options = path;\n    path = null;\n  }\n\n  // default options\n  options = options || {};\n  for (var prop in defaultOptions) {\n    if (typeof options[prop] === 'undefined') {\n      options[prop] = defaultOptions[prop];\n    }\n  }\n\n  // if no path was passed in, assume the equivelant of __dirname from caller\n  // otherwise, resolve path relative to the equivalent of __dirname\n  path = !path ? dirname(m.filename) : resolve(dirname(m.filename), path);\n\n  // get the path of each file in specified directory, append to current tree node, recurse\n  fs.readdirSync(path).forEach(function (filename) {\n    var joined = join(path, filename),\n      files,\n      key,\n      obj;\n    if (fs.statSync(joined).isDirectory() && options.recurse) {\n      // this node is a directory; recurse\n      files = requireDirectory(m, joined, options);\n      // exclude empty directories\n      if (Object.keys(files).length) {\n        retval[options.rename(filename, joined, filename)] = files;\n      }\n    } else {\n      if (joined !== m.filename && checkFileInclusion(joined, filename, options)) {\n        // hash node key shouldn't include file extension\n        key = filename.substring(0, filename.lastIndexOf('.'));\n        obj = m.require(joined);\n        retval[options.rename(key, joined, filename)] = options.visit(obj, joined, filename) || obj;\n      }\n    }\n  });\n  return retval;\n}\nmodule.exports = requireDirectory;\nmodule.exports.defaults = defaultOptions;","map":{"version":3,"names":["fs","require","join","resolve","dirname","defaultOptions","extensions","recurse","rename","name","visit","obj","checkFileInclusion","path","filename","options","RegExp","test","include","exclude","requireDirectory","m","retval","prop","readdirSync","forEach","joined","files","key","statSync","isDirectory","Object","keys","length","substring","lastIndexOf","module","exports","defaults"],"sources":["/home/user/Рабочий стол/pizza/project/node_modules/require-directory/index.js"],"sourcesContent":["'use strict';\n\nvar fs = require('fs'),\n  join = require('path').join,\n  resolve = require('path').resolve,\n  dirname = require('path').dirname,\n  defaultOptions = {\n    extensions: ['js', 'json', 'coffee'],\n    recurse: true,\n    rename: function (name) {\n      return name;\n    },\n    visit: function (obj) {\n      return obj;\n    }\n  };\n\nfunction checkFileInclusion(path, filename, options) {\n  return (\n    // verify file has valid extension\n    (new RegExp('\\\\.(' + options.extensions.join('|') + ')$', 'i').test(filename)) &&\n\n    // if options.include is a RegExp, evaluate it and make sure the path passes\n    !(options.include && options.include instanceof RegExp && !options.include.test(path)) &&\n\n    // if options.include is a function, evaluate it and make sure the path passes\n    !(options.include && typeof options.include === 'function' && !options.include(path, filename)) &&\n\n    // if options.exclude is a RegExp, evaluate it and make sure the path doesn't pass\n    !(options.exclude && options.exclude instanceof RegExp && options.exclude.test(path)) &&\n\n    // if options.exclude is a function, evaluate it and make sure the path doesn't pass\n    !(options.exclude && typeof options.exclude === 'function' && options.exclude(path, filename))\n  );\n}\n\nfunction requireDirectory(m, path, options) {\n  var retval = {};\n\n  // path is optional\n  if (path && !options && typeof path !== 'string') {\n    options = path;\n    path = null;\n  }\n\n  // default options\n  options = options || {};\n  for (var prop in defaultOptions) {\n    if (typeof options[prop] === 'undefined') {\n      options[prop] = defaultOptions[prop];\n    }\n  }\n\n  // if no path was passed in, assume the equivelant of __dirname from caller\n  // otherwise, resolve path relative to the equivalent of __dirname\n  path = !path ? dirname(m.filename) : resolve(dirname(m.filename), path);\n\n  // get the path of each file in specified directory, append to current tree node, recurse\n  fs.readdirSync(path).forEach(function (filename) {\n    var joined = join(path, filename),\n      files,\n      key,\n      obj;\n\n    if (fs.statSync(joined).isDirectory() && options.recurse) {\n      // this node is a directory; recurse\n      files = requireDirectory(m, joined, options);\n      // exclude empty directories\n      if (Object.keys(files).length) {\n        retval[options.rename(filename, joined, filename)] = files;\n      }\n    } else {\n      if (joined !== m.filename && checkFileInclusion(joined, filename, options)) {\n        // hash node key shouldn't include file extension\n        key = filename.substring(0, filename.lastIndexOf('.'));\n        obj = m.require(joined);\n        retval[options.rename(key, joined, filename)] = options.visit(obj, joined, filename) || obj;\n      }\n    }\n  });\n\n  return retval;\n}\n\nmodule.exports = requireDirectory;\nmodule.exports.defaults = defaultOptions;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}