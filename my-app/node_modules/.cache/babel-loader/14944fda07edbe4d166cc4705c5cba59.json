{"ast":null,"code":"var EventEmitter = require('events').EventEmitter;\nvar debug = require('debug')('localtunnel:client');\nvar net = require('net');\nvar HeaderHostTransformer = require('./HeaderHostTransformer');\n\n// manages groups of tunnels\nvar TunnelCluster = function (opt) {\n  if (!(this instanceof TunnelCluster)) {\n    return new TunnelCluster(opt);\n  }\n  var self = this;\n  self._opt = opt;\n  EventEmitter.call(self);\n};\nTunnelCluster.prototype.__proto__ = EventEmitter.prototype;\n\n// establish a new tunnel\nTunnelCluster.prototype.open = function () {\n  var self = this;\n  var opt = self._opt || {};\n  var remote_host = opt.remote_host;\n  var remote_port = opt.remote_port;\n  var local_host = opt.local_host || 'localhost';\n  var local_port = opt.local_port;\n  debug('establishing tunnel %s:%s <> %s:%s', local_host, local_port, remote_host, remote_port);\n\n  // connection to localtunnel server\n  var remote = net.connect({\n    host: remote_host,\n    port: remote_port\n  });\n  remote.setKeepAlive(true);\n  remote.on('error', function (err) {\n    // emit connection refused errors immediately, because they\n    // indicate that the tunnel can't be established.\n    if (err.code === 'ECONNREFUSED') {\n      self.emit('error', new Error('connection refused: ' + remote_host + ':' + remote_port + ' (check your firewall settings)'));\n    }\n    remote.end();\n  });\n  function conn_local() {\n    if (remote.destroyed) {\n      debug('remote destroyed');\n      self.emit('dead');\n      return;\n    }\n    debug('connecting locally to %s:%d', local_host, local_port);\n    remote.pause();\n\n    // connection to local http server\n    var local = net.connect({\n      host: local_host,\n      port: local_port\n    });\n    function remote_close() {\n      debug('remote close');\n      self.emit('dead');\n      local.end();\n    }\n    ;\n    remote.once('close', remote_close);\n\n    // TODO some languages have single threaded servers which makes opening up\n    // multiple local connections impossible. We need a smarter way to scale\n    // and adjust for such instances to avoid beating on the door of the server\n    local.once('error', function (err) {\n      debug('local error %s', err.message);\n      local.end();\n      remote.removeListener('close', remote_close);\n      if (err.code !== 'ECONNREFUSED') {\n        return remote.end();\n      }\n\n      // retrying connection to local server\n      setTimeout(conn_local, 1000);\n    });\n    local.once('connect', function () {\n      debug('connected locally');\n      remote.resume();\n      var stream = remote;\n\n      // if user requested specific local host\n      // then we use host header transform to replace the host header\n      if (opt.local_host) {\n        debug('transform Host header to %s', opt.local_host);\n        stream = remote.pipe(HeaderHostTransformer({\n          host: opt.local_host\n        }));\n      }\n      stream.pipe(local).pipe(remote);\n\n      // when local closes, also get a new remote\n      local.once('close', function (had_error) {\n        debug('local connection closed [%s]', had_error);\n      });\n    });\n  }\n  remote.on('data', function (data) {\n    const match = data.toString().match(/^(\\w+) (\\S+)/);\n    if (match) {\n      self.emit('request', {\n        method: match[1],\n        path: match[2]\n      });\n    }\n  });\n\n  // tunnel is considered open when remote connects\n  remote.once('connect', function () {\n    self.emit('open', remote);\n    conn_local();\n  });\n};\nmodule.exports = TunnelCluster;","map":{"version":3,"names":["EventEmitter","require","debug","net","HeaderHostTransformer","TunnelCluster","opt","self","_opt","call","prototype","__proto__","open","remote_host","remote_port","local_host","local_port","remote","connect","host","port","setKeepAlive","on","err","code","emit","Error","end","conn_local","destroyed","pause","local","remote_close","once","message","removeListener","setTimeout","resume","stream","pipe","had_error","data","match","toString","method","path","module","exports"],"sources":["/home/user/Рабочий стол/pizza/project/node_modules/localtunnel/lib/TunnelCluster.js"],"sourcesContent":["var EventEmitter = require('events').EventEmitter;\nvar debug = require('debug')('localtunnel:client');\nvar net = require('net');\n\nvar HeaderHostTransformer = require('./HeaderHostTransformer');\n\n// manages groups of tunnels\nvar TunnelCluster = function(opt) {\n    if (!(this instanceof TunnelCluster)) {\n        return new TunnelCluster(opt);\n    }\n\n    var self = this;\n    self._opt = opt;\n\n    EventEmitter.call(self);\n};\n\nTunnelCluster.prototype.__proto__ = EventEmitter.prototype;\n\n// establish a new tunnel\nTunnelCluster.prototype.open = function() {\n    var self = this;\n\n    var opt = self._opt || {};\n\n    var remote_host = opt.remote_host;\n    var remote_port = opt.remote_port;\n\n    var local_host = opt.local_host || 'localhost';\n    var local_port = opt.local_port;\n\n    debug('establishing tunnel %s:%s <> %s:%s', local_host, local_port, remote_host, remote_port);\n\n    // connection to localtunnel server\n    var remote = net.connect({\n        host: remote_host,\n        port: remote_port\n    });\n\n    remote.setKeepAlive(true);\n\n    remote.on('error', function(err) {\n        // emit connection refused errors immediately, because they\n        // indicate that the tunnel can't be established.\n        if (err.code === 'ECONNREFUSED') {\n            self.emit('error', new Error('connection refused: ' + remote_host + ':' + remote_port + ' (check your firewall settings)'));\n        }\n\n        remote.end();\n    });\n\n    function conn_local() {\n        if (remote.destroyed) {\n            debug('remote destroyed');\n            self.emit('dead');\n            return;\n        }\n\n        debug('connecting locally to %s:%d', local_host, local_port);\n        remote.pause();\n\n        // connection to local http server\n        var local = net.connect({\n            host: local_host,\n            port: local_port\n        });\n\n        function remote_close() {\n            debug('remote close');\n            self.emit('dead');\n            local.end();\n        };\n\n        remote.once('close', remote_close);\n\n        // TODO some languages have single threaded servers which makes opening up\n        // multiple local connections impossible. We need a smarter way to scale\n        // and adjust for such instances to avoid beating on the door of the server\n        local.once('error', function(err) {\n            debug('local error %s', err.message);\n            local.end();\n\n            remote.removeListener('close', remote_close);\n\n            if (err.code !== 'ECONNREFUSED') {\n                return remote.end();\n            }\n\n            // retrying connection to local server\n            setTimeout(conn_local, 1000);\n        });\n\n        local.once('connect', function() {\n            debug('connected locally');\n            remote.resume();\n\n            var stream = remote;\n\n            // if user requested specific local host\n            // then we use host header transform to replace the host header\n            if (opt.local_host) {\n                debug('transform Host header to %s', opt.local_host);\n                stream = remote.pipe(HeaderHostTransformer({ host: opt.local_host }));\n            }\n\n            stream.pipe(local).pipe(remote);\n\n            // when local closes, also get a new remote\n            local.once('close', function(had_error) {\n                debug('local connection closed [%s]', had_error);\n            });\n        });\n    }\n\n    remote.on('data', function(data) {\n        const match = data.toString().match(/^(\\w+) (\\S+)/);\n        if (match) {\n            self.emit('request', {\n                method: match[1],\n                path: match[2],\n            });\n        }\n    });\n\n    // tunnel is considered open when remote connects\n    remote.once('connect', function() {\n        self.emit('open', remote);\n        conn_local();\n    });\n};\n\nmodule.exports = TunnelCluster;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}